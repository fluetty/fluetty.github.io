<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>nginx学习记录</title>
      <link href="2020/11/05/nginx%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
      <url>2020/11/05/nginx%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h2 id="Nginx-简介"><a href="#Nginx-简介" class="headerlink" title="Nginx 简介"></a>Nginx 简介</h2><p>Nginx是一款免费开源、轻量级的高性能 Web服务器、反向代理服务器，它高并发性能很好，官方测试能够支撑 5 万的并发量；运行时内存和 CPU 占用率低，配置简单，容易上手，而且运行非常稳定。由于它的内存占用少，启动极快，高并发能力强，在互联网项目中广泛应用。</p><p>Nginx是由俄罗斯人Igor Sysoev 设计开发的，第一次公开发布在2004年10月4日。 <a href="http://nginx.org/">官方网站</a></p><h2 id="Nginx的常用功能"><a href="#Nginx的常用功能" class="headerlink" title="Nginx的常用功能"></a>Nginx的常用功能</h2><p>Nginx的功能特别多，详见<a href="http://nginx.org/en/">官网介绍</a> ，比较常用的功能有以下几个。</p><h3 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h3><p>这是 Nginx 服务器作为 WEB 服务器的主要功能之一，客户端向服务器发送请求时，会首先经过 Nginx 服务器，由服务器将请求分发到相应的 WEB 服务器。<strong>正向代理是代理客户端，而反向代理则是代理服务器</strong>，Nginx 在提供反向代理服务方面，通过使用正则表达式进行相关配置，采取不同的转发策略，配置相当灵活，而且在配置后端转发请求时，完全不用关心网络环境如何，可以指定任意的IP地址和端口号，或其他类型的连接、请求等。</p><h3 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h3><p>这也是 Nginx 最常用的功能之一，负载均衡，<strong>一方面是将单一的重负载分担到多个网络节点上做并行处理</strong>，每个节点处理结束后将结果汇总返回给用户，这样可以大幅度提高网络系统的处理能力；<strong>另一方面将大量的前端并发请求或数据流量分担到多个后端网络节点分别处理</strong>，这样可以有效减少前端用户等待相应的时间。而 Nginx 负载均衡都是属于后一方面，主要是<strong>对大量前端访问或流量进行分流</strong>，以保证前端用户访问效率，并可以减少后端服务器处理压力。</p><h3 id="Web缓存"><a href="#Web缓存" class="headerlink" title="Web缓存"></a>Web缓存</h3><p>缓存，是Nginx提供的，可以加快访问速度的机制，说白了，在配置上就是一个开启，同时指定目录，让缓存可以存储到磁盘上。在很多优秀的网站中，Nginx 可以作为前置缓存服务器，它被用于缓存前端请求，从而提高 Web服务器的性能。Nginx 会对用户已经访问过的内容在服务器本地建立副本，这样在一段时间内再次访问该数据，就不需要通过 Nginx 服务器向后端发出请求。减轻网络拥堵，减小数据传输延时，提高用户访问速度。</p><h2 id="Nginx的安装"><a href="#Nginx的安装" class="headerlink" title="Nginx的安装"></a>Nginx的安装</h2><p>​                参考：<a href="https://www.cnblogs.com/taiyonghai/p/6728707.html">Nginx Linux详细安装部署教程</a></p><p>​                          <a href="https://www.cnblogs.com/taiyonghai/p/9402734.html">Nginx Windows详细安装部署教程</a></p><h3 id="启动-Nginx"><a href="#启动-Nginx" class="headerlink" title="启动 Nginx"></a>启动 Nginx</h3><p>window在解压的nginx目录下 打开cmd.exe</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">start nginx</span><br></pre></td></tr></table></figure><h3 id="查看服务是否启动"><a href="#查看服务是否启动" class="headerlink" title="查看服务是否启动"></a>查看服务是否启动</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ps -ef | grep nginx</span><br></pre></td></tr></table></figure><h3 id="重启Nginx"><a href="#重启Nginx" class="headerlink" title="重启Nginx"></a>重启Nginx</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nginx -s reload</span><br></pre></td></tr></table></figure><h3 id="关闭Nginx"><a href="#关闭Nginx" class="headerlink" title="关闭Nginx"></a>关闭Nginx</h3><p>先查出nginx进程id再使用kill命令强制杀掉进程</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nginx -s stop</span><br></pre></td></tr></table></figure><p>允许 nginx 服务将当前正在处理的网络请求处理完成，但不再接收新的请求，之后关闭连接，停止工作。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nginx -s quit</span><br></pre></td></tr></table></figure><h3 id="检查配置文件语法"><a href="#检查配置文件语法" class="headerlink" title="检查配置文件语法"></a>检查配置文件语法</h3><p>指定要检查的文件</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nginx -t -c nginx/conf/nginx/conf</span><br></pre></td></tr></table></figure><p>默认检查nginx.conf配置文件</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nginx -t</span><br></pre></td></tr></table></figure><h2 id="Nginx-conf配置文件"><a href="#Nginx-conf配置文件" class="headerlink" title="Nginx.conf配置文件"></a>Nginx.conf配置文件</h2><ul><li>1、<strong>全局块</strong>：配置影响nginx全局的指令。一般有运行nginx服务器的用户组，nginx进程pid存放路径，日志存放路径，配置文件引入，允许生成worker process数等。</li><li>2、<strong>events块</strong>：配置影响nginx服务器或与用户的网络连接。有每个进程的最大连接数，选取哪种事件驱动模型处理连接请求，是否允许同时接受多个网路连接，开启多个网络连接序列化等。</li><li>3、<strong>http块</strong>：可以嵌套多个server，配置代理，缓存，日志定义等绝大多数功能和第三方模块的配置。如文件引入，mime-type定义，日志自定义，是否使用sendfile传输文件，连接超时时间，单连接请求数等。</li><li>4、<strong>server块</strong>：配置虚拟主机的相关参数，一个http中可以有多个server。</li><li>5、<strong>location块</strong>：配置请求的路由，以及各种页面的处理情况。</li></ul><p>nginx配置文件详解</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#user  nobody;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#==工作进程数，一般设置为cpu核心数</span></span><br><span class="line">worker_processes  <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">#error_log  logs/error.log;</span></span><br><span class="line"><span class="comment">#error_log  logs/error.log  notice;</span></span><br><span class="line"><span class="comment">#error_log  logs/error.log  info;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#pid        logs/nginx.pid;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">events &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">#==最大连接数，一般设置为cpu*2048</span></span><br><span class="line">    worker_connections  <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line">    include       mime.types;</span><br><span class="line">    default_type  application/octet-stream;</span><br><span class="line"></span><br><span class="line">    <span class="comment">#log_format  main  &#x27;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#x27;</span></span><br><span class="line">    <span class="comment">#                  &#x27;$status $body_bytes_sent &quot;$http_referer&quot; &#x27;</span></span><br><span class="line">    <span class="comment">#                  &#x27;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#x27;;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">#access_log  logs/access.log  main;</span></span><br><span class="line">    </span><br><span class="line">    sendfile        on;</span><br><span class="line">    <span class="comment">#tcp_nopush     on;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">#keepalive_timeout  0;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">#==客户端链接超时时间</span></span><br><span class="line">    keepalive_timeout  <span class="number">65</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#gzip  on;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">#当配置多个server节点时，默认server names的缓存区大小就不够了，需要手动设置大一点</span></span><br><span class="line">    server_names_hash_bucket_size <span class="number">512</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#server表示虚拟主机可以理解为一个站点，可以配置多个server节点搭建多个站点</span></span><br><span class="line">    <span class="comment">#每一个请求进来确定使用哪个server由server_name确定</span></span><br><span class="line">    server &#123;</span><br><span class="line">        <span class="comment">#站点监听端口</span></span><br><span class="line">        listen       <span class="number">8800</span>;</span><br><span class="line">        <span class="comment">#站点访问域名</span></span><br><span class="line">        server_name  localhost;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">#编码格式，避免url参数乱码</span></span><br><span class="line">        charset utf<span class="number">-8</span>;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">#access_log  logs/host.access.log  main;</span></span><br><span class="line">    </span><br><span class="line">        <span class="comment">#location用来匹配同一域名下多个URI的访问规则</span></span><br><span class="line">        <span class="comment">#比如动态资源如何跳转，静态资源如何跳转等</span></span><br><span class="line">        <span class="comment">#location后面跟着的/代表匹配规则</span></span><br><span class="line">        location / &#123;</span><br><span class="line">            <span class="comment">#站点根目录，可以是相对路径，也可以使绝对路径</span></span><br><span class="line">            root   html;</span><br><span class="line">            <span class="comment">#默认主页</span></span><br><span class="line">            index  index.html index.htm;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">#转发后端站点地址，一般用于做软负载，轮询后端服务器</span></span><br><span class="line">            <span class="comment">#proxy_pass http://10.11.12.237:8080;</span></span><br><span class="line">    </span><br><span class="line">            <span class="comment">#拒绝请求，返回403，一般用于某些目录禁止访问</span></span><br><span class="line">            <span class="comment">#deny all;</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">#允许请求</span></span><br><span class="line">            <span class="comment">#allow all;</span></span><br><span class="line">            </span><br><span class="line">            add_header <span class="string">&#x27;Access-Control-Allow-Origin&#x27;</span> <span class="string">&#x27;*&#x27;</span>;</span><br><span class="line">            add_header <span class="string">&#x27;Access-Control-Allow-Credentials&#x27;</span> <span class="string">&#x27;true&#x27;</span>;</span><br><span class="line">            add_header <span class="string">&#x27;Access-Control-Allow-Methods&#x27;</span> <span class="string">&#x27;GET, POST, OPTIONS&#x27;</span>;</span><br><span class="line">            add_header <span class="string">&#x27;Access-Control-Allow-Headers&#x27;</span> <span class="string">&#x27;DNT,X-CustomHeader,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type&#x27;</span>;</span><br><span class="line">            <span class="comment">#重新定义或者添加发往后端服务器的请求头</span></span><br><span class="line">            <span class="comment">#给请求头中添加客户请求主机名</span></span><br><span class="line">            proxy_set_header Host $host;</span><br><span class="line">            <span class="comment">#给请求头中添加客户端IP</span></span><br><span class="line">            proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">            <span class="comment">#将$remote_addr变量值添加在客户端“X-Forwarded-For”请求头的后面，并以逗号分隔。 如果客户端请求未携带“X-Forwarded-For”请求头，$proxy_add_x_forwarded_for变量值将与$remote_addr变量相同  </span></span><br><span class="line">            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">            <span class="comment">#给请求头中添加客户端的Cookie</span></span><br><span class="line">            proxy_set_header Cookie $http_cookie;</span><br><span class="line">            <span class="comment">#将使用代理服务器的主域名和端口号来替换。如果端口是80，可以不加。</span></span><br><span class="line">            proxy_redirect off;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">#浏览器对 Cookie 有很多限制，如果 Cookie 的 Domain 部分与当前页面的 Domain 不匹配就无法写入。</span></span><br><span class="line">            <span class="comment">#所以如果请求 A 域名，服务器 proxy_pass 到 B 域名，然后 B 服务器输出 Domian=B 的 Cookie，</span></span><br><span class="line">            <span class="comment">#前端的页面依然停留在 A 域名上，于是浏览器就无法将 Cookie 写入。</span></span><br><span class="line"></span><br><span class="line">　　         <span class="comment">#不仅是域名，浏览器对 Path 也有限制。我们经常会 proxy_pass 到目标服务器的某个 Path 下，</span></span><br><span class="line">            <span class="comment">#不把这个 Path 暴露给浏览器。这时候如果目标服务器的 Cookie 写死了 Path 也会出现 Cookie 无法写入的问题。</span></span><br><span class="line">            </span><br><span class="line"></span><br><span class="line">            <span class="comment">#设置“Set-Cookie”响应头中的domain属性的替换文本，其值可以为一个字符串、正则表达式的模式或一个引用的变量</span></span><br><span class="line">            <span class="comment">#转发后端服务器如果需要Cookie则需要将cookie domain也进行转换，否则前端域名与后端域名不一致cookie就会无法存取</span></span><br><span class="line"></span><br><span class="line">　　　　　　  <span class="comment">#配置规则：proxy_cookie_domain serverDomain(后端服务器域) nginxDomain(nginx服务器域)</span></span><br><span class="line">            proxy_cookie_domain localhost .testcaigou800.com;</span><br><span class="line">            </span><br><span class="line"></span><br><span class="line">            <span class="comment">#取消当前配置级别的所有proxy_cookie_domain指令</span></span><br><span class="line">            <span class="comment">#proxy_cookie_domain off;</span></span><br><span class="line">            <span class="comment">#与后端服务器建立连接的超时时间。一般不可能大于75秒；</span></span><br><span class="line">            proxy_connect_timeout <span class="number">30</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">#error_page  404              /404.html;</span></span><br><span class="line">    </span><br><span class="line">        <span class="comment"># redirect server error pages to the static page /50x.html</span></span><br><span class="line">        <span class="comment">#</span></span><br><span class="line">        error_page   <span class="number">500</span> <span class="number">502</span> <span class="number">503</span> <span class="number">504</span>  /<span class="number">50</span>x.html;</span><br><span class="line">        location = /<span class="number">50</span>x.html &#123;</span><br><span class="line">            root   html;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">　　<span class="comment">#当需要对同一端口监听多个域名时，使用如下配置，端口相同域名不同，server_name也可以使用正则进行配置</span></span><br><span class="line">　　<span class="comment">#但要注意server过多需要手动扩大server_names_hash_bucket_size缓存区大小</span></span><br><span class="line">　　server &#123;</span><br><span class="line">　　　　listen <span class="number">80</span>;</span><br><span class="line">　　　　server_name www.abc.com;</span><br><span class="line">　　　　charset utf<span class="number">-8</span>;</span><br><span class="line">　　　　location / &#123;</span><br><span class="line">　　　　　　proxy_pass http://localhost:<span class="number">10001</span>;</span><br><span class="line">　　　　&#125;</span><br><span class="line">　　&#125;</span><br><span class="line">　　server &#123;</span><br><span class="line">　　　　listen <span class="number">80</span>;</span><br><span class="line">　　　　server_name aaa.abc.com;</span><br><span class="line">　　　　charset utf<span class="number">-8</span>;</span><br><span class="line">　　　　location / &#123;</span><br><span class="line">　　　　　　proxy_pass http://localhost:<span class="number">20002</span>;</span><br><span class="line">　　　　&#125;</span><br><span class="line">　　&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Nginx反向代理详解"><a href="#Nginx反向代理详解" class="headerlink" title="Nginx反向代理详解"></a>Nginx反向代理详解</h2><h3 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h3><p><strong>正向代理代理客户端，反向代理代理服务器。</strong></p><h4 id="正向代理"><a href="#正向代理" class="headerlink" title="正向代理"></a>正向代理</h4><p>正向代理指的是，一个位于客户端和原始服务器之间的服务器，为了从原始服务器取得内容，客户端向代理发送一个请求并指定目标(原始服务器)，然后代理向原始服务器转交请求并将获得的内容返回给客户端。</p><h4 id="反向代理-1"><a href="#反向代理-1" class="headerlink" title="反向代理"></a>反向代理</h4><p>反向代理（Reverse Proxy）方式是指以代理服务器来接受Internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给Internet上请求连接的客户端，此时代理服务器对外就表现为一个服务器。</p><h3 id="为什么使用反向代理？"><a href="#为什么使用反向代理？" class="headerlink" title="为什么使用反向代理？"></a>为什么使用反向代理？</h3><ul><li>可以起到保护网站安全的作用，因为任何来自Internet的请求都必须先经过代理服务器。</li><li>通过缓存静态资源，加速Web请求。</li><li>实现负载均衡。目前市面上，主流的负载均衡方案：硬件设备有F5，软件方案有四层负载均衡的LVS，七层负载均衡的Nginx、Haproxy等。</li></ul><p><strong>链接：<a href="https://www.cnblogs.com/ysocean/p/9392908.html#_label3">nginx 反向代理详解</a></strong></p><h3 id="Nginx的Master-Worker模式"><a href="#Nginx的Master-Worker模式" class="headerlink" title="Nginx的Master-Worker模式"></a>Nginx的Master-Worker模式</h3><p>启动Nginx后，其实就是在80端口启动了Socket服务进行监听，如图所示，Nginx涉及Master进程和Worker进程。</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/fluetty/clouding/main/data/nginx-Master-Worker.jpg" alt="nginx-Master-Worker"></p><h4 id="Master进程的作用"><a href="#Master进程的作用" class="headerlink" title="Master进程的作用"></a>Master进程的作用</h4><p>读取并验证配置文件nginx.conf；管理worker进程；</p><h4 id="Worker进程的作用"><a href="#Worker进程的作用" class="headerlink" title="Worker进程的作用"></a>Worker进程的作用</h4><p>每一个Worker进程都维护一个线程（避免线程切换），处理连接和请求；注意Worker进程的个数由配置文件决定，一般和CPU个数相关（有利于进程切换），配置几个就有几个Worker进程。</p><h2 id="Nginx负载均衡"><a href="#Nginx负载均衡" class="headerlink" title="Nginx负载均衡"></a>Nginx负载均衡</h2><p>在反向代理中，可以通过proxy_pass来指定Tomcat的地址，很显然只能指定一台Tomcat地址，那么如果想指定多台来达到负载均衡呢？</p><p>第一，通过<strong>upstream</strong>来定义一组Tomcat，并指定负载策略（IPHASH、加权论调、最少连接），健康检查策略（Nginx可以监控这一组Tomcat的状态）等。</p><p>第二，将proxy_pass替换成upstream指定的值即可。</p><h3 id="负载均衡可能带来的问题"><a href="#负载均衡可能带来的问题" class="headerlink" title="负载均衡可能带来的问题"></a>负载均衡可能带来的问题</h3><p>负载均衡所带来的明显的问题是，一个请求，可以到A server，也可以到B server，这完全不受控制，当然这也不是什么问题，只是得注意：<strong>用户状态的保存问题，如Session会话信息，不能在保存到服务器上。</strong></p><h3 id="查看链接：-nginx-负载均衡详解"><a href="#查看链接：-nginx-负载均衡详解" class="headerlink" title="查看链接： nginx 负载均衡详解"></a>查看链接： <a href="https://www.cnblogs.com/ysocean/p/9392912.html">nginx 负载均衡详解</a></h3><h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><h3 id="Nginx如何做到热部署？"><a href="#Nginx如何做到热部署？" class="headerlink" title="Nginx如何做到热部署？"></a>Nginx如何做到热部署？</h3><p>所谓热部署，就是配置文件nginx.conf修改后，不需要stop Nginx，不需要中断请求，就能让配置文件生效。（nginx -s reload 重新加载/nginx -t检查配置/nginx -s stop）</p><p>worker进程负责处理具体的请求，那么如果想达到热部署的效果，可以想象：</p><p><strong>方案一：</strong></p><p>修改配置文件nginx.conf后，主进程master负责推送给woker进程更新配置信息，woker进程收到信息后，更新进程内部的线程信息。（有点valatile的味道）</p><p><strong>方案二：</strong></p><p>修改配置文件nginx.conf后，重新生成新的worker进程，当然会以新的配置进行处理请求，而且新的请求必须都交给新的worker进程，至于老的worker进程，等把那些以前的请求处理完毕后，kill掉即可。</p><p><strong>Nginx采用的就是方案二来达到热部署的。</strong></p><h3 id="Nginx如何做到高并发下的高效处理？"><a href="#Nginx如何做到高并发下的高效处理？" class="headerlink" title="Nginx如何做到高并发下的高效处理？"></a>Nginx如何做到高并发下的高效处理？</h3><p>Nginx的worker进程个数与CPU绑定、worker进程内部包含一个线程高效回环处理请求，这的确有助于效率，但这是不够的。</p><p>要同时处理那么多的请求，要知道，有的请求需要发生IO，可能需要很长时间，如果等着它，就会拖慢worker的处理速度。</p><p><strong>Nginx采用了Linux的epoll模型，epoll模型基于事件驱动机制，它可以监控多个事件是否准备完毕，如果OK，那么放入epoll队列中，这个过程是异步的。worker只需要从epoll队列循环处理即可。</strong></p><h3 id="Nginx挂掉怎么办？"><a href="#Nginx挂掉怎么办？" class="headerlink" title="Nginx挂掉怎么办？"></a>Nginx挂掉怎么办？</h3><p><strong>Keepalived+Nginx实现高可用</strong>。</p><p>Keepalived是一个高可用解决方案，主要是用来防止服务器单点发生故障，可以通过和Nginx配合来实现Web服务的高可用。（其实，Keepalived不仅仅可以和Nginx配合，还可以和很多其他服务配合）</p><p>Keepalived+Nginx实现高可用的思路：</p><p>第一：请求不要直接打到Nginx上，应该先通过Keepalived（这就是所谓虚拟IP，VIP）</p><p>第二：Keepalived应该能监控Nginx的生命状态（提供一个用户自定义的脚本，定期检查Nginx进程状态，进行权重变化,，从而实现Nginx故障切换）</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/fluetty/clouding/main/data/nginx+keepalived.jpg" alt="nginx+keepalived"></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://zhuanlan.zhihu.com/p/34943332">8分钟带你深入浅出搞懂Nginx</a><br><a href="https://www.cnblogs.com/ysocean/p/9392908.html#_label3">nginx 反向代理详解</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>开源API网关Kong笔记</title>
      <link href="2020/11/05/%E5%BC%80%E6%BA%90API%E7%BD%91%E5%85%B3Kong%E7%AC%94%E8%AE%B0/"/>
      <url>2020/11/05/%E5%BC%80%E6%BA%90API%E7%BD%91%E5%85%B3Kong%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是API网关？"><a href="#什么是API网关？" class="headerlink" title="什么是API网关？"></a>什么是API网关？</h2><p>API 网关并非一个新兴的概念，在十几年前就已经存在了，它的作用主要是作为流量的入口，统一的处理和业务相关的请求，让请求更加安全、快速和准确的得到处理。</p><p>它有以下传统的功能：</p><ol><li><p>反向代理和负载均衡，这和 Nginx 的定位和功能是一致的；</p></li><li><p>动态上游、动态 SSL 证书和动态限流限速等运行时的动态功能，这是开源版本 Nginx并不具备的功能；</p></li><li><p>上游的主动和被动健康检查，以及服务熔断；</p></li><li><p>在 API 网关的基础之上进行扩展，成为全生命周期的 API 管理平台。</p></li></ol><h2 id="Kong简介"><a href="#Kong简介" class="headerlink" title="Kong简介"></a>Kong简介</h2><p>Kong基于<strong>Nginx</strong>，利用了其稳定性和高效率。Kong是Mashape开源的高性能高可用API网关和API服务管理层。</p><p>Kong是一个在Nginx中运行的Lua应用程序，并且可以通过lua-nginx模块实现。Kong不是用这个模块编译Nginx，而是与OpenResty一起分发，OpenResty已经包含了lua-nginx-module。OpenResty不是Nginx的分支，而是一组扩展其功能的模块。Kong基于OpenResty，进行API管理，并提供了插件实现API的AOP。</p><p> 这为可插拔架构奠定了基础，可以在运行时启用和执行Lua脚本（称为“插件”）。 因此，我们认为Kong是微服务架构的典范：它的核心是<strong>实现数据库抽象，路由和插件管理</strong>。 插件可以存在于单独的代码库中，并且可以在几行代码中注入到请求生命周期的任何位置。</p><p>目前互联网后台架构一般是采用微服务，或者类似微服务的形式，应用的请求通常需要访问多个后台系统。如果让每一个后台系统都实现鉴权、限流、<a href="https://cloud.tencent.com/product/clb?from=10680">负载均衡</a>、审计等基础功能是不合适的，通用的做法是把这些功能抽离出来放到网关层。Kong是目前最流行的网关平台。</p><h2 id="Kong的基本架构"><a href="#Kong的基本架构" class="headerlink" title="Kong的基本架构"></a>Kong的基本架构</h2><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/fluetty/clouding/main/data/view.png" alt="view"></p><h3 id="Kong-默认绑定4个端口"><a href="#Kong-默认绑定4个端口" class="headerlink" title="Kong 默认绑定4个端口"></a>Kong 默认绑定4个端口</h3><ul><li>:8000 用来接受用户的HTTP请求，并转发到后台系统</li><li>:8443 用来接受用户的HTTPS请求，并转发到后台系统</li><li>:8001 通过HTTP协议提供管理功能的API （Admin API）</li><li>:8444 通过HTTPS协议提供管理功能的API</li></ul><p>这些端口可以在**/etc/kong/kong.conf**中修改，当然我们可以把Admin API作为一个服务通过kong的网关暴露出去。</p><h3 id="Kong-主要有三个组件"><a href="#Kong-主要有三个组件" class="headerlink" title="Kong 主要有三个组件"></a>Kong 主要有三个组件</h3><ul><li>Kong Server ：基于nginx的服务器，用来接收 API 请求。</li><li>Apache Cassandra/PostgreSQL：用来存储操作数据。</li><li>Kong dashboard：官方推荐 UI 管理工具，当然，也可以使用 restfull 方式管理 admin api。</li></ul><p>Kong 采用插件机制进行功能定制，插件集（可以是 0 或 N 个）在 API 请求响应循环的生命周期中被执行。<strong>插件使用 Lua 编写</strong>，基础功能包括：HTTP 基本认证、密钥认证、CORS（Cross-Origin Resource Sharing，跨域资源共享）、TCP、UDP、文件日志、API 请求限流、请求转发以及 Nginx 监控等。</p><h3 id="Kong-网关具有以下的特性"><a href="#Kong-网关具有以下的特性" class="headerlink" title="Kong 网关具有以下的特性"></a>Kong 网关具有以下的特性</h3><ul><li>可扩展性: 通过简单地添加更多的服务器，可以轻松地进行横向扩展，这意味着您的平台可以在一个较低负载的情况下处理任何请求；</li><li>模块化: 可以通过添加新的插件进行扩展，这些插件可以通过RESTful Admin API轻松配置；</li><li>在任何基础架构上运行: Kong 网关可以在任何地方都能运行。可以在云或内部网络环境中部署 Kong，包括单个或多个数据中心设置，以及 public，private 或 invite-only APIs。</li></ul><h2 id="相关术语"><a href="#相关术语" class="headerlink" title="相关术语"></a>相关术语</h2><ul><li><p>Route：是请求的转发规则，按照Hostname和PATH，将请求转发给Service。<strong>路由是定义对这个服务暴露给客户端的请求路径及请求方式。服务与路由是1对多的关系，一个服务可以以多种路由方式暴露给前端访问，该服务对应的上游服务就是1个API</strong>。  告诉Kong怎么把网关收到的请求发送到某个特定的后台服务。</p></li><li><p>Services：是多个Upstream的集合，是Route的转发目标。<strong>不要把Services当作后端的具体API，要把它当作一个大的服务，该服务下面有多个API（endpoint or route）</strong>。</p></li><li><p>Consumer：是API的用户，里面记录用户的一些信息。</p></li><li><p>Plugin：是插件，plugin可以是全局的，绑定到Service，绑定到Router，绑定到Consumer。</p></li><li><p>Certificate：是https证书。</p></li><li><p>Sni：是域名与Certificate的绑定，指定了一个域名对应的https证书。</p></li><li><p>Upstream：表示虚拟主机名，可用于通过多个服务（目标）对传入请求进行负载均衡。例如：service.v1.xyz 为Service对象命名的上游host是service.v1.xyz对此服务的请求将代理到上游定义的目标。</p></li><li><p>Target：目标IP地址/主机名，其端口表示后端服务的实例,是最终处理请求的Backend服务。每个上游都可以有多个target,并且可以动态添加Target。 由于Upstream维护Target的更改历史记录，因此无法删除或者修改Target。要禁用目标，请发布一个新的Target weight=0,或者使用DELETE来完成相同的操作。</p></li></ul><h2 id="Kong插件的格式"><a href="#Kong插件的格式" class="headerlink" title="Kong插件的格式"></a>Kong插件的格式</h2><p>一个完整的插件目录结构应该像下面这样：</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/fluetty/clouding/main/data/image-20200831151628965.png" alt="image-20200831151628965"></p><p>各个模块的功能：</p><table><thead><tr><th>模块名</th><th>描述</th><th>是否必需</th></tr></thead><tbody><tr><td>api.lua</td><td>插件需要向 Admin API 暴露接口时使用</td><td>N</td></tr><tr><td>daos.lua</td><td>数据层相关，当插件需要访问数据库时配置</td><td>N</td></tr><tr><td>handler.lua</td><td>插件的主要逻辑，这个将会被 Kong 在不同阶段执行其对应的 handler</td><td>Y</td></tr><tr><td>migrations / *.lua</td><td>插件依赖的数据表结构，启用了 daos.lua 时需要定义</td><td>N</td></tr><tr><td>schema.lua</td><td>插件的配置参数定义，主要用于 Kong 参数验证</td><td>Y</td></tr></tbody></table><p>其中 handler.lua 和 schema.lua 是必需的（rbac_charing下也是只有这两个），上面提到的插件需要暴露出来的方法就定义在 handler.lua 中。</p><p><strong>kong插件主要有三个文件</strong>：</p><p>handler.lua 是包含插件逻辑处理相关代码。 schema.lua 包含插件的配置文件。 rockspec 文件是通过luarock安装时用的配置文件。</p><p>逻辑处理的代码根据openResty的不同处理阶段分成了不同的函数，根据插件的功能只需要在不同的函数中添加自己的业务逻辑。</p><h2 id="跟路径（path）有关的参数"><a href="#跟路径（path）有关的参数" class="headerlink" title="跟路径（path）有关的参数"></a>跟路径（path）有关的参数</h2><ol><li> route中的paths参数，表示符合这些请求路径要发到route对应的service中</li><li> route中的strip_path 参数，决定kong转发给后端的时候是否保留源请求用于路由匹配的路径</li><li>service中的path参数，默认为null，kong转发请求时会把这个作为前缀加上</li></ol><p>假设网关以<code>/api</code>为路由把请求转发给nodedemo（即<code>route.paths = [&#39;/api&#39;]</code>)，它们的组合关系如下：</p><table><thead><tr><th>strip_path</th><th>service.path</th><th>请求地址</th><th>网关实际访问后端地址</th></tr></thead><tbody><tr><td>true</td><td>null 或者 /</td><td><a href="http://127.0.0.1/api/demo">http://127.0.0.1/api/demo</a></td><td><a href="http://127.0.0.1:8080/demo">http://127.0.0.1:8080/demo</a></td></tr><tr><td>true</td><td>/test</td><td><a href="http://127.0.0.1/api/demo">http://127.0.0.1/api/demo</a></td><td><a href="http://127.0.0.1:8080/test/demo">http://127.0.0.1:8080/test/demo</a></td></tr><tr><td>false</td><td>null 或者 /</td><td><a href="http://127.0.0.1/api/demo">http://127.0.0.1/api/demo</a></td><td><a href="http://127.0.0.1:8080/api/demo">http://127.0.0.1:8080/api/demo</a></td></tr><tr><td>false</td><td>/test</td><td><a href="http://127.0.0.1/api/demo">http://127.0.0.1/api/demo</a></td><td><a href="http://127.0.0.1:8080/test/api/demo">http://127.0.0.1:8080/test/api/demo</a></td></tr></tbody></table><p>以最后一行为例，相当于访问 <a href="http://127.0.0.1/api/demo">http://127.0.0.1/api/demo</a> 时，实际访问的是<code>/test/api/demo</code>，也就是把 service.path (/test）跟实际请求的路径(/api/demo)拼接起来发给后端。</p><p>配置route时候：这里的 Path 就是具体业务API的路径（endpoint）。Hosts不设置会默认采用Services里的Host，但是一旦设置了，客户端请求该route的时候必须带上设置的host，且必须一致。</p><p>如果Strip path设置为YES，这里的 Path 可以加一个前缀，如：/passport/users，但最终会映射到后端真实的API /users。Kong转发到后端服务的时候会把前缀/passport部分去掉。客户端调用API必须和Routes里的Path一致才行（/passport/users），否则会得到404，无法匹配。用户的请求是先匹配route，然后转发到service。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="http://blog.didispace.com/hzf-ms-apigateway-2/">微服务与API 网关（下）- Kong能为我们做什么？</a></p><p><a href="https://segmentfault.com/a/1190000019857235">企业级API网关Kong系列</a></p><p><a href="https://ms2008.github.io/2018/05/14/kong-plugin-load/">Kong 插件加载机制概述</a></p><p><a href="https://www.cnblogs.com/SummerinShire/p/6925308.html">Kong-负载均衡参考</a></p><p><a href="https://www.jianshu.com/p/b65259021d2b">Kong负载均衡的实现</a></p><p><a href="%5Bhttps://www.lijiaocn.com/%E9%A1%B9%E7%9B%AE/2018/11/20/kong-features-16-work-process.html#%E4%BB%8E-upstream-%E5%88%B0-target%5D(https://www.lijiaocn.com/%E9%A1%B9%E7%9B%AE/2018/11/20/kong-features-16-work-process.html#%E4%BB%8E-upstream-%E5%88%B0-target)">upstream和target详解</a></p>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> learn </tag>
            
            <tag> kong </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker常用指令</title>
      <link href="2020/11/05/Docker%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/"/>
      <url>2020/11/05/Docker%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<p><strong>简介：</strong>Docker 是一个开源的应用容器引擎，基于 Go 语言开发，Docker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的系统。</p><p>docker本质就是宿主机的一个进程，docker是通过namespace实现资源隔离，通过cgroup实现资源限制，通过写时复制技术（copy-on-write）实现了高效的文件操作（类似虚拟机的磁盘比如分配500g并不是实际占用物理磁盘500g）</p><h2 id="Docker-三个核心概念"><a href="#Docker-三个核心概念" class="headerlink" title="Docker 三个核心概念"></a>Docker 三个核心概念</h2><h3 id="镜像（Image）"><a href="#镜像（Image）" class="headerlink" title="镜像（Image）"></a>镜像（Image）</h3><p>是一个包含有文件系统的面向 Docker 引擎的只读模板。任何应用程序运行都需要环境，而镜像就是用来提供这种运行环境的。例如一个 Ubuntu 镜像就是一个包含 Ubuntu 操作系统环境的模板。Docker 把应用程序及其依赖，打包在 image 文件里面。只有通过这个文件，才能生成 Docker 容器。image 文件可以看作是容器的模板。Docker 根据 image 文件生成容器的实例。同一个 image 文件，可以生成多个同时运行的容器实例。</p><h3 id="容器（Container）"><a href="#容器（Container）" class="headerlink" title="容器（Container）"></a>容器（Container）</h3><p>类似于一个轻量级的沙盒，可以将其看作一个极简的 Linux 系统环境（包括 root 权限、进程空间、用户空间和网络空间等），以及运行在其中的应用程序。Docker 引擎利用容器来运行、隔离各个应用。</p><p>容器是镜像创建的应用实例，可以创建、启动、停止、删除容器，各个容器之间是是相互隔离的，互不影响。</p><p>注意：镜像本身是只读的，容器从镜像启动时，Docker 在镜像的上层创建一个可写层，镜像本身不变。</p><h3 id="仓库（Repository）"><a href="#仓库（Repository）" class="headerlink" title="仓库（Repository）"></a>仓库（Repository）</h3><p>镜像仓库，是 Docker 用来集中存放镜像文件的地方。</p><h2 id="Docker常用命令"><a href="#Docker常用命令" class="headerlink" title="Docker常用命令"></a>Docker常用命令</h2><p>Docker 的常用命令一般分为：镜像管理、容器管理。</p><h3 id="查看-Docker-版本"><a href="#查看-Docker-版本" class="headerlink" title="查看 Docker 版本"></a>查看 Docker 版本</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker version</span><br></pre></td></tr></table></figure><h3 id="列出常用命令"><a href="#列出常用命令" class="headerlink" title="列出常用命令"></a>列出常用命令</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker --help</span><br></pre></td></tr></table></figure><h3 id="镜像管理命令"><a href="#镜像管理命令" class="headerlink" title="镜像管理命令"></a>镜像管理命令</h3><p>下面使用 busybox 软件作为示例，busybox 软件是一个集成了非常多最常用的 Linux 命令和工具的软件集合。</p><h4 id="查看所有镜像"><a href="#查看所有镜像" class="headerlink" title="查看所有镜像"></a>查看所有镜像</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker images</span><br><span class="line">docker images ls</span><br></pre></td></tr></table></figure><ul><li><p>REPOSITORY：镜像来自哪个仓库</p></li><li><p>TAG：镜像的标签信息，版本之类的信息</p></li><li><p>IMAGE ID：镜像创建时的id</p></li><li><p>CREATED：镜像创建的时间</p></li><li><p>SIZE：镜像文件大小</p></li></ul><h4 id="下载软件镜像"><a href="#下载软件镜像" class="headerlink" title="下载软件镜像"></a>下载软件镜像</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker pull busybox:latest</span><br></pre></td></tr></table></figure><p>备注：latest 表示使用 busybox 软件的最新版本，所以软件默认下载都是 latest 版本。</p><h4 id="导出镜像"><a href="#导出镜像" class="headerlink" title="导出镜像"></a>导出镜像</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker save busybox &gt; busybox.tar</span><br></pre></td></tr></table></figure><p>备注：把 busybox 镜像导出为 busybox.tar 文件，可以把 busybox.tar 文件复制到别的操作系统上使用，免除下载时网络慢的问题。</p><h4 id="删除镜像"><a href="#删除镜像" class="headerlink" title="删除镜像"></a>删除镜像</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker rmi busybox:latest</span><br></pre></td></tr></table></figure><p>备注：镜像一般都会根据版本打包，如果有下载一个软件的多个版本就需要指定具体版本信息。如 busybox:1.26 就会删除 busybox 软件的 1.26 版本的镜像，不会删除latest 版本的镜像。</p><h4 id="导入镜像"><a href="#导入镜像" class="headerlink" title="导入镜像"></a>导入镜像</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker load &lt; busybox.tar</span><br></pre></td></tr></table></figure><p>备注：使用导出命令导出的镜像，可以通过此命令导入到没有下载此软件的操作系统，方便网络条件差的情况使用。</p><h4 id="更改镜像名"><a href="#更改镜像名" class="headerlink" title="更改镜像名"></a>更改镜像名</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker tag busybox:latest busybox:test</span><br></pre></td></tr></table></figure><p>备注：busybox:latest原镜像名，busybox:test要改成的镜像名</p><h3 id="容器管理命令"><a href="#容器管理命令" class="headerlink" title="容器管理命令"></a><strong>容器管理命令</strong></h3><h4 id="运行容器"><a href="#运行容器" class="headerlink" title="运行容器"></a>运行容器</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d --name=busybox busybox:latest ping 114.114.114.114</span><br><span class="line">docker container run -p 8000:3000 -it demo:0.0.1 /bin/bash</span><br></pre></td></tr></table></figure><ul><li><code>run</code>：run参数代表启动容器</li><li><code>-d</code>：以后台daemon的方式运行</li><li><code>--name</code>：指定一个容器的名字，此后操作都需要使用这个名字来定位容器。</li><li><code>busybox:latest</code>：容器所使用的镜像名字</li><li><code>ping 114.114.114.114</code>：启动容器执行的命令</li></ul><h4 id="查看运行的容器"><a href="#查看运行的容器" class="headerlink" title="查看运行的容器"></a>查看运行的容器</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker ps</span><br><span class="line">docker container ls</span><br></pre></td></tr></table></figure><h4 id="查看所有容器"><a href="#查看所有容器" class="headerlink" title="查看所有容器"></a>查看所有容器</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker ps -a</span><br></pre></td></tr></table></figure><ul><li><code>CONTAINER ID</code>：容器启动的id</li><li><code>IMAGE</code>：使用哪个镜像启动的容器</li><li><code>COMMAND</code>：启动容器的命令</li><li><code>CREATED</code>：创建容器的时间</li><li><code>STATUS</code>：容器启动时间</li><li><code>PORTS</code>：容器映射到宿主机的端口</li><li><code>NAMES</code>：容器启动的名字</li></ul><h4 id="启动容器"><a href="#启动容器" class="headerlink" title="启动容器"></a>启动容器</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker start busybox</span><br></pre></td></tr></table></figure><h4 id="重新启动容器"><a href="#重新启动容器" class="headerlink" title="重新启动容器"></a>重新启动容器</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker restart busybox</span><br></pre></td></tr></table></figure><h4 id="停止容器"><a href="#停止容器" class="headerlink" title="停止容器"></a>停止容器</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker stop busybox</span><br></pre></td></tr></table></figure><h4 id="杀死容器"><a href="#杀死容器" class="headerlink" title="杀死容器"></a>杀死容器</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker kill busybox</span><br></pre></td></tr></table></figure><h4 id="清理所有终止状态的容器"><a href="#清理所有终止状态的容器" class="headerlink" title="清理所有终止状态的容器"></a>清理所有终止状态的容器</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker container prune</span><br></pre></td></tr></table></figure><h4 id="列出容器映射的端口"><a href="#列出容器映射的端口" class="headerlink" title="列出容器映射的端口"></a>列出容器映射的端口</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker port busybox</span><br></pre></td></tr></table></figure><h4 id="查看容器内部运行的进程"><a href="#查看容器内部运行的进程" class="headerlink" title="查看容器内部运行的进程"></a>查看容器内部运行的进程</h4><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">docker top busybox</span><br></pre></td></tr></table></figure><h4 id="查看容器或镜像底层信息"><a href="#查看容器或镜像底层信息" class="headerlink" title="查看容器或镜像底层信息"></a>查看容器或镜像底层信息</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker inspect busybox</span><br></pre></td></tr></table></figure><h4 id="删除运行中的容器"><a href="#删除运行中的容器" class="headerlink" title="删除运行中的容器"></a>删除运行中的容器</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker rm -f busybox</span><br></pre></td></tr></table></figure><h4 id="执行容器内命令"><a href="#执行容器内命令" class="headerlink" title="执行容器内命令"></a>执行容器内命令</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker exec -it busybox ls</span><br><span class="line">docker exec -it busybox /bin/bash</span><br></pre></td></tr></table></figure><p>备注：-it 交互终端</p><h4 id="复制容器内文件"><a href="#复制容器内文件" class="headerlink" title="复制容器内文件"></a>复制容器内文件</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker cp busybox:/etc/hosts hosts</span><br></pre></td></tr></table></figure><h4 id="查看容器日志"><a href="#查看容器日志" class="headerlink" title="查看容器日志"></a>查看容器日志</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker logs -f busybox</span><br><span class="line">docker logs [OPTIONS] busybox</span><br></pre></td></tr></table></figure><p>OPTIONS说明：</p><ul><li><code>-f</code>：跟踪日志输出</li><li><code>--since</code>：显示某个开始时间的所有日志</li><li><code>-t</code>：显示时间戳</li><li><code>--tail</code>：仅列出最新N条容器日志</li></ul><h2 id="docker-compose"><a href="#docker-compose" class="headerlink" title="docker-compose"></a>docker-compose</h2><p>Compose 是用于定义和运行多容器 Docker 应用程序的工具。通过 Compose，可以使用 YML 文件来配置应用程序需要的所有服务。然后使用一个命令，就可以从 YML 文件配置中创建并启动所有服务。  compose命令大多依赖于yml文件，默认使用当前目录下的“docker-compose.yml“，也可以通过－f指定。</p><h4 id="构建建启动nignx容器"><a href="#构建建启动nignx容器" class="headerlink" title="构建建启动nignx容器"></a>构建建启动nignx容器</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker-compose up -d nginx          </span><br></pre></td></tr></table></figure><h4 id="进入到nginx容器中"><a href="#进入到nginx容器中" class="headerlink" title="进入到nginx容器中"></a>进入到nginx容器中</h4> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker-compose exec nginx bash     </span><br></pre></td></tr></table></figure><h4 id="删除所有nginx容器-镜像"><a href="#删除所有nginx容器-镜像" class="headerlink" title="删除所有nginx容器,镜像"></a>删除所有nginx容器,镜像</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker-compose down         </span><br></pre></td></tr></table></figure><h4 id="重新启动nginx容器"><a href="#重新启动nginx容器" class="headerlink" title="重新启动nginx容器"></a>重新启动nginx容器</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker-compose restart nginx</span><br></pre></td></tr></table></figure><h4 id="在php-fpm中不启动关联容器，并容器执行php-v-执行完成后删除容器"><a href="#在php-fpm中不启动关联容器，并容器执行php-v-执行完成后删除容器" class="headerlink" title="在php-fpm中不启动关联容器，并容器执行php -v 执行完成后删除容器"></a>在php-fpm中不启动关联容器，并容器执行php -v 执行完成后删除容器</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker-compose run --no-deps --rm php-fpm php -v </span><br></pre></td></tr></table></figure><h4 id="构建镜像"><a href="#构建镜像" class="headerlink" title="构建镜像"></a>构建镜像</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker-compose build nginx  </span><br></pre></td></tr></table></figure><h4 id="不带缓存的构建"><a href="#不带缓存的构建" class="headerlink" title="不带缓存的构建"></a>不带缓存的构建</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker-compose build --no-cache nginx </span><br></pre></td></tr></table></figure><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://www.cnblogs.com/edisonchou/p/dockerfile_inside_introduction.html">你必须知道的Dockerfile</a></p><p><a href="https://www.cnblogs.com/moxiaoan/p/9299404.html">Docker-compose常用命令</a></p>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
            <tag> learn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PicGo+GitHub实现免费图床</title>
      <link href="2020/11/04/PicGo-GitHub%E5%AE%9E%E7%8E%B0%E5%85%8D%E8%B4%B9%E5%9B%BE%E5%BA%8A/"/>
      <url>2020/11/04/PicGo-GitHub%E5%AE%9E%E7%8E%B0%E5%85%8D%E8%B4%B9%E5%9B%BE%E5%BA%8A/</url>
      
        <content type="html"><![CDATA[<p>为了方便自己学习和工作两台电脑.md文件中图片的同步，所以了解到PicGo和Github实现免费图床，特将操作过程记录下来。</p><h2 id="图床"><a href="#图床" class="headerlink" title="图床"></a>图床</h2><p>图床一般就是指存储图片的服务器。图床一般是指储存图片的服务器，有国内和国外之分。国外的图床由于有空间距离等因素决定访问速度很慢影响图片显示速度。国内也分为单线空间、多线空间和cdn加速三种。<a href="https://baike.baidu.com/item/%E5%9B%BE%E5%BA%8A/10721348?fr=aladdin">百度百科</a></p><p>简单来说上传图片后会得到图片的链接，这样就可以通过此链接来查看图片，方便迁移。</p><h2 id="PicGo"><a href="#PicGo" class="headerlink" title="PicGo"></a>PicGo</h2><p><a href="https://molunerfinn.com/PicGo/">PicGo</a> 是一款图片上传的工具, 支持SM.MS图床，微博图床，七牛图床，腾讯云COS，阿里云OSS，Imgur，又拍云，<code>GitHub</code>等图床。我选择的是集成<code>GitHub</code>。</p><p>可以使用此工具将本地的图片文件上传到<code>GitHub</code>个人仓库中，方便快捷，markdown中图片不用再使用本地图片链接。<strong>需要注意的是隐私性问题，GitHub中你公开的仓库别人是可以访问的，也就是你的图片别人是可以看到的。</strong></p><p>安装完成后主界面是这样的。</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/fluetty/clouding/main/data/image-20201022155435359.png" alt="image-20201022155435359"></p><h2 id="GitHUb新建仓库"><a href="#GitHUb新建仓库" class="headerlink" title="GitHUb新建仓库"></a>GitHUb新建仓库</h2><ol><li>注册GitHub账号，有账号则直接登录。点击右上角头像旁加号，新建仓库。</li></ol><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/fluetty/clouding/main/data/image-20201022155606104.png" alt="image-20201022155606104"></p><p>2.设置仓库的名字，注意要设置成public</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/fluetty/clouding/main/data/image-20201022155657318.png" alt="image-20201022155657318"></p><h2 id="生成密钥"><a href="#生成密钥" class="headerlink" title="生成密钥"></a>生成密钥</h2><ol><li>点击右上角头像，选择settings</li></ol><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/fluetty/clouding/main/data/image-20201022155910865.png" alt="image-20201022155910865"></p><p>2.选择左侧 Developer settings</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/fluetty/clouding/main/data/image-20201022160948997.png" alt="image-20201022160948997"></p><p>3.生成新的token,note随意填写。</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/fluetty/clouding/main/data/image-20201022161231153.png" alt="image-20201022161231153"></p><p>4.复制保存新生成的token串</p><h2 id="PicGo配置图床"><a href="#PicGo配置图床" class="headerlink" title="PicGo配置图床"></a>PicGo配置图床</h2><ol><li><p>配置时候需要注意，分支名现在为main,不再是mater了。</p></li><li><p>指定存储路径，会在仓库下建个同名的文件夹。</p></li><li><p>自定义域名的作用是在上传图片后成功后，<code>PicGo</code>会将“自定义域名+上传的图片名”生成的访问链接，放到剪切板上<a href="https://raw.githubusercontent.com/%E7%94%A8%E6%88%B7%E5%90%8D/%E4%BB%93%E5%BA%93%E5%90%8D/main%EF%BC%8C%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9F%9F%E5%90%8D%E9%9C%80%E8%A6%81%E6%8C%89%E7%85%A7%E8%BF%99%E6%A0%B7%E5%8E%BB%E5%A1%AB%E5%86%99">https://raw.githubusercontent.com/用户名/仓库名/main，自定义域名需要按照这样去填写</a></p></li><li><p>通过上传区可以测试上传，成功后GitHub中会有新建的文件夹和图片，PicGo相册中可以看到上传的图片。</p></li></ol><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/fluetty/clouding/main/data/image-20201022161414837.png" alt="image-20201022161414837"></p><h2 id="Typora集成PicGo"><a href="#Typora集成PicGo" class="headerlink" title="Typora集成PicGo"></a>Typora集成PicGo</h2><p><a href="https://typora.io/">Typora</a> 是一款支持实时预览的Markdown 文本编辑器。非常好用，界面设计也挺有高级感。</p><ol><li>左上角 文件– 偏好设置 按照如图配置。配置后测试验证图片上传即可</li></ol><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/fluetty/clouding/main/data/image-20201022161854170.png" alt="image-20201022161854170"></p><ol start="2"><li>使用Typora编辑文件时，拖拽图片进来，截图后复制黏贴图片都可。使用快捷键 <strong>Ctrl + Shift + I</strong>，可以调出插入图片的功能。</li></ol>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
