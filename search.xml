<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Java后端工作中遇到问题总结</title>
      <link href="2022/06/27/Java%E5%90%8E%E7%AB%AF%E5%B7%A5%E4%BD%9C%E4%B8%AD%E9%81%87%E5%88%B0%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/"/>
      <url>2022/06/27/Java%E5%90%8E%E7%AB%AF%E5%B7%A5%E4%BD%9C%E4%B8%AD%E9%81%87%E5%88%B0%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h2 id="1-jackson接收List发生Can-not-deserialize-instance-of"><a href="#1-jackson接收List发生Can-not-deserialize-instance-of" class="headerlink" title="1. jackson接收List发生Can not deserialize instance of"></a>1. jackson接收List发生Can not deserialize instance of</h2><p>该错误是因为目标类属性keyX需要目标的类型，待转换的json串里属性名keyX对应的，不是一个POJO对象，而是ArrayList集合。</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">json    &#123; &quot;idList&quot;:[&quot;123&quot;,&quot;124&quot;] &#125;</span><br></pre></td></tr></table></figure><p>java应用map或者pojo来接收</p><p>如若直接用应用List<String>来接收就会报错Can not deserialize instance of java.util.ArrayList out of START_OBJECT token，即无法寻找到key。</p><h2 id="2-JSONObject-toJSONString首字母大小写问题"><a href="#2-JSONObject-toJSONString首字母大小写问题" class="headerlink" title="2. JSONObject.toJSONString首字母大小写问题"></a>2. JSONObject.toJSONString首字母大小写问题</h2><p>  在字段上加注解@JSONField（name=””）</p><h2 id="3-Java中-PO-VO-TO-BO-DAO-POJO）的区别"><a href="#3-Java中-PO-VO-TO-BO-DAO-POJO）的区别" class="headerlink" title="3.  Java中(PO,VO,TO,BO,DAO,POJO）的区别"></a>3.  Java中(PO,VO,TO,BO,DAO,POJO）的区别</h2><p>  PO：（Persistence Object）    <strong>持久层对象</strong>，对象的属性和数据库表的字段一一对应；<br>  VO：（View Object） <strong>表现层对象</strong>,对象的属性和页面展示的数据的名称一一对应；<br>  TO：（Transfer Object）<strong>数据传输对象</strong>，在应用程序不同tie(关系)之间传输的对象<br>  BO：（Business Object） <strong>业务层对象</strong>，对象的属性和当前业务逻辑所需的数据的名称一一对应；<br>  DAO：（Data Access Object）<strong>数据访问对象接口</strong>，DAO是Data Access Object数据访问接口，数据访问：顾名思义就是与数据库打交道。夹在业务逻辑与数据库资源中间<br>  POJO：（ Plain Ordinary <a href="http://lib.csdn.net/base/java">Java </a>Object）<strong>普通<a href="http://lib.csdn.net/base/java">Java</a>对象</strong>，只有属性及其set/get方法。</p><h2 id="4-String转List"><a href="#4-String转List" class="headerlink" title="4. String转List"></a>4. String转List</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;常见的为逗号分隔</span><br><span class="line">String str &#x3D; &quot;a,b,c&quot;;</span><br><span class="line">List&lt;String&gt; list1 &#x3D; Arrays.asList(str.split(&quot;,&quot;)); &#x2F;&#x2F;[a, b, c]</span><br><span class="line">List&lt;String&gt; list2 &#x3D; Arrays.asList(str.split(&quot;&quot;)); &#x2F;&#x2F;[a, ,, b, ,, c]</span><br></pre></td></tr></table></figure><p>List转String</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list &#x3D; new ArrayList&lt;String&gt;();</span><br><span class="line">list.add(&quot;a&quot;);</span><br><span class="line">list.add(&quot;b&quot;);</span><br><span class="line">list.add(&quot;c&quot;);</span><br><span class="line">String str1 &#x3D; StringUtils.join(list, &quot;,&quot;); &#x2F;&#x2F;a,b,c</span><br><span class="line">String str2 &#x3D; StringUtils.join(list, &quot;&quot;); &#x2F;&#x2F;abc</span><br></pre></td></tr></table></figure><h2 id="5-电脑常用快捷键"><a href="#5-电脑常用快捷键" class="headerlink" title="5. 电脑常用快捷键"></a>5. 电脑常用快捷键</h2><p>windows + E              打开我的电脑<br>windows + shift +S    截图<br>windows +D               一键返回桌面<br>Windows+数字          直接打开任务栏中的应用，数字对应任务栏应用中的顺序<br>Ctrl+Shift+Esc           调出任务管理器</p>]]></content>
      
      
      
        <tags>
            
            <tag> 问题总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>xxljob实战总结</title>
      <link href="2022/03/22/xxljob%E5%AE%9E%E6%88%98%E6%80%BB%E7%BB%93/"/>
      <url>2022/03/22/xxljob%E5%AE%9E%E6%88%98%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h2 id="理论相关"><a href="#理论相关" class="headerlink" title="理论相关"></a>理论相关</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>XXL-JOB是一个轻量级<a href="https://so.csdn.net/so/search?q=%E5%88%86%E5%B8%83%E5%BC%8F&spm=1001.2101.3001.7020">分布式</a>任务调度平台，其核心设计目标是开发迅速、学习简单、轻量级、易扩展。现已开放源代码并接入多家公司线上产品线，开箱即用。xxl三个字母是其开发者许雪里名字的缩写。</p><p>几个特性：</p><p> 1、简单：支持通过Web页面对任务进行CRUD操作，操作简单，一分钟上手；<br> 2、动态：支持动态修改任务状态、启动/停止任务，以及终止运行中任务，即时生效；<br> 3、调度中心HA（中心式）：调度采用中心式设计，“调度中心”自研调度组件并支持集群部署，可保证调度中心HA；<br> 4、执行器HA（分布式）：任务分布式执行，任务”执行器”支持集群部署，可保证任务执行HA；<br> 5、注册中心: 执行器会周期性自动注册任务, 调度中心将会自动发现注册的任务并触发执行，每30秒清理一次<a href="https://so.csdn.net/so/search?q=%E6%B3%A8%E5%86%8C%E8%A1%A8&spm=1001.2101.3001.7020">注册表</a>中的无效机器。同时，也支持手动录入执行器地址；<br> 6、弹性扩容缩容：一旦有新执行器机器上线或者下线，下次调度时将会重新分配任务；<br> 7、路由策略：执行器集群部署时提供丰富的路由策略，包括：第一个、最后一个、轮询、随机、一致性HASH、最不经常使用、最近最久未使用、故障转移、忙碌转移等；<br> 8、故障转移：任务路由策略选择”故障转移”情况下，如果执行器集群中某一台机器故障，将会自动Failover切换到一台正常的执行器发送调度请求。<br> 9、阻塞处理策略：调度过于密集执行器来不及处理时的处理策略，策略包括：单机串行（默认）、丢弃后续调度、覆盖之前调度；<br> 10、任务超时控制：支持自定义任务超时时间，任务运行超时将会主动中断任务；<br> 11、任务失败重试：支持自定义任务失败重试次数，当任务失败时将会按照预设的失败重试次数主动进行重试；其中分片任务支持分片粒度的失败重试；<br> 12、任务失败告警；默认提供邮件方式失败告警，同时预留扩展接口，可方便的扩展短信、钉钉等告警方式；<br> 13、分片广播任务：执行器集群部署时，任务路由策略选择”分片广播”情况下，一次任务调度将会广播触发集群中所有执行器执行一次任务，可根据分片参数开发分片任务；<br> 14、动态分片：分片广播任务以执行器为维度进行分片，支持动态扩容执行器集群从而动态增加分片数量，协同进行业务处理；在进行大数据量业务操作时可显著提升任务处理能力和速度。<br> 15、事件触发：除了”Cron方式”和”任务依赖方式”触发任务执行之外，支持基于事件的触发任务方式。调度中心提供触发任务单次执行的API服务，可根据业务事件灵活触发</p><h3 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h3><h3 id="一次的完整执行流程"><a href="#一次的完整执行流程" class="headerlink" title="一次的完整执行流程"></a>一次的完整执行流程</h3><p><a href="https://imgtu.com/i/qte5Nj"><img src= "/img/loading.gif" data-lazy-src="https://s1.ax1x.com/2022/03/25/qte5Nj.png" alt="qte5Nj.png"></a></p><p>1、“调度中心”向“执行器”发送http调度请求: “执行器”中接收请求的服务，实际上是一台内嵌jetty服务器，默认端口9999;<br>2、“执行器”执行任务逻辑；<br>3、“执行器”http回调“调度中心”调度结果: “调度中心”中接收回调的服务，是针对执行器开放一套API服务;</p><p><strong>调度中心</strong>：负责管理调度信息，按照调度配置发出调度请求，自身不承担业务代码。调度系统与任务解耦，提高了系统可用性和稳定性，同时调度系统性能不再受限于任务模块；<br>支持可视化、简单且动态的管理调度信息，包括任务新建，更新，删除，GLUE开发和任务报警等，所有上述操作都会实时生效，同时支持监控调度结果以及执行日志，支持执行器Failover。<br>调度模块早期依赖于quartz,为了精简系统降低冗余依赖，和提供系统的可控度与稳定性；现在使用选择自研调度组件，类似于一个时间轮。<br>XXL-JOB中“调度模块”和“任务模块”完全解耦，调度模块进行任务调度时，将会解析不同的任务参数发起远程调用，调用各自的远程执行器服务。这种调用模型类似RPC调用，调度中心提供调用代理的功能，而执行器提供远程服务的功能。<br><strong>执行模块</strong>：负责接收调度请求并执行任务逻辑。任务模块专注于任务的执行等操作，开发和维护更加简单和高效；接收“调度中心”的执行请求、终止请求和日志请求等；<br>执行器实际上是一个内嵌的Server，默认端口9999（配置项：xxl.job.executor.port）。<br>在项目启动时，执行器会通过“@XxlJob”识别Spring容器中“Bean模式任务”，以注解的value属性为key管理起来。<br>“执行器”接收到“调度中心”的调度请求时，如果任务类型为“Bean模式”，将会匹配Spring容器中的“Bean模式任务”，然后调用其execute方法，执行任务逻辑<br>**”bean”模式原理**：每个Bean模式任务都是一个Spring的Bean类实例，它被维护在“执行器”项目的Spring容器中。任务方法需要加“@XxlJob(value=”名称”)”注解，因为“执行器”会根据该注解识别Spring容器中的任务。</p><p><a href="https://imgtu.com/i/qtmPv6"><img src= "/img/loading.gif" data-lazy-src="https://s1.ax1x.com/2022/03/25/qtmPv6.png" alt="qtmPv6.png"></a></p><h3 id="触发"><a href="#触发" class="headerlink" title="触发"></a>触发</h3><ol><li><p>早期：基于quartz.现在：timewheel时间轮，这个时间轮本质就是一个Map&lt;Integer, List&gt;</p></li><li><p>触发算法：<br>拿到了距now 5秒内的任务列表数据：scheduleList，分三种情况处理：for循环遍历scheduleList集合</p></li></ol><p>（1）对到达now时间后的任务：（任务下一次触发时间+5s&lt;now)：直接跳过不执行； 重置trigger_next_time；</p><p>（2）对到达now时间后的任务：(任务下一次触发时间&lt;now&lt;任务下一次触发时间+5s)：线程执行触发逻辑； 若任务下一次触发时间是在5秒内， 则放到时间轮内（Map&lt;Integer, List&gt; 秒数(1-60) =&gt; 任务id列表）；再 重置trigger_next_time</p><p>（3）对未到达now时间的任务（任务下一次触发时间&gt;now）：直接放到时间轮内；重置trigger_next_time 。</p><ol start="3"><li>时间轮数据结构： Map&lt;Integer, List&gt; key是秒数(1-60) value是任务id列表，具体结构如下图 ：</li></ol><p><a href="https://imgtu.com/i/qtmZUH"><img src= "/img/loading.gif" data-lazy-src="https://s1.ax1x.com/2022/03/25/qtmZUH.png" alt="qtmZUH.png"></a></p><h3 id="一致性保证"><a href="#一致性保证" class="headerlink" title="一致性保证"></a>一致性保证</h3><p>为了避免多个服务器同时调度任务， 通过mysql悲观锁实现分布式锁（for update语句）</p><p>1 setAutoCommit(false)关闭隐式自动提交事务</p><p>2 启动事务select lock for update（排他锁）</p><p>3 读db任务信息 -&gt; 拉任务到内存时间轮 -&gt; 更新db任务信息</p><p>4 commit提交事务，同时会释放for update的排他锁（悲观锁）</p><p>任务处理完毕后，释放悲观锁，准备等待下一次循环。</p><p><a href="https://imgtu.com/i/qtmWxx"><img src= "/img/loading.gif" data-lazy-src="https://s1.ax1x.com/2022/03/25/qtmWxx.png" alt="qtmWxx.png"></a></p><h2 id="Springboot整合xxljob"><a href="#Springboot整合xxljob" class="headerlink" title="Springboot整合xxljob"></a>Springboot整合xxljob</h2><ol><li><p>源码获取</p><p>首先从GitHub上面将项目clone下来，如果网络问题导致速度慢也可以从Gitee上面拉取</p><p>GitHub地址：<a href="https://github.com/xuxueli/xxl-job">https://github.com/xuxueli/xxl-job</a></p><p>Gitee地址：<a href="https://gitee.com/xuxueli0323/xxl-job">https://gitee.com/xuxueli0323/xxl-job</a></p><p>下载好之后将压缩包解压，然后通过IDEA打开，将Maven编译好后项目结构如下   xxl-job-admin  是调度中心     xxl-job-core是公共依赖   xxl-job-executor-samples 各个版本的执行器，推荐使用springboot版本<br><a href="https://imgtu.com/i/qtnpdg"><img src= "/img/loading.gif" data-lazy-src="https://s1.ax1x.com/2022/03/25/qtnpdg.png" alt="qtnpdg.png" style="zoom:50%;" /></a>  </p></li><li><p>运行doc文件下的tables_xxl_job.sql 文件 新建了八张表</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">xxl_job_lock：任务调度锁表；</span><br><span class="line">xxl_job_group：执行器信息表，维护任务执行器信息；</span><br><span class="line">xxl_job_info：调度扩展信息表： 用于保存XXL-JOB调度任务的扩展信息，如任务分组、任务名、机器地址、执行器、执行入参和报警邮件等等；</span><br><span class="line">xxl_job_log：调度日志表： 用于保存XXL-JOB任务调度的历史信息，如调度结果、执行结果、调度入参、调度机器和执行器等等；</span><br><span class="line">xxl_job_log_report：调度日志报表：用户存储XXL-JOB任务调度日志的报表，调度中心报表功能页面会用到；</span><br><span class="line">xxl_job_logglue：任务GLUE日志：用于保存GLUE更新历史，用于支持GLUE的版本回溯功能；</span><br><span class="line">xxl_job_registry：执行器注册表，维护在线的执行器和调度中心机器地址信息；</span><br><span class="line">xxl_job_user：系统用户表；</span><br></pre></td></tr></table></figure></li><li><p>配置调度中心xxl-job-admin<br>  需要将其配置成自己需要的调度中心，通过该工程能够以图形化的方式统一管理任务调度平台上调度任务，负责触发调度执行。</p><pre><code>修改调度中心配置文件：/xxl-job/xxl-job-admin/src/main/resources/application.properties</code></pre></li></ol><p><a href="https://imgtu.com/i/qtnnwF"><img src= "/img/loading.gif" data-lazy-src="https://s1.ax1x.com/2022/03/25/qtnnwF.md.png" alt="qtnnwF.md.png"></a></p><p>注意在数据库地址哪里加上时区属性，否则乱码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">spring.datasource.url=jdbc:mysql:<span class="comment">//127.0.0.1:3306/xxl_job?Unicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=UTC</span></span><br></pre></td></tr></table></figure><ol start="4"><li><p>启动XxlJobAdminApplication类，访问<a href="http://localhost:8080/xxl-job-admin">http://localhost:8080/xxl-job-admin</a> 默认账户admn，密码123456  登录后进入主页面</p><p><a href="https://imgtu.com/i/qtnGy6"><img src= "/img/loading.gif" data-lazy-src="https://s1.ax1x.com/2022/03/25/qtnGy6.md.png" alt="qtnGy6.md.png"></a></p></li></ol><p>​    <a href="https://imgtu.com/i/qtns6P"><img src= "/img/loading.gif" data-lazy-src="https://s1.ax1x.com/2022/03/25/qtns6P.md.png" alt="qtns6P.md.png"></a></p><h3 id="执行器管理"><a href="#执行器管理" class="headerlink" title="执行器管理"></a>执行器管理</h3><p><strong>参数介绍：</strong></p><p>　　<strong>AppName</strong>：是每个执行器集群的唯一标示AppName, 执行器会周期性以AppName为对象进行自动注册。可通过该配置自动发现注册成功的执行器, 供任务调度时使用;</p><p>　　<strong>名称</strong>：执行器的名称, 因为AppName限制字母数字等组成,可读性不强, 名称为了提高执行器的可读性;</p><p>　　<strong>排序</strong>: 执行器的排序, 系统中需要执行器的地方,如任务新增, 将会按照该排序读取可用的执行器列表;</p><p>　　<strong>注册方式</strong>：调度中心获取执行器地址的方式，</p><p>　　　　<strong>自动注册</strong>：执行器自动进行执行器注册，调度中心通过底层注册表可以动态发现执行器机器地址；</p><p>　　　　<strong>手动录入</strong>：人工手动录入执行器的地址信息，多地址逗号分隔，供调度中心使用；</p><p>　　<strong>机器地址</strong>：”注册方式”为”手动录入”时有效，支持人工维护执行器的地址信息；</p><ol start="5"><li>在源码 xxl-job-executor-samples  下springboot模块下jobhandler层下面新建一个自己的定时任务测试。 只是控制台输出，xxl-job有自己的日志打印。</li></ol><p><a href="https://imgtu.com/i/qtnTXV"><img src= "/img/loading.gif" data-lazy-src="https://s1.ax1x.com/2022/03/25/qtnTXV.md.png" alt="qtnTXV.md.png"></a></p><ol start="6"><li><p>在任务管理里面新增任务，点击启动即可测试。执行器配置一般选择自动注册，会扫描出ip和port。</p><h3 id="任务管理参数"><a href="#任务管理参数" class="headerlink" title="任务管理参数"></a>任务管理参数</h3><p><strong>参数介绍：</strong></p><p>　　<strong>执行器</strong>：任务的绑定的执行器，任务触发调度时将会自动发现注册成功的执行器, 实现任务自动发现功能; 另一方面也可以方便的进行任务分组。每个任务必须绑定一个执行器, 可在 “执行器管理” 进行设置。</p><p>　　<strong>任务描述</strong>：任务的描述信息，便于任务管理；</p><p>　　<strong>路由策略</strong>：当执行器集群部署时，提供丰富的路由策略，包括；<br>　　　　　　FIRST（第一个）：固定选择第一个机器；<br>　　　　　　LAST（最后一个）：固定选择最后一个机器；<br>　　　　　　ROUND（轮询）：；<br>　　　　　　RANDOM（随机）：随机选择在线的机器；<br>　　　　　　CONSISTENT_HASH（一致性HASH）：每个任务按照Hash算法固定选择某一台机器，且所有任务均匀散列在不同机器上。<br>　　　　　　LEAST_FREQUENTLY_USED（最不经常使用）：使用频率最低的机器优先被选举；<br>　　　　　　LEAST_RECENTLY_USED（最近最久未使用）：最久为使用的机器优先被选举；<br>　　　　　　FAILOVER（故障转移）：按照顺序依次进行心跳检测，第一个心跳检测成功的机器选定为目标执行器并发起调度；<br>　　　　　　BUSYOVER（忙碌转移）：按照顺序依次进行空闲检测，第一个空闲检测成功的机器选定为目标执行器并发起调度；<br>　　　　　　SHARDING_BROADCAST(分片广播)：广播触发对应集群中所有机器执行一次任务，同时系统自动传递分片参数；可根据分片参数开发分片任务；<br>　　<strong>Cron</strong>：触发任务执行的Cron表达式；<br>　　<strong>运行模式</strong>：<br>　　　　　　BEAN模式：任务以JobHandler方式维护在执行器端；需要结合 “JobHandler” 属性匹配执行器中任务；<br>　　　　　　GLUE模式(Java)：任务以源码方式维护在调度中心；该模式的任务实际上是一段继承自IJobHandler的Java类代码并 “groovy” 源码方式维护，它在执行器项目中运行，可使用　　　　　　  @Resource/@Autowire注入执行器里中的其他服务；<br>　　　　　　GLUE模式(Shell)：任务以源码方式维护在调度中心；该模式的任务实际上是一段 “shell” 脚本；<br>　　　　　　GLUE模式(Python)：任务以源码方式维护在调度中心；该模式的任务实际上是一段 “python” 脚本；<br>　　　　　　GLUE模式(PHP)：任务以源码方式维护在调度中心；该模式的任务实际上是一段 “php” 脚本；<br>　　　　　　GLUE模式(NodeJS)：任务以源码方式维护在调度中心；该模式的任务实际上是一段 “nodejs” 脚本；<br>　　　　　　GLUE模式(PowerShell)：任务以源码方式维护在调度中心；该模式的任务实际上是一段 “PowerShell” 脚本；<br>　　<strong>JobHandler</strong>：运行模式为 “BEAN模式” 时生效，对应执行器中新开发的JobHandler类“@JobHandler”注解自定义的value值；<br>　　<strong>阻塞处理策略</strong>：调度过于密集执行器来不及处理时的处理策略；<br>　　　　　　单机串行（默认）：调度请求进入单机执行器后，调度请求进入FIFO队列并以串行方式运行；<br>　　　　　　丢弃后续调度：调度请求进入单机执行器后，发现执行器存在运行的调度任务，本次请求将会被丢弃并标记为失败；<br>　　　　　　覆盖之前调度：调度请求进入单机执行器后，发现执行器存在运行的调度任务，将会终止运行中的调度任务并清空队列，然后运行本地调度任务；<br>　　<strong>子任务</strong>：每个任务都拥有一个唯一的任务ID(任务ID可以从任务列表获取)，当本任务执行结束并且执行成功时，将会触发子任务ID所对应的任务的一次主动调度。<br>　　<strong>任务超时时间</strong>：支持自定义任务超时时间，任务运行超时将会主动中断任务；<br>　　<strong>失败重试次数</strong>；支持自定义任务失败重试次数，当任务失败时将会按照预设的失败重试次数主动进行重试；<br>　　<strong>报警邮件</strong>：任务调度失败时邮件通知的邮箱地址，支持配置多邮箱地址，配置多个邮箱地址时用逗号分隔；<br>　　<strong>负责人</strong>：任务的负责人；<br>　　<strong>执行参数</strong>：任务执行所需的参数，多个参数时用逗号分隔，任务执行时将会把多个参数转换成数组传入；</p><ol start="8"><li>点击执行 启动 即可查看日志和控制台</li></ol><h3 id="项目中集成xxljob"><a href="#项目中集成xxljob" class="headerlink" title="项目中集成xxljob"></a>项目中集成xxljob</h3><ol><li>在项目中引入依赖</li></ol><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;com.xuxueli&lt;&#x2F;groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;xxl-job-core&lt;&#x2F;artifactId&gt;</span><br><span class="line">  &lt;version&gt;2.0.1&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>2.将xxl-job-executor-sample-springboot这个模块下的XxlJobConfig复制一份到项目中，然后将相关配置设置好即可</p></li></ol><p><a href="https://imgtu.com/i/qtui7D"><img src= "/img/loading.gif" data-lazy-src="https://s1.ax1x.com/2022/03/25/qtui7D.md.png" alt="qtui7D.md.png"></a></p>]]></content>
      
      
      
        <tags>
            
            <tag> xxljob </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>试卷扣分识别统计Demo记录</title>
      <link href="2021/05/20/%E8%AF%95%E5%8D%B7%E6%89%A3%E5%88%86%E8%AF%86%E5%88%AB%E7%BB%9F%E8%AE%A1Demo%E8%AE%B0%E5%BD%95/"/>
      <url>2021/05/20/%E8%AF%95%E5%8D%B7%E6%89%A3%E5%88%86%E8%AF%86%E5%88%AB%E7%BB%9F%E8%AE%A1Demo%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h2 id="需求描述"><a href="#需求描述" class="headerlink" title="需求描述"></a>需求描述</h2><p>多张判过分的试卷，通过demo来识别出每道题目扣分多少，将结果汇总到excel文件中。</p><h3 id="个人想法"><a href="#个人想法" class="headerlink" title="个人想法"></a>个人想法</h3><p>将图片按照题目划分矩形区域，识别出哪道题扣分，将结果统计出来。</p><h2 id="步骤概述"><a href="#步骤概述" class="headerlink" title="步骤概述"></a>步骤概述</h2><h3 id="图片处理"><a href="#图片处理" class="headerlink" title="图片处理"></a>图片处理</h3><h4 id="图片按照边框裁剪校正"><a href="#图片按照边框裁剪校正" class="headerlink" title="图片按照边框裁剪校正"></a>图片按照边框裁剪校正</h4><p>保证初始输入的图片处理之后有基本相同的像素大小，按照试卷的边框进行裁剪，然后图片进行校正。</p><h5 id="可参考链接"><a href="#可参考链接" class="headerlink" title="可参考链接"></a>可参考链接</h5><p><a href="https://blog.csdn.net/demm868/article/details/104289835">基于python+opencv的图像目标区域自动提取</a></p><h4 id="图片增强"><a href="#图片增强" class="headerlink" title="图片增强"></a>图片增强</h4><p>对校正好的图片进行处理，对比度增强、亮度增强、色度增强、锐度增强等。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> ImageEnhance</span><br><span class="line"></span><br><span class="line"><span class="comment"># 原始图像</span></span><br><span class="line">image = Image.<span class="built_in">open</span>(<span class="string">&#x27;fix.jpg&#x27;</span>)</span><br><span class="line">image.show()</span><br><span class="line"><span class="comment"># 对比度增强</span></span><br><span class="line">enh_con = ImageEnhance.Contrast(image)</span><br><span class="line">contrast = <span class="number">1.2</span></span><br><span class="line">image_contrasted = enh_con.enhance(contrast)</span><br><span class="line">image_contrasted.show()</span><br><span class="line"><span class="comment"># 亮度增强</span></span><br><span class="line">enh_bri = ImageEnhance.Brightness(image)</span><br><span class="line">brightness = <span class="number">1.3</span></span><br><span class="line">image_brightened = enh_bri.enhance(brightness)</span><br><span class="line">image_brightened.show()</span><br><span class="line"><span class="comment"># 色度增强</span></span><br><span class="line">enh_col = ImageEnhance.Color(image)</span><br><span class="line">color = <span class="number">1.5</span></span><br><span class="line">image_colored = enh_col.enhance(color)</span><br><span class="line">image_colored.show()</span><br><span class="line"><span class="comment"># 锐度增强</span></span><br><span class="line">enh_sha = ImageEnhance.Sharpness(image)</span><br><span class="line">sharpness = <span class="number">3.0</span></span><br><span class="line">image_sharped = enh_sha.enhance(sharpness)</span><br><span class="line">image_sharped.show()</span><br></pre></td></tr></table></figure><h5 id="todo"><a href="#todo" class="headerlink" title="todo"></a>todo</h5><p>图片增强的效果不是太好，考虑参考其它图片处理方法。  高斯模糊（todo）</p><h3 id="图片分割"><a href="#图片分割" class="headerlink" title="图片分割"></a>图片分割</h3><p>分割是比较简单，此图的难点在于如何确定哥哥题目区域，即各个题目的坐标。</p><p>此处我先均分，然后手动计算坐标给一张图片划分了矩形。（此处的基准模板图片可以考虑借助用户的帮助来生成，包括划分后区域题号的对应）</p><h3 id="图片识别"><a href="#图片识别" class="headerlink" title="图片识别"></a>图片识别</h3><p>识别切割出的题目区域中有没有扣分</p><p>选择题可以考虑只要是识别出了红色即算此题错误（todo）</p><p>客观题需要识别出所扣分数，初步打算是将扣分区域再分割出来，然后用手写体识别模型来识别扣分（准确率会高一些）。</p><p>目的是为了将扣分显示出来，所以题目信息不重要，图像处理，使得题目信息变模糊，红色加深。</p><p>提取目标图像参考下  <strong>投影法字符分割</strong>，或者是识别特定颜色并提取图像相关文章。</p><h4 id="提取目标图像（扣分区域）"><a href="#提取目标图像（扣分区域）" class="headerlink" title="提取目标图像（扣分区域）"></a>提取目标图像（扣分区域）</h4><p><a href="https://blog.csdn.net/qq_43534932/article/details/88386826?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-2.control&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-2.control">python 用opencv完成图像分割，并且完成每一个目标物的提取</a></p><p><a href="https://blog.csdn.net/liqiancao/article/details/55670749">使用Python和OpenCV检测图像中的物体并将物体裁剪下来</a></p><p><a href="https://blog.csdn.net/javastart/article/details/107719335?utm_medium=distribute.pc_relevant.none-task-blog-title-6&spm=1001.2101.3001.4242">基于tensorflow、opencv的入门案例_发票识别三：发票数据集制作和cnn网络训练</a></p><p>百度OCR开源API</p><p>腾讯OCR   ？？</p><h3 id="结果统计"><a href="#结果统计" class="headerlink" title="结果统计"></a>结果统计</h3><p>题号和切割出的图片的对应关系，导出到excel不是难点。</p><h2 id="重难点"><a href="#重难点" class="headerlink" title="重难点"></a>重难点</h2><ol><li>图像的处理和高质量图片（测试图片）的获取</li><li>题目区域的划分（若扣分跨两个题目区域？？）</li><li>题目和切割后图片对应关系</li><li>分割后的图片中是否包含扣分识别（选择题）</li><li>图片中扣分切割出并识别</li><li>识别的准确率问题</li></ol><h2 id="关键词参考"><a href="#关键词参考" class="headerlink" title="关键词参考"></a>关键词参考</h2><p><strong>透视变换     图像二值化    图片膨胀腐蚀  高斯模糊   HSV    openCV    图像切割投影法字符分割 特定区域ROI提取</strong> </p><h2 id="可能用到的参考链接"><a href="#可能用到的参考链接" class="headerlink" title="可能用到的参考链接"></a>可能用到的参考链接</h2><p><a href="https://blog.csdn.net/See_Star/article/details/103044722">Python+OpenCV识别颜色方块并提取轮廓</a></p><p><a href="https://blog.csdn.net/qq_41616397/article/details/87980510">Python识别图片指定区域文字内容</a></p><p><a href="https://blog.csdn.net/WZZ18191171661/article/details/89738212">Python+Opencv实现自动化阅卷</a></p><p><a href="https://blog.csdn.net/demm868/article/details/104058078">票据图片复杂表格框识别(票据单元格切割)</a></p><p><a href="https://blog.csdn.net/Xin_101/article/details/85602500">OpenCV图像分割python版</a></p><h2 id="可能会用到的demo"><a href="#可能会用到的demo" class="headerlink" title="可能会用到的demo"></a>可能会用到的demo</h2><ol><li><p>识别图片中的红色</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">src = cv2.imread(<span class="string">&quot;fix.jpg&quot;</span>)</span><br><span class="line">cv2.namedWindow(<span class="string">&quot;input&quot;</span>, cv2.WINDOW_AUTOSIZE)</span><br><span class="line">cv2.imshow(<span class="string">&quot;input&quot;</span>, src)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">提取图中的红色部分</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">hsv = cv2.cvtColor(src, cv2.COLOR_BGR2HSV)</span><br><span class="line">low_hsv = np.array([<span class="number">0</span>, <span class="number">36</span>, <span class="number">10</span>])</span><br><span class="line">high_hsv = np.array([<span class="number">10</span>, <span class="number">255</span>, <span class="number">255</span>])</span><br><span class="line">mask = cv2.inRange(hsv, lowerb=low_hsv, upperb=high_hsv)</span><br><span class="line">cv2.imshow(<span class="string">&quot;pic&quot;</span>, mask)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure></li><li><p>手动给试卷题目划分区域</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># encoding:utf-8</span></span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"></span><br><span class="line">image = cv2.imread(<span class="string">&quot;origin.jpg&quot;</span>)</span><br><span class="line">GrayImage = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)</span><br><span class="line">print(GrayImage.shape)</span><br><span class="line">h, w = image.shape[:<span class="number">2</span>]</span><br><span class="line">h, w = <span class="built_in">map</span>(<span class="built_in">int</span>, [h, w])</span><br><span class="line">print(<span class="string">&quot;高-宽&quot;</span>, h, w)</span><br><span class="line"><span class="comment"># # no flip</span></span><br><span class="line">draw_0 = cv2.rectangle(image, (<span class="number">10</span>, <span class="number">10</span>), (<span class="number">500</span>, <span class="number">770</span>), (<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>))</span><br><span class="line">cv2.rectangle(image, (<span class="number">510</span>, <span class="number">10</span>), (<span class="number">1000</span>, <span class="number">770</span>), (<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>))</span><br><span class="line"></span><br><span class="line">a = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> a &lt; h:</span><br><span class="line">    a += <span class="number">50</span></span><br><span class="line"><span class="comment">#  cv2.rectangle(image, (10, int(a)), (500, 770), (255, 0, 0), 1)</span></span><br><span class="line"><span class="comment">#   cv2.rectangle(image, (510, int(a)), (1000, 770), (255, 0, 0), 1)</span></span><br><span class="line"></span><br><span class="line">cv2.rectangle(image, (<span class="number">10</span>, <span class="number">270</span>), (<span class="number">500</span>, <span class="number">770</span>), (<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>))</span><br><span class="line">cv2.rectangle(image, (<span class="number">10</span>, <span class="number">313</span>), (<span class="number">500</span>, <span class="number">770</span>), (<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>))</span><br><span class="line">cv2.rectangle(image, (<span class="number">10</span>, <span class="number">365</span>), (<span class="number">500</span>, <span class="number">770</span>), (<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>))</span><br><span class="line">cv2.rectangle(image, (<span class="number">10</span>, <span class="number">415</span>), (<span class="number">500</span>, <span class="number">770</span>), (<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>))</span><br><span class="line">cv2.rectangle(image, (<span class="number">10</span>, <span class="number">470</span>), (<span class="number">500</span>, <span class="number">770</span>), (<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>))</span><br><span class="line">cv2.rectangle(image, (<span class="number">10</span>, <span class="number">505</span>), (<span class="number">500</span>, <span class="number">770</span>), (<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>))</span><br><span class="line">cv2.rectangle(image, (<span class="number">10</span>, <span class="number">615</span>), (<span class="number">500</span>, <span class="number">770</span>), (<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>))</span><br><span class="line">cv2.rectangle(image, (<span class="number">10</span>, <span class="number">670</span>), (<span class="number">500</span>, <span class="number">770</span>), (<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>))</span><br><span class="line">cv2.rectangle(image, (<span class="number">10</span>, <span class="number">725</span>), (<span class="number">500</span>, <span class="number">770</span>), (<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>))</span><br><span class="line"></span><br><span class="line">cv2.rectangle(image, (<span class="number">510</span>, <span class="number">10</span>), (<span class="number">1000</span>, <span class="number">70</span>), (<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>))</span><br><span class="line">cv2.rectangle(image, (<span class="number">510</span>, <span class="number">10</span>), (<span class="number">1000</span>, <span class="number">370</span>), (<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>))</span><br><span class="line"></span><br><span class="line">x, y, w, h = cv2.boundingRect(GrayImage)</span><br><span class="line">print(x, y, w, h)</span><br><span class="line">draw_1 = cv2.rectangle(image, (x, y), (x + w, y + h), (<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>), <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 参数：pt1,对角坐标１, pt2:对角坐标２</span></span><br><span class="line"><span class="comment"># 注意这里根据两个点pt1,pt2,确定了对角线的位置，进而确定了矩形的位置</span></span><br><span class="line"><span class="comment"># draw_0 = cv2.rectangle(image, (2 * w, 2 * h), (3 * w, 3 * h),(255, 255, 0), 2)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将画过矩形框的图片保存到当前文件夹</span></span><br><span class="line">cv2.imwrite(<span class="string">&quot;changed.jpg&quot;</span>, draw_0)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示画过矩形框的图片</span></span><br><span class="line">cv2.imshow(<span class="string">&quot;draw&quot;</span>, draw_1)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br><span class="line">cv2.destroyWindow(<span class="string">&quot;draw&quot;</span>)</span><br></pre></td></tr></table></figure></li></ol><ol start="3"><li><p>已知区域坐标，切割图片</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">特定区域图片裁切</span></span><br><span class="line"><span class="string">方法1：利用OpenCV对其进行裁剪</span></span><br><span class="line"><span class="string">方法2：使用Pillow对图片进行裁剪</span></span><br><span class="line"><span class="string">https://blog.csdn.net/hfutdog/article/details/82351549</span></span><br><span class="line"><span class="string">动态获取裁切点坐标</span></span><br><span class="line"><span class="string">(10, 270), (500, 770)</span></span><br><span class="line"><span class="string">(10, 313), (500, 770)</span></span><br><span class="line"><span class="string">(10, 365), (500, 770)</span></span><br><span class="line"><span class="string">(10, 415), (500, 770)</span></span><br><span class="line"><span class="string">(10, 470), (500, 770)</span></span><br><span class="line"><span class="string">(10, 505), (500, 770)</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">x0 = <span class="number">10</span></span><br><span class="line">x1 = <span class="number">500</span></span><br><span class="line">n = <span class="number">770</span></span><br><span class="line"><span class="comment"># 裁切点坐标 动态的坐标  图片以题号等命名</span></span><br><span class="line">y = [<span class="number">270</span>, <span class="number">313</span>, <span class="number">365</span>, <span class="number">415</span>, <span class="number">470</span>, <span class="number">505</span>]</span><br><span class="line">img = cv2.imread(<span class="string">&quot;origin.jpg&quot;</span>)</span><br><span class="line">print(img.shape)</span><br><span class="line"><span class="comment"># 裁剪坐标为[y0:y1, x0:x1]</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(y)<span class="number">-1</span>):</span><br><span class="line">    cropped = img[y[i]:y[i + <span class="number">1</span>], x0:x1]</span><br><span class="line">    cv2.imwrite(<span class="string">&quot;pic/&quot;</span> + <span class="built_in">str</span>(i) + <span class="string">&quot;.jpg&quot;</span>, cropped)</span><br></pre></td></tr></table></figure><h2 id="原始图片（测试用）"><a href="#原始图片（测试用）" class="headerlink" title="原始图片（测试用）"></a>原始图片（测试用）</h2><p>origin.jpg </p><p><a href="https://imgchr.com/i/DQc7z4"><img src= "/img/loading.gif" data-lazy-src="https://s3.ax1x.com/2020/11/20/DQc7z4.jpg" alt="DQc7z4.jpg"></a></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 图像识别 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ocr </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1025 反转链表 (25分) PAT</title>
      <link href="2021/05/18/1025%20%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8%20(25%E5%88%86)%20PAT/"/>
      <url>2021/05/18/1025%20%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8%20(25%E5%88%86)%20PAT/</url>
      
        <content type="html"><![CDATA[<h2 id="1025-反转链表-25分"><a href="#1025-反转链表-25分" class="headerlink" title="1025 反转链表 (25分)"></a>1025 反转链表 (25分)</h2><p>给定一个常数 K 以及一个单链表 L，请编写程序将 L 中每 K 个结点反转。例如：给定 L 为 1→2→3→4→5→6，K 为 3，则输出应该为 3→2→1→6→5→4；如果 K 为 4，则输出应该为 4→3→2→1→5→6，即最后不到 K 个元素不反转。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>每个输入包含 1 个测试用例。每个测试用例第 1 行给出第 1 个结点的地址、结点总个数正整数 N (≤$10^{​5}$​​ )、以及正整数 K (≤N)，即要求反转的子链结点的个数。结点的地址是 5 位非负整数，NULL 地址用 −1 表示。</p><p>接下来有 N 行，每行格式为：</p><blockquote><p>Address Data Next<br>其中 Address 是结点地址，Data 是该结点保存的整数数据，Next 是下一结点的地址。</p></blockquote><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>对每个测试用例，顺序输出反转后的链表，其上每个结点占一行，格式与输入相同。</p><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><blockquote><p>00100 6 4<br>00000 4 99999<br>00100 1 12309<br>68237 6 -1<br>33218 3 00000<br>99999 5 68237<br>12309 2 33218</p></blockquote><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><blockquote><p>00000 4 33218<br>33218 3 12309<br>12309 2 00100<br>00100 1 99999<br>99999 5 68237<br>68237 6 -1</p></blockquote><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h3><p> 此题题意刚开始没有读懂，无从下手。后来看了看别人的解法，仔细梳理了一下题目描述，终于明白什么意思了。<br> <strong>题目给定了N个节点，节点刚开始是乱序的，所以要先对节点进行排序。K 是指K个节点为一组，进行逆序，最后一组若不足K个不用逆序。例：有11个几点，K为4，则将这排好序的11个节点分为11/4+1=3组，最后一组不足4个，所以0-3，4-7这两组分别进行逆序操作，最后三组再合并起来成为一个链表输出。</strong><br> 代码在牛客上是AC了，在PAT上有一个测试点显示运行超时。解出此题已经挺高兴了，等再做些链表相关的题目再来优化此代码。</p><h3 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h3><p><strong>具体逻辑看代码注释</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//读取输入</span></span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="comment">//首地址</span></span><br><span class="line">        <span class="keyword">int</span> firstAddress = sc.nextInt();</span><br><span class="line">        <span class="comment">//读入节点个数</span></span><br><span class="line">        <span class="keyword">int</span> number = sc.nextInt();</span><br><span class="line">        <span class="comment">//反转正整数K</span></span><br><span class="line">        <span class="keyword">int</span> k = sc.nextInt();</span><br><span class="line">        <span class="comment">//暂存读入的无序节点</span></span><br><span class="line">        Node[] array = <span class="keyword">new</span> Node[<span class="number">100000</span>];</span><br><span class="line">        <span class="comment">//读入节点</span></span><br><span class="line">        <span class="keyword">while</span>(number != <span class="number">0</span>)&#123;</span><br><span class="line">            Node node = <span class="keyword">new</span> Node(sc.nextInt(),sc.nextInt(),sc.nextInt());</span><br><span class="line">            array[node.address] = node;</span><br><span class="line">            number--;</span><br><span class="line">        &#125;</span><br><span class="line">        sc.close();</span><br><span class="line">        <span class="comment">//将读入的节点按顺序放进list集合中</span></span><br><span class="line">        List&lt;Node&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">//操作完成后的list中是按照节点顺序排放好的节点</span></span><br><span class="line">        <span class="keyword">while</span>(firstAddress != -<span class="number">1</span>)&#123;</span><br><span class="line">            list.add(array[firstAddress]);</span><br><span class="line">            firstAddress = array[firstAddress].next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//按照给定的K为一组进行反转-即交换节点在list中的顺序</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">0</span>; x + k &lt;= list.size(); x += k)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> y = x + k - <span class="number">1</span>, m = x; y &gt;= m; y--, m++)&#123;</span><br><span class="line">                Node temp = list.get(m);</span><br><span class="line">                list.set(m,list.get(y));</span><br><span class="line">                list.set(y,temp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//按照要求输出结果</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; list.size() - <span class="number">1</span>; x++)&#123;</span><br><span class="line">            System.out.printf(<span class="string">&quot;%05d %d %05d\n&quot;</span>,list.get(x).address,list.get(x).data,list.get(x+<span class="number">1</span>).address);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> end = list.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//最后一个节点的next 为-1</span></span><br><span class="line">        System.out.printf(<span class="string">&quot;%05d %d -1&quot;</span>,list.get(end).address,list.get(end).data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义节点类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">        <span class="comment">//节点地址</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> address;</span><br><span class="line">        <span class="comment">//几点数据</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> data;</span><br><span class="line">        <span class="comment">//下一个节点的地址</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> next;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> address, <span class="keyword">int</span> data, <span class="keyword">int</span> next)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.address = address;</span><br><span class="line">            <span class="keyword">this</span>.data = data;</span><br><span class="line">            <span class="keyword">this</span>.next = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> PAT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>详解mnist数据集进行手写数字识别-tensorflow入门</title>
      <link href="2021/04/29/%E8%AF%A6%E8%A7%A3mnist%E6%95%B0%E6%8D%AE%E9%9B%86%E8%BF%9B%E8%A1%8C%E6%89%8B%E5%86%99%E6%95%B0%E5%AD%97%E8%AF%86%E5%88%AB-tensorflow%E5%85%A5%E9%97%A8/"/>
      <url>2021/04/29/%E8%AF%A6%E8%A7%A3mnist%E6%95%B0%E6%8D%AE%E9%9B%86%E8%BF%9B%E8%A1%8C%E6%89%8B%E5%86%99%E6%95%B0%E5%AD%97%E8%AF%86%E5%88%AB-tensorflow%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="mnist数据集进行手写数字识别–tensorflow入门"><a href="#mnist数据集进行手写数字识别–tensorflow入门" class="headerlink" title="mnist数据集进行手写数字识别–tensorflow入门"></a>mnist数据集进行手写数字识别–tensorflow入门</h2><ol><li>载入并准备好 MNIST 数据集</li><li>查看训练集和测试集</li><li>数据预处理  将这些值缩小至 0 到 1 之间，然后将其馈送到神经网络模型</li><li>构建模型 设置层</li><li>编译模型 损失函数 优化器 指标</li><li>训练验证模型 在模型训练期间，会显示损失和准确率指标</li><li>进行预测 预计结果实际结果可视化 对比</li><li>绘制图表 查看模型的预测</li><li>验证预测结果</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 载入并准备好 MNIST 数据集</span></span><br><span class="line">mnist = tf.keras.datasets.mnist</span><br><span class="line"><span class="comment"># 训练集和测试集</span></span><br><span class="line">(x_train, y_train), (x_test, y_test) = mnist.load_data()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看训练集数据 60000个训练图像 每个图像由 28 x 28 的像素表示</span></span><br><span class="line">print(x_train.shape)</span><br><span class="line">print(y_train.shape)</span><br><span class="line">print(<span class="built_in">len</span>(x_train))</span><br><span class="line"><span class="comment"># 查看测试集数据 10000个测试图像 每个图像由 28 x 28 的像素表示</span></span><br><span class="line">print(x_test.shape)</span><br><span class="line">print(y_test.shape)</span><br><span class="line">print(<span class="built_in">len</span>(x_test))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看训练集中第一个图像 像素值处于 0 到 255 之间</span></span><br><span class="line">plt.rcParams[<span class="string">&#x27;font.sans-serif&#x27;</span>] = [<span class="string">&#x27;KaiTi&#x27;</span>]</span><br><span class="line">plt.figure()</span><br><span class="line">plt.imshow(x_train[<span class="number">0</span>])</span><br><span class="line">plt.colorbar()</span><br><span class="line">plt.grid(<span class="literal">False</span>)</span><br><span class="line">plt.show()</span><br><span class="line"><span class="comment"># 数据预处理  将这些值缩小至 0 到 1 之间，然后将其馈送到神经网络模型</span></span><br><span class="line"><span class="comment"># 为此,将这些值除以 255  以相同的方式对训练集和测试集进行预处理</span></span><br><span class="line">x_train, x_test = x_train / <span class="number">255.0</span>, x_test / <span class="number">255.0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 验证数据格式是否正确 显示训练集中前25个图像，图像下方对应的数字</span></span><br><span class="line">plt.figure(figsize=(<span class="number">10</span>, <span class="number">10</span>))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">25</span>):</span><br><span class="line">    plt.subplot(<span class="number">5</span>, <span class="number">5</span>, i + <span class="number">1</span>)</span><br><span class="line">    plt.xticks([])</span><br><span class="line">    plt.yticks([])</span><br><span class="line">    plt.grid(<span class="literal">False</span>)</span><br><span class="line">    plt.imshow(x_train[i])</span><br><span class="line">    plt.xlabel(y_train[i])</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><h2 id="构建模型"><a href="#构建模型" class="headerlink" title="构建模型"></a>构建模型</h2><p><strong>layer1</strong> tf.keras.layers.Flatten 将图像格式从二维数组（28 x 28 像素）转换成一维数组（28 x 28 = 784 像素）。<br>将该层视为图像中未堆叠的像素行并将其排列起来。该层没有要学习的参数，它只会重新格式化数据。</p><p><strong>Layer2</strong> 层有 128个神经元，这128个神经元会和 Layer1 中 728 个神经元相互连接，共将产生 728 * 128 =93184 权重（weights）各自不同的连接 。<br>Layer1 中神经元的输出将与连接到 layer2 的权重值进行加权求和，得到的结果会被带入 relu 函数，最终输出一个新的值作为 Layer2 中神经元的输出。<br><strong>relu作为激活函数</strong></p><p><strong>layer3</strong> 使用 Dropout 随机丢弃 20% 神经元,防止过度拟合。</p><p><strong>layer4</strong> 有 10 个神经元，并使用 softmax作为激活函数，这 10个神经元的输出就是最终结的结果.</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 构建模型 设置层</span></span><br><span class="line">model = tf.keras.models.Sequential([</span><br><span class="line">    tf.keras.layers.Flatten(input_shape=(<span class="number">28</span>, <span class="number">28</span>)),</span><br><span class="line">    tf.keras.layers.Dense(<span class="number">128</span>, activation=<span class="string">&quot;relu&quot;</span>),</span><br><span class="line">    tf.keras.layers.Dropout(<span class="number">0.2</span>),</span><br><span class="line">    tf.keras.layers.Dense(<span class="number">10</span>, activation=<span class="string">&#x27;softmax&#x27;</span>)</span><br><span class="line">])</span><br></pre></td></tr></table></figure><h2 id="编译模型-损失函数-优化器-指标"><a href="#编译模型-损失函数-优化器-指标" class="headerlink" title="编译模型 损失函数 优化器 指标"></a>编译模型 损失函数 优化器 指标</h2><p>​    在准备对模型进行训练之前，还需要再对其进行一些设置。以下内容是在模型的编译步骤中添加的：<br>​        <strong>损失函数</strong> - 用于测量模型在训练期间的准确率。您会希望最小化此函数，以便将模型“引导”到正确的方向上。<br>​        <strong>优化器</strong> - 决定模型如何根据其看到的数据和自身的损失函数进行更新。<br>​       **指标 ** -用于监控训练和测试步骤。以下示例使用了准确率，即被正确分类的图像的比率。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">model.<span class="built_in">compile</span>(optimizer=<span class="string">&#x27;adam&#x27;</span>,</span><br><span class="line">              loss=<span class="string">&#x27;sparse_categorical_crossentropy&#x27;</span>,</span><br><span class="line">              metrics=[<span class="string">&#x27;accuracy&#x27;</span>])</span><br></pre></td></tr></table></figure><h2 id="训练模型"><a href="#训练模型" class="headerlink" title="训练模型"></a>训练模型</h2><p>训练神经网络模型需要执行以下步骤：<br>        将训练数据馈送给模型。在本例中，训练数据位于 x_train 和 y_train 数组中。<br>        模型学习将图像和标签关联起来。<br>        要求模型对测试集（在本例中为 x_test 数组）进行预测。<br>        验证预测是否与 y_test 数组中的标签相匹配。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 训练验证模型 在模型训练期间，会显示损失和准确率指标</span></span><br><span class="line">model.fit(x_train, y_train, epochs=<span class="number">5</span>)</span><br><span class="line"><span class="comment"># 模型在测试数据集上的表现 注意过拟合问题</span></span><br><span class="line">test_loss, test_acc = model.evaluate(x_test, y_test, verbose=<span class="number">2</span>)</span><br><span class="line">print(<span class="string">&#x27;\nTest accuracy:&#x27;</span>, test_acc)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 预测测试集中每个图像的数字</span></span><br><span class="line">predictions = model.predict(x_test)</span><br><span class="line"><span class="comment"># 查看第一个预测的结果 预测结果是一个包含 10 个数字的数组 它们代表模型对0-9数字的“置信度”</span></span><br><span class="line">print(predictions[<span class="number">0</span>])</span><br><span class="line"><span class="comment"># 可以看到哪个数字的置信度值最大</span></span><br><span class="line">print(np.argmax(predictions[<span class="number">0</span>]))</span><br><span class="line"><span class="comment"># 查看真实的结果</span></span><br><span class="line">print(y_test[<span class="number">0</span>])</span><br></pre></td></tr></table></figure><h2 id="预计结果实际结果可视化"><a href="#预计结果实际结果可视化" class="headerlink" title="预计结果实际结果可视化"></a>预计结果实际结果可视化</h2><p>模型经过训练后，可以使用它对一些图像进行预测。模型具有线性输出，即 logits,将 logits 转换成更容易理解的概率</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 绘制图表 查看模型的预测</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plot_image</span>(<span class="params">i, predict_array, true_num, img</span>):</span></span><br><span class="line">    predict_array, true_num, img = predict_array, true_num[i], img[i]</span><br><span class="line">    plt.grid(<span class="literal">False</span>)</span><br><span class="line">    plt.xticks([])</span><br><span class="line">    plt.yticks([])</span><br><span class="line"></span><br><span class="line">    plt.imshow(img)</span><br><span class="line">    predict_num = np.argmax(predict_array)</span><br><span class="line">    <span class="keyword">if</span> predict_num == true_num:</span><br><span class="line">        color = <span class="string">&#x27;blue&#x27;</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        color = <span class="string">&#x27;red&#x27;</span></span><br><span class="line">    <span class="comment"># 图像下方标签</span></span><br><span class="line">    plt.xlabel(<span class="string">&quot;预测值:&#123;&#125; 置信度：&#123;:2.0f&#125;% 实际值：&#123;&#125;&quot;</span>.<span class="built_in">format</span>(predict_num, <span class="number">100</span> * np.<span class="built_in">max</span>(predict_array), true_num), color=color)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plot_value_array</span>(<span class="params">i, predict_array, true_num</span>):</span></span><br><span class="line">    predict_array, true_num = predict_array, true_num[i]</span><br><span class="line">    plt.grid(<span class="literal">False</span>)</span><br><span class="line">    plt.xticks(<span class="built_in">range</span>(<span class="number">10</span>))</span><br><span class="line">    plt.yticks([])</span><br><span class="line">    thisplot = plt.bar(<span class="built_in">range</span>(<span class="number">10</span>), predict_array, color=<span class="string">&quot;#777777&quot;</span>)</span><br><span class="line">    plt.ylim([<span class="number">0</span>, <span class="number">1</span>])</span><br><span class="line">    predict_num = np.argmax(predict_array)</span><br><span class="line">    thisplot[predict_num].set_color(<span class="string">&#x27;red&#x27;</span>)</span><br><span class="line">    thisplot[true_num].set_color(<span class="string">&#x27;blue&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 验证预测结果</span></span><br><span class="line"><span class="comment"># 看第0个图像、预测结果和预测数组。正确的预测标签为蓝色，错误的预测标签为红色。数字表示预测标签的百分比（总计为 100）</span></span><br><span class="line">i = <span class="number">0</span></span><br><span class="line">plt.figure(figsize=(<span class="number">6</span>, <span class="number">3</span>))</span><br><span class="line">plt.subplot(<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>)</span><br><span class="line">plot_image(i, predictions[i], y_test, x_test)</span><br><span class="line">plt.subplot(<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line">plot_value_array(i, predictions[i], y_test)</span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用模型的预测绘制几张图像 注意，即使置信度很高，模型也可能出错</span></span><br><span class="line">num_rows = <span class="number">10</span></span><br><span class="line">num_cols = <span class="number">6</span></span><br><span class="line">num_images = num_rows * num_cols</span><br><span class="line">plt.figure(figsize=(<span class="number">2</span> * <span class="number">2</span> * num_cols, <span class="number">2</span> * num_rows))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> <span class="built_in">range</span>(num_images):</span><br><span class="line">    plt.subplot(num_rows, <span class="number">2</span> * num_cols, <span class="number">2</span> * item + <span class="number">1</span>)</span><br><span class="line">    plot_image(item, predictions[item], y_test, x_test)</span><br><span class="line">    plt.subplot(num_rows, <span class="number">2</span> * num_cols, <span class="number">2</span> * item + <span class="number">2</span>)</span><br><span class="line">    plot_value_array(item, predictions[item], y_test)</span><br><span class="line">plt.title(<span class="string">&quot;模型预测和实际对比图&quot;</span>)</span><br><span class="line">plt.tight_layout()</span><br><span class="line">plt.savefig(<span class="string">&#x27;predict--true.png&#x27;</span>)</span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用训练好的模型对单个图像进行预测</span></span><br><span class="line">img = x_test[<span class="number">15</span>]</span><br><span class="line">print(img.shape)</span><br><span class="line"><span class="comment"># tf.keras 模型经过了优化，可同时对一个批或一组样本进行预测。因此，即便只使用一个图像，也需要将其添加到列表中</span></span><br><span class="line">img = np.expand_dims(img, <span class="number">0</span>)</span><br><span class="line">print(img.shape)</span><br><span class="line"><span class="comment"># 预测此图像中的数字</span></span><br><span class="line">predict_single = model.predict(img)</span><br><span class="line">print(predict_single)</span><br><span class="line"><span class="comment"># 绘图</span></span><br><span class="line">plot_value_array(<span class="number">15</span>, predict_single[<span class="number">0</span>], y_test)</span><br><span class="line">_ = plt.xticks(<span class="built_in">range</span>(<span class="number">10</span>), <span class="built_in">range</span>(<span class="number">10</span>), rotation=<span class="number">45</span>)</span><br><span class="line">plt.show()</span><br><span class="line">print(<span class="string">&quot;predict:&quot;</span>, np.argmax(predict_single[<span class="number">0</span>]), <span class="string">&quot; real:&quot;</span>, y_test[<span class="number">15</span>])</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 手写数字识别 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>生物信息学入门名词</title>
      <link href="2021/04/16/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6%E5%85%A5%E9%97%A8%E5%90%8D%E8%AF%8D/"/>
      <url>2021/04/16/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6%E5%85%A5%E9%97%A8%E5%90%8D%E8%AF%8D/</url>
      
        <content type="html"><![CDATA[<h2 id="十个最常用的测序概念"><a href="#十个最常用的测序概念" class="headerlink" title="十个最常用的测序概念"></a>十个最常用的测序概念</h2><p><strong>1、高通量测序</strong>：</p><p>高通量测序技术（High-throughputsequencing，HTS）是对传统Sanger测序（称为一代测序技术）革命性的改变, 一次对几十万到几百万条核酸分子进行序列测定, 因此在有些文献中称其为下一代测序技术(next generation sequencing，NGS )足见其划时代的改变, 同时高通量测序使得对一个物种的转录组和基因组进行细致全貌的分析成为可能, 所以又被称为深度测序(Deep sequencing)。</p><p><strong>2、下一代测序</strong>：英文名为Next Generation Sequencing，简称为NGS。也叫做二代测序或者高通量测序。也称为高通量测序，high-throughput sequencing，或者称为新一代测序，全基因组测序WGS等等概念。是指相对于Sanger为主的第一代测序技术来说的，其特点是测序产量高，读长短，价格便宜。现在通常所说的二代测序技术，主要包括ABI的solid测序，罗氏的454测序技术、Life 公司的Ion Torrent测序技术和illumina公司的Hiseq、miseq测序技术等。当前最主要的是指illunina测序。</p><p><strong>3、全基因组测序 （Whole Genome Sequecing，WGS）</strong>：是指利用高通量测序平台对人类 不同个体或群体进行全基因组测序，并在个体或群体水平上进行生物信息分析的技术手段． 全基因组测序可全面挖掘 DNA 水平的遗传变异，包括较大的结构性变异，为筛选疾病的致病 及易感基因，研究发病及遗传机制 ，以及推断种群迁徙和进化等提供重要信息。全基因组测序可以检测人基因组上SNP突变，INDEL突变之外，还可以用于检测拷贝数变异CNV和结构变异SV，融合基因，病毒整合位点检测，非编码区突变检测等。</p><p><strong>4、全外显子组测序， Whole Exon Sequencing</strong>：也就是只测序基因组上的外显子区域。目前主要用于人基因组的研究，也包括一些小鼠等。人类基因组中约有180,000个外显子，占人全部基因组的1%，约30M。外显子测序是利用探针杂交富集外显子区域的DNA序列，然后通过高通量测序，主要用于研究基因组上编码区域的信息。WES只包含了基因组上外显子的信息，而WGS则覆盖了所有的遗传信息。相比于WGS，WES可以进行大样本高深度的测序。</p><p><strong>5、转录组测序</strong>：转录组即特定细胞在某一功能状态下所能转录出来的所有RNA的总和，包括mRNA和非编码RNA。转录组研究是基因功能及结构研究的基础和出发点，通过新一代高通量测序，能够全面快速地获得某一物种特定组织或器官在某一状态下的几乎所有转录本及基因序列，已广泛应用于基础研究、临床诊断和药物研发等领域。</p><p><img src= "/img/loading.gif" data-lazy-src="https://s3.ax1x.com/2020/11/16/DkTzOP.jpg" alt="name20201015"></p><p><strong>6、全基因组重测序</strong>：全基因组重测序是对已知基因组序列的物种进行不同个体的基因组测序，并在此基础上对个体或群体进行差异性分析。全基因组重测序的个体，通过序列比对，可以找到大量的单核苷酸多态性位点（SNP），插入缺失位点（InDel，Insertion/Deletion）、结构变异位点（SV，Structure Variation）位点。SBC可以协助客户，通过生物信息手段，分析不同个体基因组间的结构差异， 同时完成注释。</p><p><strong>7、Chip-seq</strong>：染色质免疫共沉淀技术（ChromatinImmunoprecipitation，ChIP）也称结合位点分析法，是研究体内蛋白质与DNA相互作用的有力工具，通常用于转录因子结合位点或组蛋白特异性修饰位点的研究。将ChIP与第二代测序技术相结合的ChIP-Seq技术，能够高效地在全基因组范围内检测与组蛋白、转录因子等互作的DNA区段。</p><p><strong>8、Hi-C测序</strong>：Hi-C技术源于染色体构象捕获（Chromosome Conformation Capture, 3C）技术，利用高通量测序技术，结合生物信息分析方法，研究全基因组范围内整个染色质DNA在空间位置上的关系，获得高分辨率的染色质三维结构信息。Hi-C技术不仅可以研究染色体片段之间的相互作用，建立基因组折叠模型，还可以应用于基因组组装、单体型图谱构建、辅助宏基因组组装等，并可以与RNA-Seq、ChIP-Seq等数据进行联合分析，从基因调控网络和表观遗传网络来阐述生物体性状形成的相关机制。</p><p><strong>9、单细胞测序（Single-cell sequencing</strong>）：单细胞测序是指<a href="https://link.zhihu.com/?target=https://baike.baidu.com/item/DNA/98123">DNA</a>研究中涉及测序单细胞微生物相对简单的基因组，更大更复杂的人类细胞基因组。</p><p><strong>10、亚硫酸氢盐测序（Bisulfite sequencing，BS-seq ，methseq）：</strong>先使用亚硫酸氢盐处理DNA，然后上机测序来确定甲基化模式，用亚硫酸氢盐处理DNA可将胞嘧啶残基（C）转化为尿嘧啶（U），但5-甲基胞嘧啶残基（5mC）对其有抗性，并不会发生转变。</p><h2 id="组学概念"><a href="#组学概念" class="headerlink" title="组学概念"></a>组学概念</h2><p><img src= "/img/loading.gif" data-lazy-src="https://s3.ax1x.com/2020/11/16/Dk7eO0.jpg" alt="v2-720w"></p><p><strong>11、功能基因组学(functional genomics)：</strong>功能基因组学(functional genomics)（Functuionalgenomics）又往往被称为后基因组学（Postgenomics），它利用结构基因组所提供的信息和产物，发展和应用新的实验手段，通过在基因组或系统水平上全面分析基因的功能，使得生物学研究从对单一基因或蛋白质得研究转向多个基因或蛋白质同时进行系统的研究。这是在基因组静态的碱基序列弄清楚之后转入对基因组动态的生物学功能学研究。研究内容包括基因功能发现、基因表达分析及突变检测。基因的功能包括：生物学功能，如作为蛋白质激酶对特异蛋白质进行磷酸化修饰；细胞学功能，如参与细胞间和细胞内信号传递途径；发育上功能，如参与形态建成等。采用的手段包括经典的减法杂交，差示筛选，cDNA代表差异分析以及mRNA差异显示等，但这些技术不能对基因进行全面系统的分析，新的技术应运而生，包括基因表达的系统分析（serial analysis of gene expression,SAGE），cDNA微阵列（cDNA microarray），DNA 芯片（DNA chip）和序列标志片段显示（sequence tagged fragmentsdisplay。</p><p><strong>12、比较基因组学(comparative genomics)：</strong>比较基因组学(comparative genomics)(ComparativeGenomics)是基于基因组图谱和测序基础上，对已知的基因和基因组结构进行比较，来了解基因的功能、表达机理和物种进化的学科。利用模式生物(model organism)基因组与人类基因组之间编码顺序上和结构上的同源性，克隆人类疾病基因，揭示基因功能和疾病分子机制(Molecular Mechanisms)，阐明物种进化关系，及基因组的内在结构。</p><p><strong>13、表观遗传学：</strong>表观遗传学是研究基因的核苷酸序列不发生改变的情况下，基因表达了可遗传的变化的一门遗传学分支学科。表观遗传的现象很多，已知的有DNA甲基化（DNAmethylation），基因组印记（genomicimpriting），母体效应（maternaleffects），基因沉默（genesilencing），核仁显性，休眠转座子激活和RNA编辑（RNA editing）等。</p><p><strong>14、蛋白质组学：</strong>蛋白质组学，是以蛋白质组为研究对象，研究细胞、组织或生物体蛋白质组成及其变化规律的科学</p><p><strong>15、基因组学：</strong>基因组学是对生物体所有基因进行集体表征、定量研究及不同基因组比较研究的一门交叉生物学学科。基因组学主要研究基因组的结构、功能、进化、定位和编辑等，以及它们对生物体的影响。</p><p><strong>16、代谢组学：</strong>代谢组学利用高通量、高灵敏度与高精确度的现代分析技术，对细胞、有机体分泌出来的体液中的代谢物的整体组成进行动态跟踪分析，借助多变量统计分析方法，来辩识和解析被研究对象的生理、病理状态及其与环境因子、基因组成等的关系。“代谢组学”是一种整体性的研究策略，其研究策略有点类似于通过分析发动机的尾气成分，来研究发动机的运行规律和故障诊断等的“反向工程学”的技术思路。由于代谢组学着眼于把研究对象作为一个整体来观察和分析，也被称为“整体的系统生物学”。</p><h2 id="关于序列比对"><a href="#关于序列比对" class="headerlink" title="关于序列比对"></a>关于序列比对</h2><p><strong>17、替换打分矩阵：</strong>替换记分矩阵是反映残基之间相互替换率的矩阵。也就是说，它描述了残基两两相似的量化关系，DNA 序列的替换记分矩阵主要有三种。一个是等价矩阵，另一种是转换-颠换矩阵，还有一种叫 BLAST 矩阵</p><p><img src= "/img/loading.gif" data-lazy-src="https://s3.ax1x.com/2020/11/16/Dk7uwT.jpg" alt="中国MOOC山东大学生物信息学课件"></p><p><strong>18、Needleman-Wunsch</strong> ：经典的全局比对算法是 Needleman-Wunsch 算法。1970 年，Needleman 和 Wunsch 首先将动态规划法应用于两条序列的全局比对，后来这个算法就称为 Needleman-Wunsch 算法。今天，所有比对软件使用的算法都是从这个经典算法衍生出来的。</p><p><img src= "/img/loading.gif" data-lazy-src="https://s3.ax1x.com/2020/11/16/Dk7lY4.jpg" alt="v2-44e6388c34379ff721802ff571da879a_720w"></p><p><strong>19、MEME：</strong>MEME 是一款寻找序列基序（motif）的软件。在核酸或蛋白质序列中存在一些有特定模式的序列片段，这些片段称为序列的基序（motif）。序列的基序与生物功能密切相关，MEME 是 The MEME Suite 在线软件套装中的一员（ <a href="https://link.zhihu.com/?target=http://meme-suite.org/%EF%BC%89%E3%80%82MEME">http://meme-suite.org/）。MEME</a> 的使用非常简单，只需要将待分析的序列上传即可。而且，上传的序列为原始序列，不需要提前为它们做多序列比对。你也可以指定返回排名前几的基序。MEME 的等待时间稍长，大约 10 分钟以上，所以最好留下邮箱。</p><p><img src= "/img/loading.gif" data-lazy-src="https://s3.ax1x.com/2020/11/16/Dk71fJ.jpg" alt="v2-58a5350017d0dd8b80b5be5773e15462_720w"></p><p><strong>20、WebLogo：</strong>寻找保守区域：序列标识图 WebLogo序列标识图就是序列的 logo，它是以图形的方式依次绘出序列比对中各个位置上出现的残基，每个位置上残基的累积可以反应出该位置上残基的一致性。每个残基对应图形字符的大小与残基在该位置上出现的频率成正比。但图形字符的大小并不等于频率百分比，而是经过简单统计计算后转化的结果。如果某一列非常保守，字母高度就高。反之，如果某一列没有什么特征，各种残基都有出现，杂乱无章，那么就会看到一堆比较矮的字母摞在一起</p><p><img src= "/img/loading.gif" data-lazy-src="https://s3.ax1x.com/2020/11/16/Dk7J61.jpg" alt="v2-591ef86d3bc1df87e212457e6fea0451_720w"></p><p><strong>21、TCOFFEE：</strong>TCOFFEE 是一个非常流行的多序列比对工具。TCOFFEE 与 CLUSTAL 系列在所使用的算法上类似，准确度上比 CLUSTAL 系列略高，但计算耗时也比 CLUSTAL 系列略高。最关键的是 TCOFFEE 有很多种变形，也就是说它有更多的功能。许多网站都提供 TCOFFEE的在线使用，比如 EMBL 的多序列比对工具里就有 TCOFFEE。但是这次，我们从 TCOFFEE的网站（ <a href="https://link.zhihu.com/?target=http://tcoffee.crg.cat/">T-COFFEE Multiple Sequence Alignment Server</a>）做多序列比对。</p><p><strong>21、BLAST：</strong>BLAST 实际上是综合在一起的一组工具的统称，它不仅可用于直接对蛋白质序列数据库和核酸序列数据库进行搜索，而且可以将待搜索的核酸序列翻译成蛋白质序列后再进行搜索，或者反之，以提高搜索效率。因此 BLAST 可以分为 BLASTp，BLASTn，BLASTx，tBLASTn和 tBLASTx。</p><p><img src= "/img/loading.gif" data-lazy-src="https://s3.ax1x.com/2020/11/16/Dk7YOx.jpg" alt="v2-9ab07872da2221bdcdac90d14f585b2f_720w"></p><p>BLASTp 也就是用蛋白质序列搜索蛋白质序列数据库，</p><p>BLASTn 是用核酸序列搜索核酸序列数据库，这是最直接也是最常用的两种 BLAST。</p><p>BLASTx 是将核酸序列按 6 条链翻译成蛋白质序列后搜索蛋白质序列数据库</p><p>tBLASTn 是用蛋白质序列搜核酸序列数据库，核酸数据库中的核酸序列要按 6 条链翻译成蛋白质序列后再被搜索</p><p>tBLASTx。它是将核酸序列按 6 条链翻译成蛋白质序列后搜索核酸序列数据库，核酸数据库中的所有核酸序列也要按 6 条链翻译成的蛋白质序列后再被搜索</p><h2 id="关于树"><a href="#关于树" class="headerlink" title="关于树"></a>关于树</h2><p><strong>19、进化树</strong>：英文Evolutionary Trees。在生物学中，用来表示物种之间的进化关系，又称“系统树”、“系谱树”。生物分类学家和进化论者根据各类生物间的亲缘关系的远近，把各类生物安置在有分枝的树状的图表上，简明地表示生物的进化历程和亲缘关系。</p><p>**20、分子树(molecular tree)**：依据分子数据构建的反映分子系统发育的树。</p><p><strong>30、系统发生树（英文：Phylogenetic tree）</strong>：又称为演化树（evolutionary tree），是表明被认为具有共同祖先的各物种间演化关系的树。是一种亲缘分支分类方法（cladogram）。在树中，每个节点代表其各分支的最近共同祖先，而节点间的线段长度对应演化距离（如估计的演化时间）。</p><p><img src= "/img/loading.gif" data-lazy-src="https://s3.ax1x.com/2020/11/16/Dk7aTO.jpg" alt="v2-72d97d3ff217b3b280ba2670f3c56bf3_720w"></p><h2 id="计算距离"><a href="#计算距离" class="headerlink" title="计算距离"></a>计算距离</h2><p><strong>31、MP 最大简约法（maximal parsimony）</strong>：假设4种核苷酸或者20中氨基酸可以突变为与其自身不同的任何一种，这样对于任何一个给定的拓朴结构，可以推断每个位点的祖先状态。对这一拓朴结构，可以计算出用来解释整个进化过程所需核苷酸或者氨基酸的最小替代数。对所有可能正确的拓朴结构进行这种计算，并挑选出所需替代数最小的拓朴结构作为最优系统树。</p><p><strong>32、NJ 邻接法（neighbour joining）</strong>：是距离法中的一种，这种方法并不检验所有可能的拓朴结构，但在物种聚合时要应用最小进化原则。</p><p><strong>33、ML 最大似然法（ maximal likelihood ）</strong>：在ML法中，以一个特定的替代模型分析既定的一组序列数据，使所获得的每一个拓朴结构的拟自然率最大，挑选出其中拟自然率最大的拓朴结构作为最终树。</p><h2 id="测序基础"><a href="#测序基础" class="headerlink" title="测序基础"></a>测序基础</h2><p><strong>34、测序深度和覆盖度：</strong>测序深度（Sequencing Depth）：测序得到的碱基总量（bp）与基因组大小（Genome）的比值，它是评价测序量的指标之一。测序深度与基因组覆盖度之间是一个正相关的关系，测序带来的错误率或假阳性结果会随着测序深度的提升而下降。重测序的个体，如果采用的是双末端或Mate-Pair方案，当测序深度在10~15X以上时，基因组覆盖度和测序错误率控制均得以保证。</p><p><strong>35、DNA甲基化：</strong>DNA甲基化是指在DNA甲基化转移酶的作用下，在基因组CpG二核苷酸的胞嘧啶5”碳位共价键结合一个甲基基团。</p><p><strong>36、基因组注释：</strong>基因组注释(Genomeannotation) 是利用生物信息(bioinformation)学方法和工具,对基因组所有基因的生物学功能进行高通量注释,是当前功能基因组学(functional genomics)研究的一个热点。基因组注释的研究内容包括基因识别和基因功能注释两个方面。基因识别的核心是确定全基因组序列中所有基因的确切位置</p><p><strong>37、index *：*</strong>测序的标签，用于测定混合样本，通过每个样本添加的不同标签进行数据区分，鉴别测序样品。</p><p><strong>38、碱基质量值 ：</strong>（Quality Score 或 Q-score ）是碱基识别（ Base Calling ）出错的概率的整数映射。碱基质量值越高表明碱基识别越可靠，碱基测错的可能性越小。</p><p><strong>39、Q30 ：</strong>碱基质量值为 Q30 代表碱基的精确度在 99.9% 。</p><p><strong>40、FPKM</strong>（Fragments Per Kilobase of transcript per Million fragments mapped ） 每 1 百万个 map 上的 reads 中 map 到外显子的每 1K 个碱基上的 fragment 个数。</p><p><strong>41、TPM：</strong>TPM与FPKM最大的区别在于消除两种影响的次序：在TPM中先消除基因长度的影响，再消除测序深度的影响。计算TPM的过程也可以分为三个步骤：</p><ol><li>将每个read counts除以对应基因的长度（外显子区域的长度，单位为kb），此时得到每千个碱基包含的reads数，即（reads per kilobase, RPK）；</li><li>将一个样本中的RPK加起来的总数除以$10^6$，得到”per million”缩放系数（这是两种方法计算结果不同的主要来源，因为这里的总数是消除了基因长度的影响之后得到的RPK，而不是原始read counts之和）；</li><li>用RPK除以”per million”缩放系数，得到TPM。</li></ol><p><strong>42、FC（Fold Change ）：</strong>即差异表达倍数。</p><p><strong>43、FDR （False Discovery Rate ）：</strong>即错误发现率，定义为在多重假设检验过程中，错误拒绝 (拒绝真的原 (零)假设 )的个数占所有被拒绝的原假设个数的比例的期望值。通过控制 FDR 来决定 P 值的阈值。</p><p><strong>44、P 值（P-value ）：</strong>即概率，反映某一事件发生的可能性大小。 统计学根据显著性检验方法所得到的 P 值，一般以 P&lt;0.05为显著， P&lt;0.01 为非常显著，其含义是样本间的差异由抽样误差所致的概率小于 0.05 或 0.01 。</p><p><strong>45、可变剪接（ Alternative splicing ）：</strong>有些基因的一个 mRNA 前体通过不同的剪接方式 （选择不同的剪接位点） 产生不同的 mRNA 剪接异构体，这一过程称为可变剪接 (或选择性剪接， alternative splicing) 。可变剪接是调节基因表达和产生蛋白质组多样性的重要机制，是导致真核生物基因和蛋白质数量较大差异的重要原因。在生物体内，主要存在7 种可变剪接类型： A）Exon skipping ；B）Intron retention ；C) Alternative 5’ splice site ；D) Alternative 3’ splice site ；E) Alternative first exon ；F) Alternativelast exon ；G) Mutually exclusive exon 。</p><p><strong>46、外显子跳跃（ Exon skipping ）：</strong>外显子在前体 mRNA 剪接形成成熟 mRNA 过程中被跳过，最终没有出现在某些成熟 mRNA 上，这种剪接机制被称为外显子跳跃。</p><p><strong>47、内含子保留（ Intron retention ）：</strong>前体 mRNA 在剪接形成成熟 mRNA 的过程中， 部分内含子被保留下来， 这种剪接机制被称为内含子保留。</p><p><strong>48、5’ 或 3’端可变剪接：</strong>前体 mRNA 在剪接形成成熟 mRNA 的过程中， 5’端或 3’端边界发生不同方式的剪接，这种剪接机制被称为 5’或 3’端可变剪接。</p><p><strong>49、基因结构优化：</strong>由于使用的软件或数据本身的局限性，导致所选参考基因组的注释往往不够精确，需要对原有注释的基因结构进行修正，这一过程称为基因结构优化。</p><p><strong>50、基因间区 (intergenic) ：</strong>指基因与基因之间的间隔序列，不属于基因结构，不直接决定氨基酸，可能通过转录后调控影响性状的区域。</p><p><strong>51、UTR:(UntranslateRegions) ：</strong>非翻译区域。是信使 RNA（mRNA ）分子两端的非编码片段。 5’-UTR 从 mRNA 起点的甲基化鸟嘌呤核苷酸帽延伸至 AUG 起始密码子， 3’-UTR 从编码区末端的终止密码子延伸至多聚 A 尾巴（ Poly-A ）的前端。</p><p><strong>52、ORF （open reading frame ）：</strong>开放阅读框或开放读码框。是结构基因的正常核苷酸序列，从起始密码子到终止密码子的阅读框可编码完整的多肽链，其间不存在使翻译中断的终止密码子。</p><p><strong>53、CDS （Coding sequence ）：</strong> 是编码一段蛋白产物的序列，是结构基因组学术语。 DNA 转录成 mRNA ，mRNA 经剪接等加工后翻译出蛋白质，所谓 CDS 就是与蛋白质序列一一对应的 DNA 序列，且该序列中间不含其它非该蛋白质对应的序列，不考虑 mRNA 加工等过程中的序列变化，总之，就是与蛋白质的密码子完全对应。</p><p><strong>54、插入片段大小（ insert size ）：</strong>通过检测双端序列在基因组上的起止位置，可以得到插入片段的实际长度，决定了测序的长度，是信息分析的重要参数。</p><p><strong>55、分子标记：</strong>是遗传标记的一种，直接在 DNA 分子上检测遗传变异。分子标记能对不同发育时期的个体、组织器官甚至细胞作检测， 数量极多， 遍及整个基因组， 多态性高， 遗传稳定， 不受环境及基因表达与否的影响。目前常见分子标记主要有 SNP 、InDel 、SSR 等。</p><p><strong>56、SNP （Single Nucleotide Polymorphism ）：</strong>即单核苷酸多态性，主要是指在基因组水平上由单个核苷酸的变异所引起的 DNA 序列多态性。 SNP所表现的多态性只涉及到单个碱基的变异，这种变异可由单个碱基的转换 (transition) 或颠换 (transversion)所引起，也可由碱基的插入或缺失所致。但通常所说的 SNP 并不包括后两种情况。</p><p><strong>57、SSR （Simple Sequence Repeat ，SSR）：</strong>即简单重复序列， 又叫微卫星序列， 指的是基因组中由 1-6 个核苷酸组成的基本单位重复多次构成的一段 DNA，广泛分布于基因组的不同位置，长度一般在 200bp 以下。</p><p><strong>58、转换(transition) ：</strong>同类型（嘌呤和嘌呤，或嘧啶和嘧啶）碱基之间的相互替换称为转换。</p><p><strong>59、颠换(transversion) ：</strong>不同类型（嘌呤和嘧啶）碱基之间的相互替换称为颠换。</p><p><strong>60、RNA 编辑（ RNA editing ）：</strong> 是指在 mRNA 水平上改变遗传信息的过程。 具体来说， 指基因转录产生的 mRNA 分子中， 由于核苷酸的缺失，插入或置换，基因转录物的序列不与编码序列互补，使翻译生成的蛋白质的氨基酸组成，不同于基因序列中的编码信息现象。</p><p><strong>61、 差异表达转录本（ DifferentiallyExpressed Transcript ，DET）：</strong>指表达水平存在显著差异的转录本。</p><p><strong>62、差异表达基因（ Differentially Expressed Gene ，DEG） ：</strong>指在两个不同条件（如对照与处理、野生型和突变型、不同时间点、不同组织等）下，表达水平存在显著差异的基因，称之为差异表达基因。</p><p><strong>63、生物学重复（ Biological Replicates ）：</strong>可以定义为使用来自不同抽提的 RNA 样本进行杂交，例如，同一来源独立制备的样本，或者不同来源的样本（不同组织或者一个细胞系的不同培养物）。</p><p><strong>64、 技术重复：</strong>使用同一个抽提的 RNA 进行实验称为技术重复。与生物学重复相比，技术重复不是完全独立的，取平均值不能去除共有的系统偏差。</p><p><strong>65、皮尔逊相关系数 r（Pearson ’s Correlation Coefficient ）：</strong>用于度量两个变量 X 和 Y 之间的相关（线性相关），其值介于 -1 与 1 之间。其中， 1 表示变量完全正相关， 0 表示无关， -1 表示完全负相关。在高通量测序中，将皮尔逊相关系数作为生物学重复相关性的评估指标。越接近 1，说明两个重复样品相关性越强。</p><p><strong>66、Contig ：</strong>高通量测序中利用软件将具有一定长度 overlap 的 reads 连成更长的片段，这些通过 reads overlap关系得到的不含 N 的组装片段称之为 Contig 。</p><p><strong>67、Scaffold ：</strong>高通量测序中 reads 经过拼接获得 Contigs ，Contig 经过确定先后顺序用 N 连接起来组成 Scaffold 。</p><p><strong>68、Contig N50 ：</strong>Reads 拼接后会得到长度不同的 Contigs 。将所有 Contigs 的长度相加后获得一个 Contig 的总长度。之后将所有 Contig 按照序列长度由短到长进行排序， 如获得 Contig1 ，Contig2 ，Contig3 ⋯⋯.. 。将 Contig按照这个顺序一次相加，当相加的长度达到 Contig 总长度的一半时，最后一个加上的 Contig 长度即为Contig N50 。</p><p><strong>69、component ：</strong>TRINITY 软件拼接过程中， 由于 contig 的构造方法，使得各个 contig 之间不可能共享 k 个以上序列，因此这些 inchwormcontigs 不能很好的表征各种可变剪切形式和同源基因等情况，软件中 “chrysalis ” 这一步骤将那些有重叠的 contigs 聚类，构成 components 。component 就成为一组可变剪切 isoform 或同源基因可能的表征的集合。</p><p><strong>70、de Bruijn graph ：</strong>使用 TRINITY 软件拼接时，在 “chrysalis ”步骤中会将 component 通过 overlap 关系构建成 de Bruijn 图，便于获取可变剪切的序列。</p><p><strong>71、数字基因表达谱（ DigitalGene Expression Profile ，DGE ）：</strong>利用新一代高通量测序技术和高性能的计算分析技术，能够全面、经济、快速地检测某一物种特定组织在特定状态下的基因表达情况。</p><p><strong>72、small RNA ：</strong>对长度在 18-40bp 的短 RNA 进行序列、结构、表达、功能上的分析，主要进行 miRNA ，siRNA ，piRNA 几种类型 sRNA 的分析；可与 mRNA 关联分析。</p><p><strong>73、ncRNA （non-coding RNA ）：</strong>非编码 RNA 。指不编码蛋白质的 RNA 。其中包括 rRNA ，tRNA ，snRNA ，snoRNA 和 microRNA 等多种已知功能的 RNA，及未知功能的 RNA 。其共同特点是都能从基因组上转录而来，不需要翻译成蛋白即可在 RNA 水平上行使各自的生物学功能。</p><p><strong>74、降解组测序（ Degradome Sequencing ）：</strong>利用高通量测序平台，针对 miRNA 介导的剪切降解片段进行深度测序，从中筛选 miRNA 作用的靶基因，并结合生物信息学分析确定降解片段与 miRNA 的精确配对信息。该技术能从细胞或组织中准确高效的筛选出 miRNA 的靶基因，为研究 miRNA 与其对应的靶基因的相互关系提供准确、 高效的筛选手段。</p><p><strong>75、lncRNA （long noncoding RNA ）：</strong>长链非编码 RNA 。在长度 200-100000nt 之间，不具有编码蛋白功能的转录本。</p><p><strong>76、正链/负链（ plus strand/minus strand ） ：</strong>对于一个基因来说， DNA 的两条链中有一条链作为 RNA 合成时的模板， 这条链叫负链， 另一条叫正链。正链和负链并无生物学上的意义，它是人为定义的，在人类基因组计划中，我们把跟reference genome同向的这条链称为正链，与之反向的称为负链</p><p><strong>77、反义链 /有义链（ antisense strand/sense strand ）：</strong>在双链 DNA 中，用来转录 mRNA 的 DNA 链称为模板链 (template strand) ，不用于转录的链则称为非模板链（ nontemplate strand ）。根据碱基互补配对原则，转录出的 mRNA 链的碱基序列与非模板链的碱基序列一致，惟一不同的是，非模板链中的 T mRNA 链中全部置换成了 U。正是由于非模板链的碱基序列实际上代表了 mRNA 的碱基序列（只不过在 mRNA 中 T 换成了 U），因此非模板链又被称为编码链（ coding strand ）,有义链（ sense strand ）和克里克链 (crick strand) ，而用来转录 mRNA 的 DNA 链被称为非编码链（ anticoding strand ）或反义链（ antisense strand ）或沃森链 (watson strand) 。</p><p><strong>78、链特异性（ strand specific ）：</strong>链特异性建库，可以确定转录本来自正链还是负链。以便更加准确的获得基因的结构以及基因表达信息。并且可以更好的发现新的基因。（研究表明：很多基因组区域具有正负链的转录本，反义转录是真核基因的一个特征，是一种重要的调控方式。对于原核以及低等真核生物的基因组，常常具有重叠基因。</p><p><strong>79、GO （Gene Ontology ）：</strong>基因本体联合会 （Gene Ontology Consortium ）所建立的数据库， 旨在建立一个适用于各种物种的，堆积因何蛋白质功能进行限定和描述的，并能随着研究不断深入而更新的语言词汇标准。 GO 是多种生物本体语言中的一种，提供了三层结构（分子功能、生物学途径、细胞组件）的系统定义方式，用于描述基因产物的功能。</p><p><strong>80、 BSR(Bulked Segregant RNA sequencing) ：</strong>将转录组测序与集群分离分析相结合，在转录组范围内开发 SNPs ，筛选与性状紧密连锁的 SNPs ，进行功能基因的定位，同时进行基因差异表达分析等转录组常规分析的技术。</p><p><strong>81、Nr(NCBI non-redundant protein sequences) ：</strong>是 NCBI 官方的蛋白序列数据库， 它包括了 GenBank 基因的蛋白编码序列， PDB(Protein Data Bank)蛋白数据库、SwissProt 蛋白序列及来自 PIR（Protein Information Resource ）和 PRF（Protein Research Foundation ）等数据库的蛋白序列。根据 nr 注释信息我们能得到 GO 功能注释。</p><p><strong>82、KEGG(Kyoto Encyclopedia of Genes and Genomes) ：</strong>是系统分析基因产物和化合物在细胞中的代谢途径以及这些基因产物的功能的数据库。它整合了基因组、化学分子和生化系统等方面的数据 ,包括代谢通路（ KEGG PATHWAY ）、药物（ KEGG DRUG ）、疾病（KEGG DISEASE ）、功能模型 （KEGG MODULE ）、基因序列 （KEGG GENES ）及基因组 （KEGG GENOME ）等等。 KO（KEGG ORTHOLOG ）系统将各个 KEGG 注释系统联系在一起， KEGG 已建立了一套完整 KO 注释的系统，可完成新测序物种的基因组或转录组的功能注释。</p><p><strong>83、Rfam 是 ncRNA 注释库：</strong>包含 rRNA ，tRNA ，snoRNA ，snRNA 等类型非编码 RNA。详见 <a href="https://link.zhihu.com/?target=http://rfam.xfam.org/">Rfam: Home page</a> 。</p><h2 id="其他重要的概念"><a href="#其他重要的概念" class="headerlink" title="其他重要的概念"></a>其他重要的概念</h2><p><strong>84、表达谱</strong>：基因表达谱(geneexpression profile)：指通过构建处于某一特定状态下的细胞或组织的非偏性cDNA文库,大规模cDNA测序,收集cDNA序列片段、定性、定量分析其mRNA群体组成,从而描绘该特定细胞或组织在特定状态下的基因表达种类和丰度信息,这样编制成的数据表就称为基因表达谱</p><p><strong>85、计算生物学</strong>：计算生物学是指开发和应用数据分析及理论的方法、数学建模、计算机仿真技术等。当前，生物学数据量和复杂性不断增长，单单依靠观察和实验已难以应付。因此，必须依靠大规模计算模拟技术，从海量信息中提取最有用的数据。</p>]]></content>
      
      
      <categories>
          
          <category> bioinformatics </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>tensorflow回归问题</title>
      <link href="2021/03/30/tensorflow%E5%9B%9E%E5%BD%92%E9%97%AE%E9%A2%98/"/>
      <url>2021/03/30/tensorflow%E5%9B%9E%E5%BD%92%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="tensorflow回归问题"><a href="#tensorflow回归问题" class="headerlink" title="tensorflow回归问题"></a>tensorflow回归问题</h2><p>在 回归 (regression) 问题中，目的是预测出如价格或概率这样连续值的输出。<br>相对于分类(classification) 问题，分类(classification) 的目的是从一系列的分类出选择出一个分类<br>（如，给出一张包含苹果或橘子的图片，识别出图片中是哪种水果）。</p><p>本demo使用经典的 Auto MPG 数据集，构建了一个用来预测70年代末到80年代初汽车燃油效率的模型。<br>为了做到这一点，为该模型提供许多那个时期的汽车描述。这个描述包含：气缸数，排量，马力以及重量。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">from</span> tensorflow <span class="keyword">import</span> keras</span><br><span class="line"><span class="keyword">from</span> tensorflow.keras <span class="keyword">import</span> layers</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取数据</span></span><br><span class="line">dataset_path = keras.utils.get_file(<span class="string">&#x27;auto-mpg.data&#x27;</span>,</span><br><span class="line">                                    <span class="string">&#x27;http://archive.ics.uci.edu/ml/machine-learning-databases/auto-mpg/auto-mpg.data&#x27;</span>)</span><br><span class="line">print(dataset_path)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用pandas导入数据集</span></span><br><span class="line">column_names = [<span class="string">&#x27;MPG&#x27;</span>, <span class="string">&#x27;Cylinders&#x27;</span>, <span class="string">&#x27;Displacement&#x27;</span>, <span class="string">&#x27;Horsepower&#x27;</span>, <span class="string">&#x27;Weight&#x27;</span>, <span class="string">&#x27;Acceleration&#x27;</span>, <span class="string">&#x27;Model Year&#x27;</span>, <span class="string">&#x27;Origin&#x27;</span>]</span><br><span class="line">raw_dataset = pd.read_csv(dataset_path, names=column_names,</span><br><span class="line">                          na_values=<span class="string">&quot;?&quot;</span>, comment=<span class="string">&#x27;\t&#x27;</span>,</span><br><span class="line">                          sep=<span class="string">&quot; &quot;</span>, skipinitialspace=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">dataset = raw_dataset.copy()</span><br><span class="line">print(dataset.tail())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 数据清洗 数据集中包含一些未知值</span></span><br><span class="line">dataset.isna().<span class="built_in">sum</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 为保证初始示例的简单性 删除这些行</span></span><br><span class="line">dataset = dataset.dropna()</span><br><span class="line"></span><br><span class="line"><span class="comment"># &quot;Origin&quot; 列实际上代表分类，而不仅仅是一个数字。所以把它转换为独热码 （one-hot）</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">独热码</span></span><br><span class="line"><span class="string">在英文文献中称做one-hot code, 直观来说就是有多少个状态就有多少比特，而且只有一个比特为1，其他全为0的一种码制。 </span></span><br><span class="line"><span class="string">通常，在通信网络协议栈中，使用八位或者十六位状态的独热码，且系统占用其中一个状态码，余下的可以供用户使用</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">origin = dataset.pop(<span class="string">&#x27;Origin&#x27;</span>)</span><br><span class="line">dataset[<span class="string">&#x27;USA&#x27;</span>] = (origin == <span class="number">1</span>) * <span class="number">1.0</span></span><br><span class="line">dataset[<span class="string">&#x27;Europe&#x27;</span>] = (origin == <span class="number">2</span>) * <span class="number">1.0</span></span><br><span class="line">dataset[<span class="string">&#x27;Japan&#x27;</span>] = (origin == <span class="number">3</span>) * <span class="number">1.0</span></span><br><span class="line">print(dataset.tail())</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">拆分训练数据集和测试数据集</span></span><br><span class="line"><span class="string">现在需要将数据集拆分为一个训练数据集和一个测试数据集。</span></span><br><span class="line"><span class="string">最后将使用测试数据集对模型进行评估。</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">train_dataset = dataset.sample(frac=<span class="number">0.8</span>, random_state=<span class="number">0</span>)</span><br><span class="line">test_dataset = dataset.drop(train_dataset.index)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 数据检查</span></span><br><span class="line"><span class="comment"># 快速查看训练集中几对列的联合分布</span></span><br><span class="line">sns.pairplot(train_dataset[[<span class="string">&quot;MPG&quot;</span>, <span class="string">&quot;Cylinders&quot;</span>, <span class="string">&quot;Displacement&quot;</span>, <span class="string">&quot;Weight&quot;</span>]], diag_kind=<span class="string">&quot;kde&quot;</span>)</span><br><span class="line">plt.savefig(<span class="string">&#x27;basicRegression.png&#x27;</span>)</span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看总体的数据统计</span></span><br><span class="line">train_stats = train_dataset.describe()</span><br><span class="line">train_stats.pop(<span class="string">&#x27;MPG&#x27;</span>)</span><br><span class="line">train_stats = train_stats.transpose()</span><br><span class="line">print(train_stats)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从标签中分离特征</span></span><br><span class="line"><span class="comment"># 将特征值冲目标值或者”标签&#x27;中分离， 这个标签是使用训练模型进行预测的值</span></span><br><span class="line">train_labels = train_dataset.pop(<span class="string">&#x27;MPG&#x27;</span>)</span><br><span class="line">test_labels = test_dataset.pop(<span class="string">&#x27;MPG&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">数据规范化</span></span><br><span class="line"><span class="string">再次审视下上面的 train_stats 部分，并注意每个特征的范围有什么不同。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">使用不同的尺度和范围对特征归一化是好的实践。</span></span><br><span class="line"><span class="string">尽管模型可能 在没有特征归一化的情况下收敛，它会使得模型训练更加复杂，并会造成生成的模型依赖输入所使用的单位选择。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">注意：尽管仅仅从训练集中有意生成这些统计数据，但是这些统计信息也会用于归一化的测试数据集。</span></span><br><span class="line"><span class="string">需要这样做，将测试数据集放入到与已经训练过的模型相同的分布中。</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">norm</span>(<span class="params">x</span>):</span></span><br><span class="line">    <span class="keyword">return</span> (x - train_stats[<span class="string">&#x27;mean&#x27;</span>]) / train_stats[<span class="string">&#x27;std&#x27;</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">normed_train_data = norm(train_dataset)</span><br><span class="line">normed_test_data = norm(test_dataset)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">使用这个已经归一化的数据来训练模型。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">警告: 用于归一化输入的数据统计（均值和标准差）需要反馈给模型从而应用于任何其他数据，</span></span><br><span class="line"><span class="string">以及之前所获得独热码。这些数据包含测试数据集以及生产环境中所使用的实时数据。</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 构建模型</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">构建自己的模型。使用一个“顺序”模型，其中包含两个紧密相连的隐藏层，以及返回单个、连续值得输出层。</span></span><br><span class="line"><span class="string">模型的构建步骤包含于一个名叫 &#x27;build_model&#x27; 的函数中，稍后将会创建第二个模型。 两个密集连接的隐藏层。</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">build_model</span>():</span></span><br><span class="line">    model = keras.Sequential([</span><br><span class="line">        layers.Dense(<span class="number">64</span>, activation=<span class="string">&#x27;relu&#x27;</span>, input_shape=[<span class="built_in">len</span>(train_dataset.keys())]),</span><br><span class="line">        layers.Dense(<span class="number">64</span>, activation=<span class="string">&#x27;relu&#x27;</span>),</span><br><span class="line">        layers.Dense(<span class="number">1</span>)</span><br><span class="line">    ])</span><br><span class="line">    optimizer = tf.keras.optimizers.RMSprop(<span class="number">0.001</span>)</span><br><span class="line">    model.<span class="built_in">compile</span>(loss=<span class="string">&#x27;mse&#x27;</span>,</span><br><span class="line">                  optimizer=optimizer,</span><br><span class="line">                  metrics=[<span class="string">&#x27;mae&#x27;</span>, <span class="string">&#x27;mse&#x27;</span>])</span><br><span class="line">    <span class="keyword">return</span> model</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">model = build_model()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查模型  使用 .summary 方法来打印该模型的简单描述</span></span><br><span class="line">model.summary()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 试用下这个模型。从训练数据中批量获取10条例子并对这些例子调用 model.predict</span></span><br><span class="line">example_batch = normed_train_data[:<span class="number">10</span>]</span><br><span class="line">example_result = model.predict(example_batch)</span><br><span class="line">print(example_result)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 训练模型 对模型进行1000个周期的训练，并在 history 对象中记录训练和验证的准确性</span></span><br><span class="line"><span class="comment"># 通过为每个完成的时期打印一个点来显示训练进度</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PrintDot</span>(<span class="params">keras.callbacks.Callback</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">on_epoch_end</span>(<span class="params">self, epoch, logs</span>):</span></span><br><span class="line">        <span class="keyword">if</span> epoch % <span class="number">100</span> == <span class="number">0</span>: print(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">        print(<span class="string">&#x27;.&#x27;</span>, end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">EPOCHS = <span class="number">1000</span></span><br><span class="line">history = model.fit(</span><br><span class="line">    normed_train_data, train_labels,</span><br><span class="line">    epochs=EPOCHS, validation_split=<span class="number">0.2</span>, verbose=<span class="number">0</span>,</span><br><span class="line">    callbacks=[PrintDot()]</span><br><span class="line">)</span><br><span class="line">print(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 history 对象中存储的统计信息可视化模型的训练进度</span></span><br><span class="line">hist = pd.DataFrame(history.history)</span><br><span class="line">hist[<span class="string">&#x27;epoch&#x27;</span>] = history.epoch</span><br><span class="line">print(hist.tail())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘图</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plot_history</span>(<span class="params">history</span>):</span></span><br><span class="line">    hist = pd.DataFrame(history.history)</span><br><span class="line">    hist[<span class="string">&#x27;epoch&#x27;</span>] = history.epoch</span><br><span class="line">    plt.figure()</span><br><span class="line">    plt.xlabel(<span class="string">&#x27;Epoch&#x27;</span>)</span><br><span class="line">    plt.ylabel(<span class="string">&#x27;Mean Abs Error [MPG]&#x27;</span>)</span><br><span class="line">    plt.plot(hist[<span class="string">&#x27;epoch&#x27;</span>], hist[<span class="string">&#x27;mae&#x27;</span>],</span><br><span class="line">             label=<span class="string">&#x27;Train Error&#x27;</span>)</span><br><span class="line">    plt.plot(hist[<span class="string">&#x27;epoch&#x27;</span>], hist[<span class="string">&#x27;val_mae&#x27;</span>],</span><br><span class="line">             label=<span class="string">&#x27;Val Error&#x27;</span>)</span><br><span class="line">    plt.ylim([<span class="number">0</span>, <span class="number">5</span>])</span><br><span class="line">    plt.legend()</span><br><span class="line"></span><br><span class="line">    plt.figure()</span><br><span class="line">    plt.xlabel(<span class="string">&#x27;Epoch&#x27;</span>)</span><br><span class="line">    plt.ylabel(<span class="string">&#x27;Mean Square Error [$MPG^2$]&#x27;</span>)</span><br><span class="line">    plt.plot(hist[<span class="string">&#x27;epoch&#x27;</span>], hist[<span class="string">&#x27;mse&#x27;</span>],</span><br><span class="line">             label=<span class="string">&#x27;Train Error&#x27;</span>)</span><br><span class="line">    plt.plot(hist[<span class="string">&#x27;epoch&#x27;</span>], hist[<span class="string">&#x27;val_mse&#x27;</span>],</span><br><span class="line">             label=<span class="string">&#x27;Val Error&#x27;</span>)</span><br><span class="line">    plt.ylim([<span class="number">0</span>, <span class="number">20</span>])</span><br><span class="line">    plt.legend()</span><br><span class="line">    plt.show()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">plot_history(history)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string"> 该图表显示在约100个 epochs 之后误差非但没有改进，反而出现恶化。</span></span><br><span class="line"><span class="string"> 更新 model.fit 调用，当验证值没有提高上是自动停止训练。 </span></span><br><span class="line"><span class="string"> 使用一个 EarlyStopping callback 来测试每个 epoch 的训练条件。</span></span><br><span class="line"><span class="string"> 如果经过一定数量的 epochs 后没有改进，则自动停止训练。</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">model = build_model()</span><br><span class="line"><span class="comment"># patience 值用来检查改进epochs的值</span></span><br><span class="line">early_stop = keras.callbacks.EarlyStopping(monitor=<span class="string">&#x27;val_loss&#x27;</span>, patience=<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">history = model.fit(normed_train_data, train_labels, epochs=EPOCHS,</span><br><span class="line">                    validation_split=<span class="number">0.2</span>, verbose=<span class="number">0</span>, callbacks=[early_stop, PrintDot()])</span><br><span class="line"><span class="comment"># 如图所示，验证集中的平均的误差通常在 +/- 2 MPG左右</span></span><br><span class="line">plot_history(history)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用测试集来泛化模型的效果如何</span></span><br><span class="line">loss, mae, mse = model.evaluate(normed_test_data, test_labels, verbose=<span class="number">2</span>)</span><br><span class="line">print(<span class="string">&quot;Testing set Mean Abs Error: &#123;:5.2f&#125; MPG&quot;</span>.<span class="built_in">format</span>(mae))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 做预测 使用测试集中的数据预测MPG值</span></span><br><span class="line">test_predictions = model.predict(normed_test_data).flatten()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 看起来模型预测的挺好</span></span><br><span class="line">plt.scatter(test_labels, test_predictions)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;True Values [MPG]&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;Predictions [MPG]&#x27;</span>)</span><br><span class="line">plt.axis(<span class="string">&#x27;equal&#x27;</span>)</span><br><span class="line">plt.axis(<span class="string">&#x27;square&#x27;</span>)</span><br><span class="line">plt.xlim([<span class="number">0</span>, plt.xlim()[<span class="number">1</span>]])</span><br><span class="line">plt.ylim([<span class="number">0</span>, plt.ylim()[<span class="number">1</span>]])</span><br><span class="line">_ = plt.plot([<span class="number">-100</span>, <span class="number">100</span>], [<span class="number">-100</span>, <span class="number">100</span>])</span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 看误差分布情况 结果不是完全的高斯分布 推断是由于样本量很小导致的</span></span><br><span class="line">error = test_predictions - test_labels</span><br><span class="line">plt.hist(error, bins=<span class="number">25</span>)</span><br><span class="line">plt.xlabel(<span class="string">&quot;Prediction Error [MPG]&quot;</span>)</span><br><span class="line">_ = plt.ylabel(<span class="string">&quot;Count&quot;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>本文介绍了一些处理回归问题的技术。</p><p><strong>均方误差（MSE）</strong>是用于回归问题的常见损失函数（分类问题中使用不同的损失函数）。<br>类似的，用于回归的评估指标与分类不同。 常见的回归指标是平均绝对误差（MAE）。<br>当数字输入数据特征的值存在不同范围时，每个特征应独立缩放到相同范围。<br>如果训练数据不多，一种方法是选择隐藏层较少的小网络，以避免过度拟合。<br>早期停止是一种防止过度拟合的有效技术。</p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 回归问题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python3使用pytesseract进行图片文字识别</title>
      <link href="2021/03/20/Python3%E4%BD%BF%E7%94%A8pytesseract%E8%BF%9B%E8%A1%8C%E5%9B%BE%E7%89%87%E6%96%87%E5%AD%97%E8%AF%86%E5%88%AB/"/>
      <url>2021/03/20/Python3%E4%BD%BF%E7%94%A8pytesseract%E8%BF%9B%E8%A1%8C%E5%9B%BE%E7%89%87%E6%96%87%E5%AD%97%E8%AF%86%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<h2 id="安装Tesseract-OCR软件"><a href="#安装Tesseract-OCR软件" class="headerlink" title="安装Tesseract-OCR软件"></a>安装Tesseract-OCR软件</h2><p>Tesseract-OCR 是一款由HP实验室开发由Google维护的开源OCR（Optical Character Recognition , 光学字符识别）引擎。</p><h3 id="下载Tesseract-OCR-windows"><a href="#下载Tesseract-OCR-windows" class="headerlink" title="下载Tesseract-OCR (windows)"></a>下载Tesseract-OCR (windows)</h3><p> 官方下载地址：<a href="https://digi.bib.uni-mannheim.de/tesseract/tesseract-ocr-setup-4.00.00dev.exe">https://digi.bib.uni-mannheim.de/tesseract/tesseract-ocr-setup-4.00.00dev.exe</a></p><p>  百度网盘：链接: <a href="https://pan.baidu.com/s/1ooItjyzki089pTXNbYQ1hA">https://pan.baidu.com/s/1ooItjyzki089pTXNbYQ1hA</a> 提取码: sq3t </p><h3 id="安装和设置环境变量"><a href="#安装和设置环境变量" class="headerlink" title="安装和设置环境变量"></a>安装和设置环境变量</h3><p>双击安装，点击下一步，默认安装即可。</p><ol><li><p>右键点击此电脑–属性–高级系统设置–环境变量–系统变量–Path</p></li><li><p>添加系统变量</p><p><a href="https://imgchr.com/i/DQKzwV"><img src= "/img/loading.gif" data-lazy-src="https://s3.ax1x.com/2020/11/20/DQKzwV.png" alt="DQKzwV.png"></a></p></li><li><p>添加 tessdata 系统变量</p><p>新建系统变量 ： TESSDATA_PREFIX<br>变量值为 tessdata 文件夹的路径（在Tesseract-OCR的安装目录下）</p><p><a href="https://imgchr.com/i/DQQygH"><img src= "/img/loading.gif" data-lazy-src="https://s3.ax1x.com/2020/11/20/DQQygH.png" alt="DQQygH.png"></a></p></li><li><p>如果识别中文需要下载相应的语言包</p><p>​     中文包百度网盘：链接: <a href="https://pan.baidu.com/s/1xWLQxXw0YdgW2ZPJY-wYWA">https://pan.baidu.com/s/1xWLQxXw0YdgW2ZPJY-wYWA</a> 提取码: jxyh </p><p>下载好的文件放在步骤三的路径下，即 tessdata 文件夹下。</p><h3 id="使用-Tesseract-OCR"><a href="#使用-Tesseract-OCR" class="headerlink" title="使用 Tesseract-OCR"></a>使用 Tesseract-OCR</h3><ol><li><p>验证是否安装成功  cmd命令行模式下，出现版本号即为成功，未成功一般原因是环境变量设置有问题</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tesseract --version</span><br></pre></td></tr></table></figure></li><li><p>使用命令来识别图片, 查看输出文件中识别内容</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tesseract 图片路径 输出文件</span><br></pre></td></tr></table></figure></li><li><p>经过测试，对于规整的文本等识别效果还可以，手写体或者背景噪音过多识别准确率过低。</p></li></ol></li></ol><h2 id="python代码中使用-pytesseract-图片识别"><a href="#python代码中使用-pytesseract-图片识别" class="headerlink" title="python代码中使用 pytesseract 图片识别"></a>python代码中使用 pytesseract 图片识别</h2><p>需要用到库，所以需要导入相关依赖。<a href="https://pypi.python.org/pypi/pytesseract">官方文档</a></p><h3 id="安装相关依赖-pillow和pytesseract"><a href="#安装相关依赖-pillow和pytesseract" class="headerlink" title="安装相关依赖 pillow和pytesseract"></a>安装相关依赖 pillow和pytesseract</h3><p>也可在PyCharm中直接导包（alt + enter）</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pip install pytesseract</span><br><span class="line">pip install pillow</span><br></pre></td></tr></table></figure><h3 id="编写代码测试"><a href="#编写代码测试" class="headerlink" title="编写代码测试"></a>编写代码测试</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pytesseract</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"></span><br><span class="line">image = Image.<span class="built_in">open</span>(<span class="string">&quot;code.png&quot;</span>)</span><br><span class="line">txt = pytesseract.image_to_string(image, lang=<span class="string">&quot;chi_sim&quot;</span>)</span><br><span class="line">print(txt)</span><br></pre></td></tr></table></figure><h3 id="出现错误，一般也是系统变量配置问题"><a href="#出现错误，一般也是系统变量配置问题" class="headerlink" title="出现错误，一般也是系统变量配置问题"></a>出现错误，一般也是系统变量配置问题</h3><p> 方法一：<a href="#%E5%AE%89%E8%A3%85%E5%92%8C%E8%AE%BE%E7%BD%AE%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F">重新配置环境变量 </a></p><p> 方法二： 代码中指定环境变量参数</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pytesseract</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"></span><br><span class="line">pytesseract.pytesseract.tesseract_cmd = <span class="string">&#x27;C:/Program Files (x86)/Tesseract-OCR/tesseract.exe&#x27;</span></span><br><span class="line">tessdata_dir_config = <span class="string">&#x27;--tessdata-dir &quot;C:/Program Files (x86)/Tesseract-OCR/tessdata&quot;&#x27;</span></span><br><span class="line"></span><br><span class="line">image = Image.<span class="built_in">open</span>(<span class="string">&quot;0.jpg&quot;</span>)</span><br><span class="line">txt = pytesseract.image_to_string(image, config=tessdata_dir_config, lang=<span class="string">&quot;chi_sim&quot;</span>)</span><br><span class="line">print(txt)</span><br></pre></td></tr></table></figure><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>除非图片非常清晰的分离的前景和背景才能被Tesseract很好的识别出结果。</p><p>在有”噪点”的图片情况，需要获取更好的，更精确的训练模型去适应这种特别的情况。</p><p>对于具有高分辨率输入的情况，其中前景文本被干净地从背景中分割的图片，Tesseract 是最适合的。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://zhuanlan.zhihu.com/p/36397839">使用Tesseract-OCR进行图像中的文字识别</a></p>]]></content>
      
      
      <categories>
          
          <category> 图像识别 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ocr </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>matplotlib和pandas实现数据可视化</title>
      <link href="2021/03/15/matplotlib%E5%92%8Cpandas%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
      <url>2021/03/15/matplotlib%E5%92%8Cpandas%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<p>数据可视化可以让我们很直观的发现数据中隐藏的规律，察觉到变量之间的互动关系，可以帮助我们更好的给他人解释现象，做到一图胜千文的说明效果。</p><p><strong>常见的数据可视化库有：</strong></p><ol><li>  matplotlib 是最常见的2维库，可以算作可视化的必备技能库，由于matplotlib是比较底层的库，api很多，代码学起来不太容易。</li><li> seaborn 是建构于matplotlib基础上，能满足绝大多数可视化需求。更特殊的需求还是需要学习matplotlib。</li><li>pyecharts 上面的两个库都是静态的可视化库，而pyecharts有很好的web兼容性，可以做到可视化的动态效果。</li></ol><p>但是在数据科学中，几乎都离不开<strong>pandas数据分析库</strong>，而pandas可以做：</p><ul><li>数据采集：如何批量采集网页表格数据？</li><li>数据读取：pd.read_csv/pd.read_excel</li><li>数据清洗（预处理）：理解pandas中的apply和map的作用和异同</li><li>可视化，兼容matplotlib语法(今天重点) </li></ul><p>londonweather.csv  链接: <a href="https://pan.baidu.com/s/1yZrsWG_-RytDAwIJMs3OtA">https://pan.baidu.com/s/1yZrsWG_-RytDAwIJMs3OtA</a> 提取码: wn54 </p><p>london2018.xlsx  链接: <a href="https://pan.baidu.com/s/1Jfb082DTQb1htPTp3Dl9pg">https://pan.baidu.com/s/1Jfb082DTQb1htPTp3Dl9pg</a> 提取码: ga3c </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">df = pd.read_excel(<span class="string">&#x27;london2018.xlsx&#x27;</span>)</span><br><span class="line">print(df)</span><br><span class="line"></span><br><span class="line"><span class="comment"># plot最简单的图 Month作为横坐标 Tmax作为纵坐标</span></span><br><span class="line"><span class="comment"># 横坐标轴参数x传入的是df中的列名Month 纵坐标轴参数y传入的是df中的列名Tmax</span></span><br><span class="line">df.plot(x=<span class="string">&#x27;Month&#x27;</span>, y=<span class="string">&#x27;Tmax&#x27;</span>)</span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">上面的图就是折线图，折线图语法有三种</span></span><br><span class="line"><span class="string">    df.plot(x=&#x27;Month&#x27;, y=&#x27;Tmax&#x27;)</span></span><br><span class="line"><span class="string">    df.plot(x=&#x27;Month&#x27;, y=&#x27;Tmax&#x27;, kind=&#x27;line&#x27;)</span></span><br><span class="line"><span class="string">    df.plot.line(x=&#x27;Month&#x27;, y=&#x27;Tmax&#x27;)</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># grid绘制格线</span></span><br><span class="line">df.plot(x=<span class="string">&#x27;Month&#x27;</span>, y=<span class="string">&#x27;Tmax&#x27;</span>, kind=<span class="string">&#x27;line&#x27;</span>, grid=<span class="string">&#x27;True&#x27;</span>)</span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 多个y值  上面的折线图中只有一条线， 如何将多个y绘制到一个图中，比如Tmax， Tmin</span></span><br><span class="line">df.plot(x=<span class="string">&#x27;Month&#x27;</span>, y=[<span class="string">&#x27;Tmax&#x27;</span>, <span class="string">&#x27;Tmin&#x27;</span>])</span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 条形图</span></span><br><span class="line">df.plot(x=<span class="string">&#x27;Month&#x27;</span>, y=<span class="string">&#x27;Rain&#x27;</span>, kind=<span class="string">&#x27;bar&#x27;</span>)</span><br><span class="line"><span class="comment"># 或者  df.plot.bar(x=&#x27;Month&#x27;, y=&#x27;Rain&#x27;)</span></span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 水平条形图 将kind中bar替换为barh</span></span><br><span class="line">df.plot(x=<span class="string">&#x27;Month&#x27;</span>, y=<span class="string">&#x27;Rain&#x27;</span>, kind=<span class="string">&#x27;barh&#x27;</span>)</span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 多个变量的条形图</span></span><br><span class="line">df.plot(x=<span class="string">&#x27;Month&#x27;</span>, y=[<span class="string">&#x27;Tmax&#x27;</span>, <span class="string">&#x27;Tmin&#x27;</span>], kind=<span class="string">&#x27;bar&#x27;</span>)</span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 散点图</span></span><br><span class="line">df.plot(kind=<span class="string">&#x27;scatter&#x27;</span>, x=<span class="string">&#x27;Month&#x27;</span>, y=<span class="string">&#x27;Sun&#x27;</span>)</span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 饼图</span></span><br><span class="line">df.plot(kind=<span class="string">&#x27;pie&#x27;</span>, y=<span class="string">&#x27;Sun&#x27;</span>)</span><br><span class="line">plt.show()</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">上面的饼图绘制有两个小问题：</span></span><br><span class="line"><span class="string">    legend图例不应该显示</span></span><br><span class="line"><span class="string">    月份的显示用数字不太正规</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">df.index = [<span class="string">&#x27;Jan&#x27;</span>, <span class="string">&#x27;Feb&#x27;</span>, <span class="string">&#x27;Mar&#x27;</span>, <span class="string">&#x27;Apr&#x27;</span>, <span class="string">&#x27;May&#x27;</span>, <span class="string">&#x27;Jun&#x27;</span>, <span class="string">&#x27;Jul&#x27;</span>, <span class="string">&#x27;Aug&#x27;</span>, <span class="string">&#x27;Sep&#x27;</span>, <span class="string">&#x27;Oct&#x27;</span>, <span class="string">&#x27;Nov&#x27;</span>, <span class="string">&#x27;Dec&#x27;</span>]</span><br><span class="line">df.plot(kind=<span class="string">&#x27;pie&#x27;</span>, y=<span class="string">&#x27;Sun&#x27;</span>, legend=<span class="literal">False</span>)</span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 更多数据进行操作</span></span><br><span class="line">df2 = pd.read_csv(<span class="string">&#x27;londonweather.csv&#x27;</span>)</span><br><span class="line">print(df.head())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 共748条记录，62年的记录</span></span><br><span class="line">print(df2.Rain.describe())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 箱型图</span></span><br><span class="line">df2.plot.box(y=<span class="string">&#x27;Rain&#x27;</span>)</span><br><span class="line"><span class="comment"># df2.plot(y=&#x27;Rain&#x27;, kind=&#x27;box&#x27;)</span></span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 直方图</span></span><br><span class="line">df2.plot(y=<span class="string">&#x27;Rain&#x27;</span>, kind=<span class="string">&#x27;hist&#x27;</span>)</span><br><span class="line"><span class="comment"># df2.plot.hist(y=&#x27;Rain&#x27;)</span></span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 纵坐标的刻度可以通过bins来设置</span></span><br><span class="line">df2.plot(y=<span class="string">&#x27;Rain&#x27;</span>, kind=<span class="string">&#x27;hist&#x27;</span>, bins=[<span class="number">0</span>, <span class="number">25</span>, <span class="number">50</span>, <span class="number">75</span>, <span class="number">100</span>, <span class="number">125</span>, <span class="number">150</span>, <span class="number">175</span>, <span class="number">200</span>])</span><br><span class="line"><span class="comment"># df2.plot.hist(y=&#x27;Rain&#x27;)</span></span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 多图并存</span></span><br><span class="line">df.plot(kind=<span class="string">&#x27;line&#x27;</span>,</span><br><span class="line">        y=[<span class="string">&#x27;Tmax&#x27;</span>, <span class="string">&#x27;Tmin&#x27;</span>, <span class="string">&#x27;Rain&#x27;</span>, <span class="string">&#x27;Sun&#x27;</span>],  <span class="comment"># 4个变量可视化</span></span><br><span class="line">        subplots=<span class="literal">True</span>,  <span class="comment"># 多子图并存</span></span><br><span class="line">        layout=(<span class="number">2</span>, <span class="number">2</span>),  <span class="comment"># 子图排列两行两列</span></span><br><span class="line">        figsize=(<span class="number">20</span>, <span class="number">10</span>))  <span class="comment"># 图布的尺寸</span></span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line">df.plot(kind=<span class="string">&#x27;bar&#x27;</span>,</span><br><span class="line">        y=[<span class="string">&#x27;Tmax&#x27;</span>, <span class="string">&#x27;Tmin&#x27;</span>, <span class="string">&#x27;Rain&#x27;</span>, <span class="string">&#x27;Sun&#x27;</span>],  <span class="comment"># 4个变量可视化</span></span><br><span class="line">        subplots=<span class="literal">True</span>,  <span class="comment"># 多子图并存</span></span><br><span class="line">        layout=(<span class="number">2</span>, <span class="number">2</span>),  <span class="comment"># 子图排列2行2列</span></span><br><span class="line">        figsize=(<span class="number">20</span>, <span class="number">10</span>))  <span class="comment"># 图布的尺寸</span></span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加标题</span></span><br><span class="line"></span><br><span class="line">df.plot(kind=<span class="string">&#x27;bar&#x27;</span>,</span><br><span class="line">        y=[<span class="string">&#x27;Tmax&#x27;</span>, <span class="string">&#x27;Tmin&#x27;</span>],  <span class="comment"># 2个变量可视化</span></span><br><span class="line">        subplots=<span class="literal">True</span>,  <span class="comment"># 多子图并存</span></span><br><span class="line">        layout=(<span class="number">1</span>, <span class="number">2</span>),  <span class="comment"># 子图排列1行2列</span></span><br><span class="line">        figsize=(<span class="number">20</span>, <span class="number">5</span>),  <span class="comment"># 图布的尺寸</span></span><br><span class="line">        title=<span class="string">&#x27;The Weather of London&#x27;</span>)  <span class="comment"># 标题</span></span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 存储为图片</span></span><br><span class="line">df.plot(kind=<span class="string">&#x27;pie&#x27;</span>, y=<span class="string">&#x27;Rain&#x27;</span>, legend=<span class="literal">False</span>, figsize=(<span class="number">10</span>, <span class="number">5</span>), title=<span class="string">&#x27;Pie of Weather inLondon&#x27;</span>)</span><br><span class="line">plt.savefig(<span class="string">&#x27;pie.png&#x27;</span>)</span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string"> df.plot更多参数</span></span><br><span class="line"><span class="string">    df.plot(x, y, kind, figsize, title, grid, legend, style)</span></span><br><span class="line"><span class="string">    - x 只有dataframe对象时，x可用。横坐标</span></span><br><span class="line"><span class="string">    - y 同上，纵坐标变量</span></span><br><span class="line"><span class="string">    - kind 可视化图的种类，如line,hist, bar, barh, pie, kde, scatter</span></span><br><span class="line"><span class="string">    - figsize 画布尺寸</span></span><br><span class="line"><span class="string">    - title 标题</span></span><br><span class="line"><span class="string">    - grid 是否显示格子线条</span></span><br><span class="line"><span class="string">    - legend  是否显示图例</span></span><br><span class="line"><span class="string">    - style 图的风格</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看plot参数可以使用help</span></span><br><span class="line"><span class="comment"># help(pd.DataFrame.plot)</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据可视化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1021 个位数统计 (15分) PAT</title>
      <link href="2021/01/13/1021%20%E4%B8%AA%E4%BD%8D%E6%95%B0%E7%BB%9F%E8%AE%A1%20(15%E5%88%86)%20PAT/"/>
      <url>2021/01/13/1021%20%E4%B8%AA%E4%BD%8D%E6%95%B0%E7%BB%9F%E8%AE%A1%20(15%E5%88%86)%20PAT/</url>
      
        <content type="html"><![CDATA[<h2 id="1021-个位数统计-15分"><a href="#1021-个位数统计-15分" class="headerlink" title="1021 个位数统计 (15分)"></a>1021 个位数统计 (15分)</h2><p>给定一个 k 位整数$N = d_{k-1}<em>10^{k-1} + … + d_1</em>10^1 + d_0(0&lt;=d_i&lt;=9, i=0,…,k-1, d_{k-1}&gt;0)$,请编写程序统计每种不同的个位数字出现的次数。例如：给定 N=100311，则有 2 个 0，3 个 1，和 1 个 3。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>每个输入包含 1 个测试用例，即一个不超过 1000 位的正整数 N。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>对 N 中每一种不同的个位数字，以 D:M 的格式在一行中输出该位数字 D 及其在 N 中出现的次数 M。要求按 D 的升序输出。</p><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><blockquote><p>100311</p></blockquote><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><blockquote><p>0:2<br>1:3<br>3:1</p></blockquote><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h3><p>题意好懂，求一个数字中各个数字出现的次数，按照格式输出。</p><p>不超过1000位的正整数，本来考虑的是用Long类型处理，将各位通过除法取余等运算求出，后发现不太好写代码。</p><p>巧妙<strong>利用二维数组来存储每个数字出现的次数</strong>，我想也可以用List,HashMap等数据结构。将读入的字符串转为数组逐位处理即可。</p><h3 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h3><p><strong>具体逻辑看注释</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//读取输入</span></span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="comment">//按照字符串读入</span></span><br><span class="line">        String number = sc.nextLine();</span><br><span class="line">        <span class="comment">//二维数组存储每个数字出现的次数</span></span><br><span class="line">        <span class="keyword">int</span>[][] array = &#123;&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;&#125;;</span><br><span class="line">        <span class="comment">//转为char类型的数据</span></span><br><span class="line">        <span class="keyword">char</span>[] chars = number.toCharArray();</span><br><span class="line">        <span class="comment">//遍历给数字出现次数赋值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : chars) &#123;</span><br><span class="line">            array[<span class="number">0</span>][c - <span class="string">&#x27;0&#x27;</span>] += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//按照格式要求输出结果</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">0</span>;x &lt; array[<span class="number">0</span>].length;x++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(array[<span class="number">0</span>][x] != <span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println( x+<span class="string">&quot;:&quot;</span> + array[<span class="number">0</span>][x]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> PAT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1028 人口普查 (20分) PAT Java代码实现 -运行超时（牛客AC）</title>
      <link href="2021/01/11/1028%20%E4%BA%BA%E5%8F%A3%E6%99%AE%E6%9F%A5%20(20%E5%88%86)%20PAT%20Java%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%20-%E8%BF%90%E8%A1%8C%E8%B6%85%E6%97%B6%EF%BC%88%E7%89%9B%E5%AE%A2AC%EF%BC%89/"/>
      <url>2021/01/11/1028%20%E4%BA%BA%E5%8F%A3%E6%99%AE%E6%9F%A5%20(20%E5%88%86)%20PAT%20Java%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%20-%E8%BF%90%E8%A1%8C%E8%B6%85%E6%97%B6%EF%BC%88%E7%89%9B%E5%AE%A2AC%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h3 id="1028-人口普查-20分"><a href="#1028-人口普查-20分" class="headerlink" title="1028 人口普查 (20分)"></a>1028 人口普查 (20分)</h3><p>某城镇进行人口普查，得到了全体居民的生日。现请你写个程序，找出镇上最年长和最年轻的人。</p><p>这里确保每个输入的日期都是合法的，但不一定是合理的——假设已知镇上没有超过 200 岁的老人，而今天是 2014 年 9 月 6 日，所以超过 200 岁的生日和未出生的生日都是不合理的，应该被过滤掉。</p><h2 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h2><p>输入在第一行给出正整数 N，取值在(0,10^5 ]；随后 N 行，每行给出 1 个人的姓名（由不超过 5 个英文字母组成的字符串）、以及按 yyyy/mm/dd（即年/月/日）格式给出的生日。题目保证最年长和最年轻的人没有并列。</p><h2 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h2><p>在一行中顺序输出有效生日的个数、最年长人和最年轻人的姓名，其间以空格分隔。</p><h2 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h2><blockquote><p>5<br>John 2001/05/12<br>Tom 1814/09/06<br>Ann 2121/01/30<br>James 1814/09/05<br>Steve 1967/11/20</p></blockquote><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><blockquote><p>3 Tom John</p></blockquote><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h3><p>此题题意也很容易理解，只需找出在时间段[1814/09/06-2014/09/06]之间的最晚和最早时间。<br>如何判断时间段是否符合，以及求最大和最小。我刚开始第一想法就是<strong>用TreeMap的有序性来排序</strong>，后测试发现最后一个测试点运行超时。<strong>见下侧代码实现一</strong>。<br>后来考虑可能是TreeMap消耗资源过多，占用内存过大，考虑不存储所有数据，只存储最大最小，<strong>动态比较给最大最小变量赋值</strong>。发现还是最后一个测试点运行超时。<strong>见下侧代码实现二</strong>。<br>又考虑String的compareTo()方法效率低，<strong>将其转换为int 类型直接比较</strong>。还是最后一个测试点运行超时。 <strong>见下侧代码实现三</strong>。</p><p><strong>坑一：</strong> 刚开始是以为考察重点是求200年前具体年月日，后通过观察测试用例发现不是这样。<br><strong>坑二：</strong> 若所有数据都不符合规则，则应只输出 0<br><strong>坑三：</strong> 若数据只有一条，年纪最大和最小都应输出同一个人名，即打印两个相同的名字。</p><p><strong>最后一个测试点未过，运行超时，得分16。试了好几种方法还是运行超时，心态不好了。求大佬解答。</strong></p><h3 id="代码实现一："><a href="#代码实现一：" class="headerlink" title="代码实现一："></a>代码实现一：</h3><p><strong>利用TreeMap的有序性来排序</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">import</span> java.util.TreeMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//读取输入</span></span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="comment">//要输入的数量  10的5次方属于int范围</span></span><br><span class="line">        <span class="keyword">int</span> number = sc.nextInt();</span><br><span class="line">        <span class="comment">//nextLine()返回类型为String(字符串对象)，返回一整行。会读取回车换行符。</span></span><br><span class="line">        <span class="comment">//此处是为了读取回车换行符</span></span><br><span class="line">        sc.nextLine();</span><br><span class="line">        <span class="comment">//最大日期字符串，超过这个日期为非法</span></span><br><span class="line">        String max = <span class="string">&quot;2014/09/06&quot;</span>;</span><br><span class="line">        <span class="comment">//最小日期字符串，小于这个日期为非法</span></span><br><span class="line">        String min = <span class="string">&quot;1814/09/06&quot;</span>;</span><br><span class="line">        <span class="comment">//TreeMap 是一个有序的key-value集合，通过红黑树实现的。</span></span><br><span class="line">        Map&lt;String,String&gt; map = <span class="keyword">new</span> TreeMap&lt;&gt;();</span><br><span class="line">        <span class="comment">//循环读取输入的数据</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; number; x++)&#123;</span><br><span class="line">            <span class="comment">//读取姓名和日期</span></span><br><span class="line">            String[] data = sc.nextLine().split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">            <span class="comment">//将符合条件的数据放进map中排序</span></span><br><span class="line">            <span class="keyword">if</span>(data[<span class="number">1</span>].compareTo(min) &gt;= <span class="number">0</span> &amp;&amp; data[<span class="number">1</span>].compareTo(max) &lt;= <span class="number">0</span> )&#123;</span><br><span class="line">                <span class="comment">// 利用其有序特性，将日期作为key排序，人名作为value</span></span><br><span class="line">                map.put(data[<span class="number">1</span>],data[<span class="number">0</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//所有数据都无效 仅仅打印0且不带空格和换行</span></span><br><span class="line">        <span class="keyword">if</span>(map.size() == <span class="number">0</span>)&#123;</span><br><span class="line">            System.out.print(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//合格数据的数量为map的大小</span></span><br><span class="line">            System.out.print(map.size() + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            <span class="comment">//map中第一个为最年长 最后一个为最年轻</span></span><br><span class="line">            Object[] values = map.values().toArray();</span><br><span class="line">            System.out.print(values[<span class="number">0</span>] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            System.out.print(values[values.length-<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="代码实现二："><a href="#代码实现二：" class="headerlink" title="代码实现二："></a>代码实现二：</h3><p><strong>动态比较给最大最小变量赋值</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">import</span> java.util.TreeMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//读取输入</span></span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="comment">//要输入的数量  10的5次方属于int范围</span></span><br><span class="line">        <span class="keyword">int</span> number = sc.nextInt();</span><br><span class="line">        <span class="comment">//nextLine()返回类型为String(字符串对象)，返回一整行。会读取回车换行符。</span></span><br><span class="line">        <span class="comment">//此处是为了读取回车换行符</span></span><br><span class="line">        sc.nextLine();</span><br><span class="line">        <span class="comment">//最大日期字符串，超过这个日期为非法</span></span><br><span class="line">        String max = <span class="string">&quot;1814/09/06&quot;</span>;</span><br><span class="line">        <span class="comment">//最小日期字符串，小于这个日期为非法</span></span><br><span class="line">        String min = <span class="string">&quot;2014/09/06&quot;</span>;</span><br><span class="line">        <span class="comment">//计数</span></span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//存储年龄最大和最小的名字</span></span><br><span class="line">        String maxName = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        String minName = <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="comment">//循环读取数据</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; number; x++)&#123;</span><br><span class="line">            <span class="comment">//读取姓名和日期</span></span><br><span class="line">            String[] data = sc.nextLine().split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">            <span class="comment">//将符合条件的数据放进map中排序</span></span><br><span class="line">            <span class="keyword">if</span>(data[<span class="number">1</span>].compareTo(<span class="string">&quot;1814/09/06&quot;</span>) &gt;= <span class="number">0</span> &amp;&amp; data[<span class="number">1</span>].compareTo(<span class="string">&quot;2014/09/06&quot;</span>) &lt;= <span class="number">0</span> )&#123;</span><br><span class="line">                <span class="comment">// 利用其有序特性，将日期作为key排序，人名作为value</span></span><br><span class="line">                count++;     </span><br><span class="line">                <span class="keyword">if</span>(data[<span class="number">1</span>].compareTo(max) &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">                    max = data[<span class="number">1</span>];</span><br><span class="line">                    maxName = data[<span class="number">0</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(data[<span class="number">1</span>].compareTo(min) &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">                    min = data[<span class="number">1</span>];</span><br><span class="line">                    minName = data[<span class="number">0</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//日期最大的为年龄最小的</span></span><br><span class="line">        <span class="keyword">if</span>(count == <span class="number">0</span>)&#123;</span><br><span class="line">            System.out.print(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.print(count + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            System.out.print(minName + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            System.out.print(maxName );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="代码实现三："><a href="#代码实现三：" class="headerlink" title="代码实现三："></a>代码实现三：</h3><p><strong>动态比较给最大最小变量赋值</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//读取输入</span></span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="comment">//要输入的数量  10的5次方属于int范围</span></span><br><span class="line">        <span class="keyword">int</span> number = sc.nextInt();</span><br><span class="line">        <span class="comment">//nextLine()返回类型为String(字符串对象)，返回一整行。会读取回车换行符。</span></span><br><span class="line">        <span class="comment">//此处是为了读取回车换行符</span></span><br><span class="line">        sc.nextLine();</span><br><span class="line">        <span class="comment">//最大日期字符串，超过这个日期为非法</span></span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">18140906</span>;</span><br><span class="line">        <span class="comment">//最小日期字符串，小于这个日期为非法</span></span><br><span class="line">        <span class="keyword">int</span> min = <span class="number">20140906</span>;</span><br><span class="line">        <span class="comment">//计数</span></span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//暂存人名</span></span><br><span class="line">        String maxName = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        String minName = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="comment">//循环读取处理</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; number; x++)&#123;</span><br><span class="line">            <span class="comment">//读取姓名和日期</span></span><br><span class="line">            String[] data = sc.nextLine().split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">            <span class="comment">//转为int类型</span></span><br><span class="line">            <span class="keyword">int</span> date = Integer.parseInt(data[<span class="number">1</span>].replaceAll(<span class="string">&quot;/&quot;</span>,<span class="string">&quot;&quot;</span>));</span><br><span class="line">            <span class="keyword">if</span>(date &gt;= <span class="number">18140906</span> &amp;&amp; date &lt;= <span class="number">20140906</span>)&#123;</span><br><span class="line">                <span class="comment">//计数</span></span><br><span class="line">                count++;</span><br><span class="line">                <span class="comment">//和最小的值比较</span></span><br><span class="line">                <span class="keyword">if</span>(date &gt;= max)&#123;</span><br><span class="line">                    max = date;</span><br><span class="line">                    maxName = data[<span class="number">0</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//和最大的值比较</span></span><br><span class="line">                <span class="keyword">if</span>(date &lt;= min)&#123;</span><br><span class="line">                    min = date;</span><br><span class="line">                    minName = data[<span class="number">0</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//日期最大的为年龄最小的</span></span><br><span class="line">        <span class="keyword">if</span>(count == <span class="number">0</span>)&#123;</span><br><span class="line">            System.out.print(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.print(count + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            System.out.print(minName + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            System.out.print(maxName );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="最新进度："><a href="#最新进度：" class="headerlink" title="最新进度："></a>最新进度：</h3><p><strong>牛客网相同的代码所有测试点都通过了，在PAT中就不行。</strong><br><strong>暂且这样吧，理解题目的考察点。<br>在这个问题上折腾了快一天了，就不再耗费时间了。</strong></p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200512101229709.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZsdWV0dHk=,size_16,color_FFFFFF,t_70" alt="牛客网AC"><br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200512101343399.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZsdWV0dHk=,size_16,color_FFFFFF,t_70" alt="PAT运行超时"></p>]]></content>
      
      
      
        <tags>
            
            <tag> PAT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1012 数字分类 (20分) PAT</title>
      <link href="2021/01/10/1012%20%E6%95%B0%E5%AD%97%E5%88%86%E7%B1%BB%20(20%E5%88%86)/"/>
      <url>2021/01/10/1012%20%E6%95%B0%E5%AD%97%E5%88%86%E7%B1%BB%20(20%E5%88%86)/</url>
      
        <content type="html"><![CDATA[<h2 id="1012-数字分类-20分"><a href="#1012-数字分类-20分" class="headerlink" title="1012 数字分类 (20分)"></a>1012 数字分类 (20分)</h2><p>给定一系列正整数，请按要求对数字进行分类，并输出以下 5 个数字：</p><p>A1  = 能被 5 整除的数字中所有偶数的和；<br>A2  = 将被 5 除后余 1 的数字按给出顺序进行交错求和，即计算 n1 −n2 +n3 −n4 ⋯；<br>A3  = 被 5 除后余 2 的数字的个数；<br>A4  = 被 5 除后余 3 的数字的平均数，精确到小数点后 1 位；<br>A5  = 被 5 除后余 4 的数字中最大数字。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>每个输入包含 1 个测试用例。每个测试用例先给出一个不超过 1000 的正整数 N，随后给出 N 个不超过 1000 的待分类的正整数。数字间以空格分隔。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>对给定的 N 个正整数，按题目要求计算 A1 ~A5 并在一行中顺序输出。数字间以空格分隔，但行末不得有多余空格。</p><p>若其中某一类数字不存在，则在相应位置输出 N。</p><h3 id="输入样例-1："><a href="#输入样例-1：" class="headerlink" title="输入样例 1："></a>输入样例 1：</h3><blockquote><p>13 1 2 3 4 5 6 7 8 9 10 20 16 18    </p></blockquote><h3 id="输出样例-1："><a href="#输出样例-1：" class="headerlink" title="输出样例 1："></a>输出样例 1：</h3><blockquote><p>30 11 2 9.7 9          </p></blockquote><h3 id="输入样例-2："><a href="#输入样例-2：" class="headerlink" title="输入样例 2："></a>输入样例 2：</h3><blockquote><p>8 1 2 4 5 6 7 9 16         </p><h3 id="输出样例-2："><a href="#输出样例-2：" class="headerlink" title="输出样例 2："></a>输出样例 2：</h3><p>N 11 2 N 9</p></blockquote><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h3><p>题目意思简单易懂，考察点在与输出格式和中间处理过程。此处我取巧用了java8的语法来减少了中间的处理过程。但是内存占用会变大。<br>也可以用数组来存储筛选出的数据，或者一遍遍历直接筛选出这五种情况下的数据。<br>具体逻辑看代码里的注释。</p><h3 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h3><p><strong>Java8语法 stream lambda表达式</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Collectors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//读取输入</span></span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="comment">//读入数字的数量</span></span><br><span class="line">        <span class="keyword">int</span> number = sc.nextInt();</span><br><span class="line">        <span class="comment">//存储读入的所有的数字</span></span><br><span class="line">        List&lt;Integer&gt;  list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">0</span>;x &lt; number; x++)&#123;</span><br><span class="line">            list.add(sc.nextInt());</span><br><span class="line">        &#125;</span><br><span class="line">        sc.close();</span><br><span class="line">        <span class="comment">// 能被 5 整除的数字中的偶数</span></span><br><span class="line">        <span class="keyword">int</span> a1 = <span class="number">0</span>;</span><br><span class="line">        List&lt;Integer&gt; temListA1 = list.stream().filter(item -&gt; item % <span class="number">5</span> == <span class="number">0</span> &amp;&amp; item % <span class="number">2</span> == <span class="number">0</span>).collect(Collectors.toList());</span><br><span class="line">        <span class="comment">//能被 5 整除的数字中所有偶数的和  如果存在才求和</span></span><br><span class="line">        <span class="keyword">if</span>(temListA1.size() &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            a1 = list.stream().filter(item -&gt; item % <span class="number">5</span> == <span class="number">0</span> &amp;&amp; item % <span class="number">2</span> == <span class="number">0</span>).mapToInt(item -&gt; item).sum();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将被 5 除后余 1 的数字</span></span><br><span class="line">        List&lt;Integer&gt; tempListA2 = list.stream().filter(item -&gt; item % <span class="number">5</span> == <span class="number">1</span>).collect(Collectors.toList());</span><br><span class="line">        <span class="keyword">int</span> a2 = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//控制交错求和 </span></span><br><span class="line">        <span class="keyword">int</span> flag = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//存在数字则交替求和</span></span><br><span class="line">        <span class="keyword">if</span>(tempListA2.size() &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> x : tempListA2)&#123;</span><br><span class="line">                a2 += x*flag;</span><br><span class="line">                flag = -flag;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 被 5 除后余 2 的数字的个数 a3为零说明不存在 则输出 N</span></span><br><span class="line">        <span class="keyword">int</span> a3 = (<span class="keyword">int</span>) list.stream().filter(item -&gt; item % <span class="number">5</span> == <span class="number">2</span>).count();        </span><br><span class="line">        </span><br><span class="line">        <span class="comment">//被 5 除后余 3 的数字</span></span><br><span class="line">        List&lt;Integer&gt; tempListA4 = list.stream().filter(item -&gt; item % <span class="number">5</span> == <span class="number">3</span>).collect(Collectors.toList());</span><br><span class="line">        <span class="comment">//求和</span></span><br><span class="line">        <span class="keyword">int</span> sum = tempListA4.stream().mapToInt(item -&gt; item).sum();</span><br><span class="line">        <span class="keyword">double</span> a4 = <span class="number">0.0</span>;</span><br><span class="line">        <span class="comment">//求平均数</span></span><br><span class="line">        <span class="keyword">if</span>(tempListA4.size() &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            a4 = (<span class="keyword">double</span>)sum / tempListA4.size();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//被 5 除后余 4 的数字</span></span><br><span class="line">        List&lt;Integer&gt; tempListA5 = list.stream().filter(item -&gt; item % <span class="number">5</span> == <span class="number">4</span>).collect(Collectors.toList());</span><br><span class="line">        <span class="keyword">int</span> a5 = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//遍历找最大数字</span></span><br><span class="line">        <span class="keyword">if</span>(tempListA5.size() &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> x : tempListA5)&#123;</span><br><span class="line">                a5 = Math.max(x, a5);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//若数字不存在则输出N  三目运算符来控制输出</span></span><br><span class="line">        System.out.print((temListA1.size() == <span class="number">0</span> ? <span class="string">&quot;N&quot;</span> : a1) + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        System.out.print((tempListA2.size() == <span class="number">0</span> ? <span class="string">&quot;N&quot;</span> : a2) + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        System.out.print((a3 == <span class="number">0</span> ? <span class="string">&quot;N&quot;</span> : a3) + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        <span class="comment">//精确到小数点后 1 位</span></span><br><span class="line">        System.out.print((tempListA4.size() == <span class="number">0</span>? <span class="string">&quot;N&quot;</span> : String.format(<span class="string">&quot;%.1f&quot;</span>,a4)) + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        System.out.print(tempListA5.size()  == <span class="number">0</span>? <span class="string">&quot;N&quot;</span> : a5);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> PAT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1011 A+B 和 C (15分)</title>
      <link href="2021/01/09/1011%20A+B%20%E5%92%8C%20C%20(15%E5%88%86)/"/>
      <url>2021/01/09/1011%20A+B%20%E5%92%8C%20C%20(15%E5%88%86)/</url>
      
        <content type="html"><![CDATA[<h2 id="1011-A-B-和-C-15分"><a href="#1011-A-B-和-C-15分" class="headerlink" title="1011 A+B 和 C (15分)"></a>1011 A+B 和 C (15分)</h2><p>给定区间 [−2​^31​​， 2^​31​​ ] 内的 3 个整数 A、B 和 C，请判断 A+B 是否大于 C。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入第 1 行给出正整数 T (≤10)，是测试用例的个数。随后给出 T 组测试用例，每组占一行，顺序给出 A、B 和 C。整数间以空格分隔。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>对每组测试用例，在一行中输出 Case #X: true 如果 A+B&gt;C，否则输出 Case #X: false，其中 X 是测试用例的编号（从 1 开始）。</p><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><blockquote><p>4<br>1 2 3<br>2 3 4<br>2147483647 0 2147483646<br>0 -2147483648 -2147483647</p></blockquote><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><blockquote><p>Case #1: false<br>Case #2: true<br>Case #3: true<br>Case #4: false</p></blockquote><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h3><p>此题题意很容易理解，用数学式子判断并输入特定格式结果。<br>我第一眼看到的是<strong>这三个整数的取值范围</strong>，所以要注意数据类型的选择，此处选取long类型。<br>需要注意的是选择何种读入数据方式，合理选择数据类型，以及精简代码。</p><p><strong>看下侧代码更好地理解为何选取long</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//输出Integer的最大值</span></span><br><span class="line">System.out.println(<span class="string">&quot;Integer.MAX_VALUE: &quot;</span>+Integer.MAX_VALUE);</span><br><span class="line"><span class="comment">//输出Integer的最小值</span></span><br><span class="line">System.out.println(<span class="string">&quot;Integer.MIN_VALUE: &quot;</span>+Integer.MIN_VALUE);</span><br><span class="line"><span class="comment">//输出 2^31 -1 的大小  2左移30位，相当于2的31次方</span></span><br><span class="line">System.out.println(<span class="string">&quot;2^31 - 1 : &quot;</span>+ String.valueOf((<span class="number">2</span> &lt;&lt; <span class="number">30</span> )-<span class="number">1</span>));</span><br></pre></td></tr></table></figure><p><strong>输出结果</strong></p><blockquote><p>Integer.MAX_VALUE:  2147483647<br>Integer.MIN_VALUE:  -2147483648<br>2^31 - 1 :  2147483647</p></blockquote><p><strong>由代码可知2的31次方为2147483648，超出Integer的最大取值范围，故选用long。</strong></p><h3 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h3><p><strong>具体细节看代码注释</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">//读取输入</span></span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span> number = sc.nextInt();</span><br><span class="line">        <span class="comment">//循环读入每一行的数据</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">1</span>; x &lt;= number; x++)&#123;</span><br><span class="line">            <span class="comment">//读入接下来的三个数 注意使用Long类型</span></span><br><span class="line">            <span class="keyword">long</span> a = sc.nextLong();</span><br><span class="line">            <span class="keyword">long</span> b = sc.nextLong();</span><br><span class="line">            <span class="keyword">long</span> c = sc.nextLong();</span><br><span class="line">            <span class="comment">//拼接打印要输出的结果  此处 true or false 直接判断结果即可，刚开始用的三目运算符发现过于臃肿</span></span><br><span class="line">            System.out.println(<span class="string">&quot;Case #&quot;</span>+ x +<span class="string">&quot;: &quot;</span>+(a + b &gt; c));</span><br><span class="line">        &#125;</span><br><span class="line">        sc.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> PAT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7-20 简单计算器（20 分） PAT</title>
      <link href="2021/01/08/7-20%20%E7%AE%80%E5%8D%95%E8%AE%A1%E7%AE%97%E5%99%A8%EF%BC%8820%20%E5%88%86%EF%BC%89%20PAT/"/>
      <url>2021/01/08/7-20%20%E7%AE%80%E5%8D%95%E8%AE%A1%E7%AE%97%E5%99%A8%EF%BC%8820%20%E5%88%86%EF%BC%89%20PAT/</url>
      
        <content type="html"><![CDATA[<h2 id="7-20-简单计算器（20-分）"><a href="#7-20-简单计算器（20-分）" class="headerlink" title="7-20 简单计算器（20 分）"></a>7-20 简单计算器（20 分）</h2><p>模拟简单运算器的工作。假设计算器只能进行加减乘除运算，运算数和结果都是整数，四种运算符的优先级相同，按从左到右的顺序计算。</p><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式:"></a>输入格式:</h3><p>输入在一行中给出一个四则运算算式，没有空格，且至少有一个操作数。遇等号”=”说明输入结束。</p><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式:"></a>输出格式:</h3><p>在一行中输出算式的运算结果，或者如果除法分母为0或有非法运算符，则输出错误信息“ERROR”。</p><h3 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例:"></a>输入样例:</h3><blockquote><p>1+2*10-10/2=</p></blockquote><h3 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例:"></a>输出样例:</h3><blockquote><p> 10</p></blockquote><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a,b,c;</span><br><span class="line"><span class="keyword">char</span> n;   </span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a);</span><br><span class="line"><span class="keyword">while</span>((n=getchar())!=<span class="string">&#x27;=&#x27;</span>)&#123;</span><br><span class="line"> <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;b);</span><br><span class="line">  <span class="keyword">if</span>(n==<span class="string">&#x27;/&#x27;</span> &amp;&amp; b==<span class="number">0</span> ||(n!=<span class="string">&#x27;+&#x27;</span> &amp;&amp; n!=<span class="string">&#x27;-&#x27;</span> &amp;&amp; n!=<span class="string">&#x27;*&#x27;</span> &amp;&amp; n!=<span class="string">&#x27;/&#x27;</span>))&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;ERROR\n&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>; <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line"> <span class="keyword">switch</span> (n)&#123;</span><br><span class="line">     <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:c=a+b;  <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:c=a-b;  <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:c=a*b;  <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>:c=a/b;  <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:<span class="built_in">printf</span>(<span class="string">&quot;ERROR\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">   a=c;</span><br><span class="line">    &#125; </span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,a); </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> PAT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>查验身份证 (15分) PAT</title>
      <link href="2021/01/07/1031%20%E6%9F%A5%E9%AA%8C%E8%BA%AB%E4%BB%BD%E8%AF%81%20(15%E5%88%86)/"/>
      <url>2021/01/07/1031%20%E6%9F%A5%E9%AA%8C%E8%BA%AB%E4%BB%BD%E8%AF%81%20(15%E5%88%86)/</url>
      
        <content type="html"><![CDATA[<h2 id="1031-查验身份证-15分"><a href="#1031-查验身份证-15分" class="headerlink" title="1031 查验身份证 (15分)"></a>1031 查验身份证 (15分)</h2><p>一个合法的身份证号码由17位地区、日期编号和顺序编号加1位校验码组成。校验码的计算规则如下：</p><p>首先对前17位数字加权求和，权重分配为：{7，9，10，5，8，4，2，1，6，3，7，9，10，5，8，4，2}；然后将计算的和对11取模得到值Z；最后按照以下关系对应Z值与校验码M的值：</p><blockquote><p>Z：0 1 2 3 4 5 6 7 8 9 10<br>M：1 0 X 9 8 7 6 5 4 3 2</p></blockquote><p>现在给定一些身份证号码，请你验证校验码的有效性，并输出有问题的号码。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入第一行给出正整数N（≤100）是输入的身份证号码的个数。随后N行，每行给出1个18位身份证号码。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>按照输入的顺序每行输出1个有问题的身份证号码。这里并不检验前17位是否合理，只检查前17位是否全为数字且最后1位校验码计算准确。如果所有号码都正常，则输出All passed。</p><h4 id="输入样例1："><a href="#输入样例1：" class="headerlink" title="输入样例1："></a>输入样例1：</h4><blockquote><p>4<br>320124198808240056<br>12010X198901011234<br>110108196711301866<br>37070419881216001X</p></blockquote><h4 id="输出样例1："><a href="#输出样例1：" class="headerlink" title="输出样例1："></a>输出样例1：</h4><blockquote><p>12010X198901011234<br>110108196711301866<br>37070419881216001X</p></blockquote><h4 id="输入样例2："><a href="#输入样例2：" class="headerlink" title="输入样例2："></a>输入样例2：</h4><blockquote><p>2<br>320124198808240056<br>110108196711301862</p></blockquote><h4 id="输出样例2："><a href="#输出样例2：" class="headerlink" title="输出样例2："></a>输出样例2：</h4><blockquote><p>All passed</p></blockquote><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h3><p>刚开始读此题目没怎么读懂，仔细多读了几遍才逐渐明白题意。</p><p>按照题意对前17位进行是否包含字符校验，以及对前17位进行加权运算求和模11取余数。余数的范围0-10，用校验码m来进行校验。只需要校验最后1位是否正确。</p><p>另外需要全局变量来标识: 是否所有的输入行都经过了校验，以便于最终输出All passed。</p><p>具体逻辑看代码注释。</p><h3 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//权重</span></span><br><span class="line">        <span class="keyword">int</span>[] weights = &#123;<span class="number">7</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">4</span>, <span class="number">2</span>&#125;;</span><br><span class="line">        <span class="comment">//校验码m  因为其中含有字符 X , 定义成char类型数组</span></span><br><span class="line">        <span class="keyword">char</span>[] checkCodeM = &#123;<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;X&#x27;</span>, <span class="string">&#x27;9&#x27;</span>, <span class="string">&#x27;8&#x27;</span>, <span class="string">&#x27;7&#x27;</span>, <span class="string">&#x27;6&#x27;</span>, <span class="string">&#x27;5&#x27;</span>, <span class="string">&#x27;4&#x27;</span>, <span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;2&#x27;</span>&#125;;</span><br><span class="line">        <span class="comment">//标识 是否存在不符合的身份证号码</span></span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">//y标识由于前17位存在字符跳出循环时的下标</span></span><br><span class="line">        <span class="keyword">int</span> y = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//先读入要输入的身份证的数量</span></span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span> number = sc.nextInt();</span><br><span class="line">        <span class="comment">//遍历依次读入身份证 进行校验</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; number; x++ )&#123;</span><br><span class="line">            <span class="comment">//保存加权后的和</span></span><br><span class="line">            <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">//读入一行身份证信息</span></span><br><span class="line">            String idCard = sc.next();</span><br><span class="line">            <span class="comment">//因为读入的数据可能包含字符X，转为char数组 加权求和</span></span><br><span class="line">            <span class="keyword">char</span>[] idCardChar = idCard.toCharArray();</span><br><span class="line">            <span class="comment">//要借用下标比对 用最基础的for循环</span></span><br><span class="line">            <span class="keyword">for</span>(y = <span class="number">0</span>; y &lt; idCardChar.length - <span class="number">1</span>; y++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(idCardChar[<span class="number">9</span>] &lt; <span class="string">&#x27;0&#x27;</span> || idCardChar[y] &gt; <span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">                    flag = <span class="keyword">false</span>;</span><br><span class="line">                    System.out.println(idCard);</span><br><span class="line">                    <span class="comment">//直接结束校验此身份证号码 此时只是跳出了此for循环</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="comment">// 对前17位数字加权求和</span></span><br><span class="line">                    sum += (idCardChar[y]  - <span class="string">&#x27;0&#x27;</span>) * weights[y];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//此时说明前17位都进行了加权计算</span></span><br><span class="line">            <span class="keyword">if</span>(y == idCardChar.length-<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="comment">//模11 余数(也就是此时的sum)范围为0-10</span></span><br><span class="line">                sum = sum % <span class="number">11</span>;</span><br><span class="line">                <span class="comment">//身份证最后一位和校验码比对是否相同 不同则输出  相同说明正确不做处理</span></span><br><span class="line">                <span class="keyword">if</span>(idCardChar[idCardChar.length-<span class="number">1</span>] != checkCodeM[sum])&#123;</span><br><span class="line">                <span class="comment">//此时也应将flag 置为false</span></span><br><span class="line"><span class="comment">//因为这句代码刚开始未加 一个测试点过不了，折腾了好长时间</span></span><br><span class="line">                    flag = <span class="keyword">false</span>;</span><br><span class="line">                    System.out.println(idCard);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">            System.out.print(<span class="string">&quot;All passed&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> PAT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1017 A除以B（20分）</title>
      <link href="2021/01/06/1017-A%E9%99%A4%E4%BB%A5B(20%E5%88%86)/"/>
      <url>2021/01/06/1017-A%E9%99%A4%E4%BB%A5B(20%E5%88%86)/</url>
      
        <content type="html"><![CDATA[<h2 id="1017-A除以B-20分"><a href="#1017-A除以B-20分" class="headerlink" title="1017 A除以B (20分)"></a>1017 A除以B (20分)</h2><p>本题要求计算 A/B，其中 A 是不超过 1000 位的正整数，B 是 1 位正整数。你需要输出商数 Q 和余数 R，使得 A=B×Q+R 成立。</p><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p> 输入在一行中依次给出 A 和 B，中间以 1 空格分隔。</p><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>在一行中依次输出 Q 和 R，中间以 1 空格分隔。</p><h3 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h3><blockquote><p>123456789050987654321 7      </p></blockquote><h3 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h3><blockquote><p>17636684150141093474 3</p></blockquote><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  <span class="comment">//读取输入</span></span><br><span class="line">  BufferedReader bufferedReader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">  String[] s = bufferedReader.readLine().split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">  bufferedReader.close();</span><br><span class="line">  <span class="comment">//除数A</span></span><br><span class="line">  <span class="keyword">char</span>[] str = s[<span class="number">0</span>].toCharArray();</span><br><span class="line">  <span class="comment">//被除数B </span></span><br><span class="line">  <span class="keyword">int</span> b = s[<span class="number">1</span>].charAt(<span class="number">0</span>) - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">  <span class="comment">//存放商</span></span><br><span class="line">  StringBuilder result = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">  <span class="keyword">int</span> number = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">//仿照除法 从高位一位一位的处理</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">char</span> c : str) &#123;</span><br><span class="line">      number = number * <span class="number">10</span> + (<span class="keyword">int</span>) c - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">      result.append((<span class="keyword">char</span>) (number / b + <span class="string">&#x27;0&#x27;</span>));</span><br><span class="line">      number = number % b;</span><br><span class="line">  &#125;</span><br><span class="line">  String out = result.toString();</span><br><span class="line">  <span class="comment">//最终输出结果处理 商 + 余数</span></span><br><span class="line">  <span class="keyword">if</span>(out.startsWith(<span class="string">&quot;0&quot;</span>) &amp;&amp; out.length()!= <span class="number">1</span>)&#123;</span><br><span class="line">System.out.print(out.substring(<span class="number">1</span>) + <span class="string">&quot; &quot;</span> + number);</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">System.out.print(out + <span class="string">&quot; &quot;</span> + number);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>此题内容比较好理解，就是模仿小学学的<strong>除法竖式</strong>来进行除法的运算。将除数一位一位进行处理，核心代码就for循环中的三句，这三句代码模拟实现了除法运算的过程。需要注意的就是输出最终结果时候处理一下，保证输出结果格式和要求的一致。<br><strong>在OJ中提交Java代码需要注意类名要为Main</strong>,即</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">           <span class="comment">//具体代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> PAT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1022 D进制的A+B (20分) PAT</title>
      <link href="2021/01/06/1022%20D%E8%BF%9B%E5%88%B6%E7%9A%84A+B%20(20%E5%88%86)%20PAT/"/>
      <url>2021/01/06/1022%20D%E8%BF%9B%E5%88%B6%E7%9A%84A+B%20(20%E5%88%86)%20PAT/</url>
      
        <content type="html"><![CDATA[<h2 id="1022-D进制的A-B-20分"><a href="#1022-D进制的A-B-20分" class="headerlink" title="1022 D进制的A+B (20分)"></a>1022 D进制的A+B (20分)</h2><p>输入两个非负 10 进制整数 A 和 B (≤2^30−1)，输出 A+B 的 D (1&lt;D≤10)进制数。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入在一行中依次给出 3 个整数 A、B 和 D。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>输出 A+B 的 D 进制数。</p><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><blockquote><p>123 456 8</p></blockquote><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><blockquote><p>1103</p></blockquote><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h3><p>此题题意简单易懂，也没有那么些坑，说一下我看的解题思路。<br>首先这道题是求进制转换，进制要求(1-10],<strong>不用过多考虑用英文字母代替10以上数字问题。</strong><br>然后A和B的范围为int,A+B可就不一定了，故<strong>A+B的和考虑用long</strong>。<br>进制转换就是类似除法竖式求余，不懂的可以点这个看一下。<a href="https://baike.baidu.com/item/%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2/3117222">进制转换</a><br>解题想法和 <a href="https://blog.csdn.net/fluetty/article/details/105989232">1017 A除以B</a> 类似。<br>第一次代码提交有一个测试点未过，仔细想了想是<strong>忘记了A+B结果为0情况处理</strong>，加上后顺利AC。解题大约耗时5分钟。</p><h3 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h3><p><strong>具体逻辑细节看代码注释</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//读取输入</span></span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="comment">//读入 A B</span></span><br><span class="line">        <span class="keyword">int</span> a = sc.nextInt();</span><br><span class="line">        <span class="keyword">int</span> b = sc.nextInt();</span><br><span class="line">        <span class="comment">//读入所求进制</span></span><br><span class="line">        <span class="keyword">int</span> d = sc.nextInt();</span><br><span class="line">        <span class="comment">//C 保存 A+B的值 可能超界 用long</span></span><br><span class="line">        <span class="keyword">long</span> c = a + b;</span><br><span class="line">        <span class="comment">//先处理异常情况 和为零直接输出零</span></span><br><span class="line">        <span class="keyword">if</span>(c == <span class="number">0</span>)&#123;</span><br><span class="line">            System.out.print(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//循环中字符串追加 最好使用StringBuilder</span></span><br><span class="line">        StringBuilder result = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="comment">//C不停的除要转换的进制并给自己赋值 为零时结束循环</span></span><br><span class="line">        <span class="keyword">while</span> (c != <span class="number">0</span>)&#123;</span><br><span class="line">            result.append(c % d);</span><br><span class="line">            c = c / d;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//得到的余数倒序即为所求结果</span></span><br><span class="line">        System.out.print(result.reverse());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> PAT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>反射模拟实现spring的getBean方法</title>
      <link href="2021/01/05/%E5%8F%8D%E5%B0%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0spring%E7%9A%84getBean%E6%96%B9%E6%B3%95/"/>
      <url>2021/01/05/%E5%8F%8D%E5%B0%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0spring%E7%9A%84getBean%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p><strong>IoC(Inversion of Control) 控制反转，是spring框架的核心。DI（dependency injection）依赖注入是IoC 的核心。</strong></p><h3 id="IoC控制反转到底反转了什么？"><a href="#IoC控制反转到底反转了什么？" class="headerlink" title="IoC控制反转到底反转了什么？"></a>IoC控制反转到底反转了什么？</h3><p><strong>依赖对象的创建和依赖关系的形成，</strong>解耦。</p><p>spring不用自己创建对象，只需要在配置文件中配置属性就可以对其实现赋值。依赖注入底层是如何实现的呢，今天就用反射来手动实现getBean()方法。</p><p>项目中需要用到dom4j的jar包来解析spring的xml配置文件。下载链接如下：<a href="https://dom4j.github.io/">https://dom4j.github.io/</a></p><p>工程的总体目录如下，代码简单，注释详细。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20190613200920875.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZsdWV0dHk=,size_16,color_FFFFFF,t_70" alt="pic"> 总目录</p><p><img src= "/img/loading.gif" data-lazy-src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>实体类Student的代码如下：四个不同属性 ，分别设置setter和getter方法，重写toString方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.entity;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">char</span> gender;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">double</span> salary;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">getGender</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> gender;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setGender</span><span class="params">(<span class="keyword">char</span> gender)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.gender = gender;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getSalary</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> salary;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSalary</span><span class="params">(<span class="keyword">double</span> salary)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.salary = salary;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;Student [name=&quot;</span> + name + <span class="string">&quot;, age=&quot;</span> + age + <span class="string">&quot;, gender=&quot;</span> + gender + <span class="string">&quot;, salary=&quot;</span> + salary + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>最重要的ApplicationContext如下，主要是解析xml文件，得到类的对象并赋值。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.factory;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> org.dom4j.Document;</span><br><span class="line"><span class="keyword">import</span> org.dom4j.Element;</span><br><span class="line"><span class="keyword">import</span> org.dom4j.io.SAXReader;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplicationContext</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> String configFileName;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ApplicationContext</span><span class="params">(String configFileName)</span></span>&#123;</span><br><span class="line"><span class="keyword">this</span>.configFileName = configFileName;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getBean</span><span class="params">(String id)</span><span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line"><span class="comment">//我们需要解析XML配置文件 所以创建SAXReader</span></span><br><span class="line">SAXReader reader = <span class="keyword">new</span> SAXReader();</span><br><span class="line"><span class="comment">//读取xml文件形成文档树对象   为避免使用不同IDE 找不到文件  使用相对路径</span></span><br><span class="line">Document doc = reader.read(<span class="keyword">this</span>.getClass().getResourceAsStream(<span class="string">&quot;../../&quot;</span>+configFileName));</span><br><span class="line"><span class="comment">//得到根元素</span></span><br><span class="line">Element root = doc.getRootElement();</span><br><span class="line"><span class="comment">//从根元素进一步解析它的子元素</span></span><br><span class="line">List&lt;Element&gt; bs = root.elements();</span><br><span class="line"><span class="comment">//我们需要遍历每一个bean 找到用户需要的那个id的bean</span></span><br><span class="line"><span class="keyword">for</span>(Element b : bs)&#123;</span><br><span class="line"><span class="comment">//我们需要拿到bean的id属性(attribute) </span></span><br><span class="line">String beanId = b.attributeValue(<span class="string">&quot;id&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(id.equals(beanId))&#123;<span class="comment">//终于找到你</span></span><br><span class="line"><span class="comment">//找到这个bean所对应的class属性</span></span><br><span class="line">String beanClass = b.attributeValue(<span class="string">&quot;class&quot;</span>);</span><br><span class="line"><span class="comment">//利用反射 得到这个类的Class对象</span></span><br><span class="line">Class c = Class.forName(beanClass);</span><br><span class="line"><span class="comment">//利用反射 得到这个Class所对应的类的一个实例</span></span><br><span class="line">Object obj = c.newInstance();</span><br><span class="line"><span class="comment">//为了注入属性</span></span><br><span class="line"><span class="comment">//得到所有&lt;property&gt;子元素</span></span><br><span class="line">List&lt;Element&gt; ps = b.elements();</span><br><span class="line"><span class="comment">//遍历每一个property元素</span></span><br><span class="line"><span class="keyword">for</span>(Element p : ps)&#123;</span><br><span class="line"><span class="comment">//得到property元素的name属性</span></span><br><span class="line">String propertyName = p.attributeValue(<span class="string">&quot;name&quot;</span>);</span><br><span class="line"><span class="comment">//得到property元素的value属性</span></span><br><span class="line">String propertyValue = p.attributeValue(<span class="string">&quot;value&quot;</span>);</span><br><span class="line"><span class="comment">//推断它的setter方法的名字</span></span><br><span class="line">String setterName = <span class="string">&quot;set&quot;</span> + propertyName.substring(<span class="number">0</span>,<span class="number">1</span>).toUpperCase() + propertyName.substring(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//得到Field属性对象</span></span><br><span class="line">Field field = c.getDeclaredField(propertyName);</span><br><span class="line"><span class="comment">//得到属性的类型</span></span><br><span class="line">Class fieldType = field.getType();</span><br><span class="line"></span><br><span class="line"><span class="comment">//到这里 我们既有了setter方法的名字 又有了setter方法要的参数</span></span><br><span class="line"><span class="comment">//得到setter方法对应的Method对象</span></span><br><span class="line">Method setter = c.getDeclaredMethod(setterName,fieldType);</span><br><span class="line"></span><br><span class="line"><span class="comment">//我们需要得到属性的类型的名字</span></span><br><span class="line">String fieldTypeName = fieldType.getSimpleName();</span><br><span class="line"></span><br><span class="line"><span class="comment">//以下简单解析  实际肯定比这复杂 </span></span><br><span class="line"><span class="comment">//包括 -ref  list array 等的处理  复杂不代表难，此处重点理解思想</span></span><br><span class="line"><span class="comment">//判断当前属性是不是字符串类型</span></span><br><span class="line"><span class="keyword">if</span>(<span class="string">&quot;String&quot;</span>.equals(fieldTypeName))&#123;</span><br><span class="line">setter.invoke(obj, propertyValue);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断当前属性是不是int类型</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">&quot;int&quot;</span>.equals(fieldTypeName))&#123;</span><br><span class="line">setter.invoke(obj,Integer.parseInt(propertyValue));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断当前属性是不是double类型</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">&quot;double&quot;</span>.equals(fieldTypeName))&#123;</span><br><span class="line">setter.invoke(obj,Double.parseDouble(propertyValue));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断当前属性是不是char类型</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">&quot;char&quot;</span>.equals(fieldTypeName))&#123;</span><br><span class="line">setter.invoke(obj, propertyValue.charAt(<span class="number">0</span>));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>xml配置文件如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans&gt;</span><br><span class="line">&lt;bean id&#x3D;&quot;stu&quot; class&#x3D;&quot;com.entity.Student&quot;&gt;</span><br><span class="line">&lt;property name&#x3D;&quot;name&quot; value&#x3D;&quot;zhangsan&quot; &#x2F;&gt;</span><br><span class="line">&lt;property name&#x3D;&quot;age&quot; value&#x3D;&quot;25&quot;&#x2F;&gt;</span><br><span class="line">&lt;property name&#x3D;&quot;gender&quot; value&#x3D;&quot;男&quot;&#x2F;&gt;</span><br><span class="line">&lt;property name&#x3D;&quot;salary&quot; value&#x3D;&quot;16666&quot; &#x2F;&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br><span class="line">&lt;&#x2F;beans&gt;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>测试类如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.test;</span><br><span class="line"><span class="keyword">import</span> com.entity.Student;</span><br><span class="line"><span class="keyword">import</span> com.factory.ApplicationContext;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestSpringBean</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">ApplicationContext ac = <span class="keyword">new</span> ApplicationContext(<span class="string">&quot;spring.xml&quot;</span>);</span><br><span class="line">Student stu = (Student)ac.getBean(<span class="string">&quot;stu&quot;</span>);</span><br><span class="line">System.out.println(stu);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>测试结果显示成功得到stu对象，并且成功为属性赋值。</p><p>其实spring框架底层就是用反射和配置文件来实现new对象，setter方法为属性赋值的。</p><p>所有框架底层都要用到反射，因为框架写好在前，我们使用在后。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2020年读书笔记和随想</title>
      <link href="2020/11/30/2020%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
      <url>2020/11/30/2020%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="极简生活"><a href="#极简生活" class="headerlink" title="极简生活"></a>极简生活</h1><p>人生精彩与否，不在于“拥有多少物品”，而在于“拥有多少让自己愉悦的时间”。</p><p>物品越多，使用频率越低，单个物品的“使用价值”就越低。在这种情况下，你花出去的钱没有产生出应有的价值。</p><p>减少身边的东西，是过上极简生活的第一步。</p><p>人能管理好的东西十分有限。想拥有平和的心态，就把多余的杂物处理掉吧。如此一来，你就不用耗费多余的精力了。</p><p>一个物品的价值不仅仅包含了你购买物品的花费，还需要包含后续在它身上所耗费的时间和精力！所以扔掉一些物品就是在节约后续可能耗费的时间价值！</p><p>什么东西该买呢？“该买的东西”有两个必备条件。条件之一，它必须是“你打从心底里想要的东西”。想要的东西不能买，想做的事情不能做，那辛辛苦苦工作还有什么意义啊！</p><p>条件之二，你必须“能想象出自己要如何用这个东西”。</p><p>“扔东西”常会带来一定的“痛感”。这种痛感的根源，就是对未来的担忧（“也许哪天会用到……”），或是对过往的执着（“好容易买回来的……”）。</p><p>说白了就是“对失去的恐惧”。</p><p>不舍得扔”，换个角度看就是“抓着过去不放”。常有人担心丢弃物品就是变相抛弃自己的价值。殊不知它们带来的经验与回忆，早已成为我们不可分割的一部分……</p><p>我们无须为未来忧心忡忡。只要脚踏实地过好“现在”，“未来”就一定会以最佳的状态呈现在你面前。到时候，再根据实际情况准备合适的物品就行了。</p><p>“东西”存在的意义并不是“放着积灰”，而是“被人使用”。</p><p>收纳的目的，并不是把东西“藏”起来，而是“方便取用”。</p><p>吸引力法则</p><p>自己喜欢一样事物，就去探索的过程中会遇到跟你有一样爱好的人，你的进步就会越来越快，物以类聚，人以群分。</p><p>很多时候事情没有那么难，只是对于自己不了解的东西一开始自己就在心里预设了很多困难，勇敢开始了第一步，后面就容易多了</p><p>幸运其实只是充分准备加上努力工作的结果</p><p>要想过更幸福、更满意的生活，人就得改变自身。这和钱无关，金钱本身既不会使人幸福，也不会带来不幸。金钱是中性的，既不好，也不坏。只有当钱属于某一个人的时候，它才会对这个人产生好的影响或者坏的影响。钱可以被用于好的用途，也可以被用于坏的用途。一个幸福的人有了钱会更幸福；而一个悲观忧虑的人，钱越多，烦恼就越多。</p><p>成功会使人骄傲。如果你骄傲自大，你就会停止学习。不学习，人就不会再进步。</p><p>恐惧总是出现在我们设想事情会如何不顺的时候。我们对失败的可能性想得越多，就会越害怕。</p><p>一个人觉得最引以为自豪的事情，往往是那些做起来最艰难的事情。</p><p>不要为失去的东西而忧伤，而要对拥有它的时光心存感激。</p><h1 id="理财相关"><a href="#理财相关" class="headerlink" title="理财相关"></a>理财相关</h1><p>一次次坐过山车不能积累财富，一次次把赚的钱留下来才能积累财富。 （落袋为安）</p><p>定投最大的意义在于强制储蓄，其次才是提供相对可观的长期收益。</p><h1 id="2020-3-5-基金定投感悟"><a href="#2020-3-5-基金定投感悟" class="headerlink" title="2020/3/5 基金定投感悟"></a>2020/3/5 基金定投感悟</h1><p>​    《小狗钱钱》里面说要有一只自己的鹅，我养了这么长时间的一只鹅终于给我生蛋了。</p><p>​       看了看定投记录，从19年八月份开始定投这只基金，刚开始都是10块，想着试试水。后来看了一些有关基金定投的文章，知道了微笑曲线等。</p><p>理财知识不是说非得等有多少钱了才开始去学，现在钱少正是试错的好机会。终于终于开始盈利了，虽然说有可能再跌，那就是止盈相关的问题了。</p><p>​      要相信长期持有坚持定投一只基金是能盈利的，要有这种信心。我要坚持下去，去更系统的学习理财知识，去不断试错。说的想的再多，不如真正去投进去钱感受的深刻。舞台再大，你不上场，终究就只是个观众。希望今年年底能挣到买年货的钱吧。</p><p>​       我的鹅，多多给我生蛋吧。咱们一起成长。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 日常 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>电影评论文本分类-tensorflow入门</title>
      <link href="2020/11/30/%E7%94%B5%E5%BD%B1%E8%AF%84%E8%AE%BA%E6%96%87%E6%9C%AC%E5%88%86%E7%B1%BB-tensorflow%E5%85%A5%E9%97%A8/"/>
      <url>2020/11/30/%E7%94%B5%E5%BD%B1%E8%AF%84%E8%AE%BA%E6%96%87%E6%9C%AC%E5%88%86%E7%B1%BB-tensorflow%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="电影评论文本分类-tensorflow入门"><a href="#电影评论文本分类-tensorflow入门" class="headerlink" title="电影评论文本分类-tensorflow入门"></a>电影评论文本分类-tensorflow入门</h2><p>来源于网络电影数据库（Internet Movie Database）的 IMDB 数据集（IMDB dataset），<br>其包含 50,000 条影评文本。从该数据集切割出的25,000条评论用作训练，另外 25,000 条用作测试。<br>训练集与测试集是平衡的（balanced），意味着它们包含相等数量的积极和消极评论。</p><ol><li>查看数据格式 准备数据</li><li>构建模型</li><li>训练模型</li><li>评估模型</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tensorflow <span class="keyword">import</span> keras</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下载数据集 该数据集已经经过预处理，评论（单词序列）已经被转换为整数序列，其中每个整数表示字典中的特定单词。</span></span><br><span class="line">imdb = keras.datasets.imdb</span><br><span class="line"><span class="comment"># num_words=10000 保留了训练数据中最常出现的 10,000 个单词</span></span><br><span class="line">(train_data, train_labels), (test_data, test_labels) = imdb.load_data(num_words=<span class="number">10000</span>)</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">查看数据格式</span></span><br><span class="line"><span class="string">该数据集是经过预处理的：每个样本都是一个表示影评中词汇的整数数组。</span></span><br><span class="line"><span class="string">每个标签都是一个值为 0 或 1 的整数值，其中 0 代表消极评论，1 代表积极评论。</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">print(<span class="string">&quot;Training entries: &#123;&#125;, labels: &#123;&#125;&quot;</span>.<span class="built_in">format</span>(<span class="built_in">len</span>(train_data), <span class="built_in">len</span>(train_labels)))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 评论文本被转换为整数值，其中每个整数代表词典中的一个单词。查看首条评论</span></span><br><span class="line">print(train_data[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 电影评论可能具有不同的长度 由于神经网络的输入必须是统一的长度，需要解决这个问题。</span></span><br><span class="line">print(<span class="built_in">len</span>(train_data[<span class="number">0</span>]), <span class="built_in">len</span>(train_data[<span class="number">1</span>]), <span class="built_in">len</span>(train_data[<span class="number">2</span>]))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 一个映射单词的整数索引的字典</span></span><br><span class="line">word_index = imdb.get_word_index()</span><br><span class="line"><span class="comment"># 保留第一个索引</span></span><br><span class="line">word_index = &#123;k: (v + <span class="number">3</span>) <span class="keyword">for</span> k, v <span class="keyword">in</span> word_index.items()&#125;</span><br><span class="line">word_index[<span class="string">&quot;&lt;PAD&gt;&quot;</span>] = <span class="number">0</span></span><br><span class="line">word_index[<span class="string">&quot;&lt;START&gt;&quot;</span>] = <span class="number">1</span></span><br><span class="line">word_index[<span class="string">&quot;&lt;UNK&gt;&quot;</span>] = <span class="number">2</span>  <span class="comment"># unknown</span></span><br><span class="line">word_index[<span class="string">&quot;&lt;UNUSED&gt;&quot;</span>] = <span class="number">3</span></span><br><span class="line"></span><br><span class="line">reverse_word_index = <span class="built_in">dict</span>([(value, key) <span class="keyword">for</span> (key, value) <span class="keyword">in</span> word_index.items()])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将整数转换为文本，创建辅助函数来查询一个包含了整数到字符串映射的字典对象</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decode_review</span>(<span class="params">text</span>):</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27; &#x27;</span>.join([reverse_word_index.get(i, <span class="string">&#x27;?&#x27;</span>) <span class="keyword">for</span> i <span class="keyword">in</span> text])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看首条评论的文本内容</span></span><br><span class="line">print(decode_review(train_data[<span class="number">0</span>]))</span><br></pre></td></tr></table></figure><h2 id="准备数据"><a href="#准备数据" class="headerlink" title="准备数据"></a>准备数据</h2><p>影评——即整数数组必须在输入神经网络之前转换为张量。这种转换可以通过以下两种方式来完成：</p><p>将数组转换为表示单词出现与否的由 0 和 1 组成的向量，类似于 one-hot 编码。例如，序列[3, 5]将转换为一个 10,000 维的向量，<br>该向量除了索引为 3 和 5 的位置是 1 以外，其他都为 0。然后，将其作为网络的首层——一个可以处理浮点型向量数据的稠密层。<br>不过，这种方法需要大量的内存，需要一个大小为 num_words * num_reviews 的矩阵。</p><p>或者，可以填充数组来保证输入数据具有相同的长度，然后创建一个大小为 max_length * num_reviews 的整型张量。<br>可以使用能够处理此形状数据的嵌入层作为网络中的第一层。</p><p>使用第二种方法</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 由于电影评论长度必须相同，使用 pad_sequences 函数来使长度标准化</span></span><br><span class="line">train_data = keras.preprocessing.sequence.pad_sequences(train_data,</span><br><span class="line">                                                        value=word_index[<span class="string">&#x27;&lt;PAD&gt;&#x27;</span>],</span><br><span class="line">                                                        padding=<span class="string">&#x27;post&#x27;</span>,</span><br><span class="line">                                                        maxlen=<span class="number">256</span>)</span><br><span class="line"></span><br><span class="line">test_data = keras.preprocessing.sequence.pad_sequences(test_data,</span><br><span class="line">                                                       value=word_index[<span class="string">&#x27;&lt;PAD&gt;&#x27;</span>],</span><br><span class="line">                                                       padding=<span class="string">&#x27;post&#x27;</span>,</span><br><span class="line">                                                       maxlen=<span class="number">256</span>)</span><br><span class="line"><span class="comment"># 处理之后的样本长度</span></span><br><span class="line">print(<span class="built_in">len</span>(train_data[<span class="number">0</span>]), <span class="built_in">len</span>(train_data[<span class="number">1</span>]), <span class="built_in">len</span>(train_data[<span class="number">2</span>]))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看首条评论，此时已经填充</span></span><br><span class="line">print(train_data[<span class="number">0</span>])</span><br></pre></td></tr></table></figure><h2 id="构建模型"><a href="#构建模型" class="headerlink" title="构建模型"></a>构建模型</h2><p>层按顺序堆叠以构建分类器：</p><ol><li> 第一层是嵌入（Embedding）层。该层采用整数编码的词汇表，并查找每个词索引的嵌入向量（embedding vector）。这些向量是通过模型训练学习到的。 向量向输出数组增加了一个维度。得到的维度为：(batch, sequence, embedding)。</li><li> 接下来，GlobalAveragePooling1D 将通过对序列维度求平均值来为每个样本返回一个定长输出向量。这允许模型以尽可能最简单的方式处理变长输入。  </li><li>该定长输出向量通过一个有 16 个隐层单元的全连接（Dense）层传输。</li><li>最后一层与单个输出结点密集连接。使用 Sigmoid 激活函数，其函数值为介于 0 与 1 之间的浮点数，表示概率或置信度。</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">构建模型</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="comment"># 输入形状是用于电影评论的词汇数目</span></span><br><span class="line">vocab_size = <span class="number">10000</span></span><br><span class="line"></span><br><span class="line">model = keras.Sequential()</span><br><span class="line">model.add(keras.layers.Embedding(vocab_size, <span class="number">16</span>))</span><br><span class="line">model.add(keras.layers.GlobalAveragePooling1D())</span><br><span class="line">model.add(keras.layers.Dense(<span class="number">16</span>, activation=<span class="string">&#x27;relu&#x27;</span>))</span><br><span class="line">model.add(keras.layers.Dense(<span class="number">1</span>, activation=<span class="string">&#x27;sigmoid&#x27;</span>))</span><br><span class="line"></span><br><span class="line">model.summary()</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">隐层单元</span></span><br><span class="line"><span class="string">上述模型在输入输出之间有两个中间层或“隐藏层”。输出（单元，结点或神经元）的数量即为层表示空间的维度。换句话说，是学习内部表示时网络所允许的自由度。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">如果模型具有更多的隐层单元（更高维度的表示空间）和/或更多层，则可以学习到更复杂的表示。</span></span><br><span class="line"><span class="string">但是，这会使网络的计算成本更高，并且可能导致学习到不需要的模式——一些能够在训练数据上而不是测试数据上改善性能的模式。</span></span><br><span class="line"><span class="string">这被称为过拟合（overfitting）</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="comment"># 二分类问题且模型输出概率值（一个使用 sigmoid 激活函数的单一单元层），此处使用 binary_crossentropy 损失函数。</span></span><br><span class="line">model.<span class="built_in">compile</span>(optimizer=<span class="string">&#x27;adam&#x27;</span>,</span><br><span class="line">              loss=<span class="string">&#x27;binary_crossentropy&#x27;</span>,</span><br><span class="line">              metrics=[<span class="string">&#x27;accuracy&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建验证集 检查模型在未见过的数据上的准确率（accuracy）</span></span><br><span class="line"><span class="comment"># 通过从原始训练数据中分离10000个样本来创建一个验证集. 目标是只使用训练数据来开发和调整模型,使用测试数据评估准确率，所以此处不用测试集</span></span><br><span class="line">x_val = train_data[<span class="number">0</span>:<span class="number">10000</span>]</span><br><span class="line">partial_x_train = train_data[<span class="number">10000</span>:]</span><br><span class="line"></span><br><span class="line">y_val = train_labels[<span class="number">0</span>:<span class="number">10000</span>]</span><br><span class="line">partial_y_train = train_labels[<span class="number">10000</span>:]</span><br></pre></td></tr></table></figure><h2 id="训练模型"><a href="#训练模型" class="headerlink" title="训练模型"></a>训练模型</h2><p> 以512个样本的mini-batch大小迭代40个epoch来训练模型。<br> 这是指对 x_train 和 y_train 张量中所有样本的的 40 次迭代。在训练过程中，监测来自验证集的 10,000 个样本上的损失值（loss）和准确率（accuracy）</p><ul><li>verbose：日志显示</li><li>verbose = 0 为不在标准输出流输出日志信息</li><li>verbose = 1 为输出进度条记录</li><li>verbose = 2 为每个epoch输出一行记录</li><li>注意： 默认为 1<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">history = model.fit(partial_x_train,</span><br><span class="line">                    partial_y_train,</span><br><span class="line">                    epochs=<span class="number">40</span>,</span><br><span class="line">                    batch_size=<span class="number">512</span>,</span><br><span class="line">                    validation_data=(x_val,y_val),</span><br><span class="line">                    verbose=<span class="number">1</span>)</span><br></pre></td></tr></table></figure></li></ul><h2 id="评估模型"><a href="#评估模型" class="headerlink" title="评估模型"></a>评估模型</h2><p> 点代表训练损失值（loss）与准确率（accuracy），实线代表验证损失值（loss）与准确率（accuracy）<br>    训练损失值随每一个 epoch 下降而训练准确率（accuracy）随每一个 epoch 上升.<br>    验证过程的损失值（loss）与准确率（accuracy）的情况并非如此，在20个epoch后达到峰值趋于平缓。<br>    这是过拟合的一个实例：模型在训练数据上的表现比在以前从未见过的数据上的表现要更好。<br>    在此之后，模型过度优化并学习特定于训练数据的表示，而不能够泛化到测试数据。<br>    对于这种特殊情况，可以通过在 20 个左右的 epoch 后停止训练来避免过拟合。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 评估模型</span></span><br><span class="line">results = model.evaluate(test_data, test_labels, verbose=<span class="number">2</span>)</span><br><span class="line">print(results)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个准确率（accuracy）和损失值（loss）随时间变化的图表 方便调参</span></span><br><span class="line"><span class="comment"># model.fit() 返回一个 History 对象，该对象包含一个字典，其中包含训练阶段所发生的一切事件</span></span><br><span class="line">history_dict = history.history</span><br><span class="line">history_dict.keys()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 有&#x27;loss&#x27;, &#x27;accuracy&#x27;, &#x27;val_loss&#x27;, &#x27;val_accuracy&#x27;四个条目</span></span><br><span class="line"><span class="comment"># 在训练和验证期间，每个条目对应一个监控指标。可以使用这些条目来绘制训练与验证过程的损失值（loss）和准确率（accuracy），以便进行比较</span></span><br><span class="line">acc = history_dict[<span class="string">&#x27;accuracy&#x27;</span>]</span><br><span class="line">val_acc = history_dict[<span class="string">&#x27;val_accuracy&#x27;</span>]</span><br><span class="line">loss = history_dict[<span class="string">&#x27;loss&#x27;</span>]</span><br><span class="line">val_loss = history_dict[<span class="string">&#x27;val_loss&#x27;</span>]</span><br><span class="line"></span><br><span class="line">epochs = <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(acc) + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># “bo”代表 &quot;蓝点&quot;</span></span><br><span class="line">plt.plot(epochs, loss, <span class="string">&#x27;bo&#x27;</span>, label=<span class="string">&#x27;Training loss&#x27;</span>)</span><br><span class="line"><span class="comment"># b代表“蓝色实线”</span></span><br><span class="line">plt.plot(epochs, val_loss, <span class="string">&#x27;b&#x27;</span>, label= <span class="string">&#x27;Validation loss&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;Training and validation loss&#x27;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;Epochs&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;Loss&#x27;</span>)</span><br><span class="line">plt.legend()</span><br><span class="line"></span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 清除数字</span></span><br><span class="line">plt.clf()</span><br><span class="line">plt.plot(epochs, acc, <span class="string">&#x27;bo&#x27;</span>, label=<span class="string">&#x27;Training acc&#x27;</span>)</span><br><span class="line">plt.plot(epochs, val_acc, <span class="string">&#x27;b&#x27;</span>, label=<span class="string">&#x27;Validation acc&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;Training and validation accuracy&#x27;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;Epochs&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;Accuracy&#x27;</span>)</span><br><span class="line">plt.legend()</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 文本分类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>个人博客折腾记录</title>
      <link href="2020/11/13/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%8A%98%E8%85%BE%E8%AE%B0%E5%BD%95/"/>
      <url>2020/11/13/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%8A%98%E8%85%BE%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<p>以前的博客都是记录在CSDN上的，最近在整理一些学习笔记，我想为什么不自己搭建个博客呢？那么说干就干吧。</p><p>我的想法是先利用现成的开源框架快速搭建一个博客，后期再折腾迭代（考虑手敲代码构建一个博客）。</p><h2 id="技术选型"><a href="#技术选型" class="headerlink" title="技术选型"></a>技术选型</h2><p>现成有很多方案可以选择，我就选择了其中比较简单的 <a href="https://hexo.io/zh-cn">Hexo</a> 框架，使用的是<a href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a> 主题。Hexo的基本常用指令没有几个，刚开始重点放在了主题的折腾上，逐渐会把重心向文章转移，专注于文章的写作。</p><h3 id="Hexo-GitHubPages-搭建博客"><a href="#Hexo-GitHubPages-搭建博客" class="headerlink" title="Hexo+GitHubPages 搭建博客"></a>Hexo+GitHubPages 搭建博客</h3><ol><li><p>Node.js下载安装</p></li><li><p>Git 下载安装</p></li><li><p>安装Hexo</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure></li></ol><ol start="4"><li><p>初始化 Hexo, 会新建一个文件夹   <a href="https://hexo.io/zh-cn/docs/">参考文档</a></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo init &lt;folder&gt;</span><br><span class="line">cd &lt;folder&gt;</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure><p>Hexo相关命令均在站点目录下用Git Bash运行。</p></li><li><p>启动服务器。在站点目录下（Git Bash)，执行以下命令，会实时监测文章的变更并渲染。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo server</span><br></pre></td></tr></table></figure></li><li><p>浏览器访问网址： <code>http://localhost:4000/</code> 此时Hexo博客已经运行在本地。默认的主题样式landscape在theme文件夹下。</p></li><li><p>新建文章，会在 站点目录/source/_posts 下生成一个 文章名字.md 文件，使用自己熟悉的markdown编辑器编辑保存文章，网页可实时查看效果。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo n &quot;文章名字&quot;</span><br></pre></td></tr></table></figure></li><li><p>GitHub：建立一个github.io的库 ，仓库名为：&lt;GitHub账号名称&gt;.github.io  <a href="https://sspai.com/post/54608">参考链接</a></p></li><li><p>将本地Hexo博客推送到GithubPages</p><ul><li><p>安装hexo-deployer-git插件。在命令行（即Git Bash）运行以下命令即可 </p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure></li><li><p>添加到 GitHub。 复制密钥文件内容（路径形如<code>C:\Users\Administrator\.ssh\id_rsa.pub</code>），粘贴到<a href="https://github.com/settings/keys">New SSH Key</a>即可。</p></li><li><p>测试是否添加成功。在命令行（即Git Bash）依次输入以下命令，返回“You’ve successfully authenticated”即成功</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure></li><li><p>修改<code>_config.yml</code>（在站点目录下）。文件末尾修改为：仓库地址写ssh地址， <strong>branch需要注意最近改为main了</strong></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Deployment</span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># Docs: https://hexo.io/docs/deployment.html</span></span></span><br><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: git@github.com:&lt;Github账号名称&gt;/&lt;Github账号名称&gt;.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure></li><li><p>推送到GithubPages。在命令行（即Git Bash）依次输入以下命令， 返回<code>INFO Deploy done: git</code>即成功推送：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo g -d</span><br></pre></td></tr></table></figure></li><li><p>等待1分钟左右，浏览器访问网址： <code>https://&lt;Github账号名称&gt;.github.io</code></p></li></ul></li></ol><p>​                 至此，Hexo博客已经搭建在GithubPages, 域名为<code>https://&lt;Github账号名称&gt;.github.io</code></p><h3 id="主题修改"><a href="#主题修改" class="headerlink" title="主题修改"></a>主题修改</h3><p>选择自己所需要的主题，下载安装，按照说明文档选择自己想要的效果修改即可。<a href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a> 主题</p><p>搞了个自言自语的碎碎念模块记录心情。</p><p>页面左下角新增了一个可爱的白色小猫咪。</p><h2 id="PicGo-GitHub实现图床"><a href="#PicGo-GitHub实现图床" class="headerlink" title="PicGo+GitHub实现图床"></a>PicGo+GitHub实现图床</h2><p>博客中所需要的文件存放在图床上，方便迁移的随取随用。我是用<a href="https://blog.csdn.net/fluetty/article/details/109224904">PicGo+GitHub实现图床</a></p><p>因为公司有外网，所以渲染加载图片很快，自己实际测试发现会加载不出图片。目前的折中方案是使用了路过图床，准备过一阵自己搭建个人图床。</p><h2 id="ToDo-List"><a href="#ToDo-List" class="headerlink" title="ToDo List"></a>ToDo List</h2><ol><li>文章笔记持续更新、标签分类整理</li><li>网站分析统计、搜索引擎收录网站、CDN</li><li>搭建个人文件服务器</li><li>搭建个人图床</li></ol>]]></content>
      
      
      <categories>
          
          <category> blog </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>推送代码到GitHub遇到的Connection timed out问题</title>
      <link href="2020/11/10/%E6%8E%A8%E9%80%81%E4%BB%A3%E7%A0%81%E9%81%87%E5%88%B0Connection%20timed%20out%E9%97%AE%E9%A2%98/"/>
      <url>2020/11/10/%E6%8E%A8%E9%80%81%E4%BB%A3%E7%A0%81%E9%81%87%E5%88%B0Connection%20timed%20out%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>最近在尝试使用Hexo和GitHub构建个人博客，本地将代码推送到GitHub是完全正常的。可是今天推送代码时候却推不上去。</p><p>报错信息：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ssh: connect to host github.com port 22: Connection timed out</span><br><span class="line">fatal: Could not read from remote repository.</span><br><span class="line">Please make sure you have the correct access rights and the repository exists.</span><br></pre></td></tr></table></figure><p>从报错信息可以看出连接GitHub超时，因为公司是能直接连接外网的，而且速度还很快，于是没有考虑网络的问题。我第一反应是配置有问题，于是就开始google解决方法。</p><p>我找到的第一种方法是重新生成并配置GitHub公钥。删除后重新生成并配置完成之后，还是推送不上。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;邮箱地址&quot;</span><br></pre></td></tr></table></figure><p>此时我又找别的解决方案，看到了这篇文章。<a href="https://www.jianshu.com/p/9f2962a6a217">关于github报错connect to host github.com port 22: Connection timed out的解决</a></p><p>我也切换端口连接了一下，发现连接成功了。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ssh -T -p 443 git@ssh.github.com</span><br></pre></td></tr></table></figure><p>文章中的解决方案是：通过修改github连接方式，从之前设置的ssh方法转成https方法。可是我并不想修改。</p><p>这时候我才想到有可能是网络的问题，于是我用手机热点成功推送，至此问题解决。</p>]]></content>
      
      
      <categories>
          
          <category> blog </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux下安装JDK1.8</title>
      <link href="2020/11/09/Linux%E4%B8%8B%E5%AE%89%E8%A3%85JDK/"/>
      <url>2020/11/09/Linux%E4%B8%8B%E5%AE%89%E8%A3%85JDK/</url>
      
        <content type="html"><![CDATA[<h2 id="下载-jdk1-8"><a href="#下载-jdk1-8" class="headerlink" title="下载 jdk1.8"></a>下载 jdk1.8</h2>   <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget --no-check-certificate --no-cookies --header &quot;Cookie: oraclelicense=accept-securebackup-cookie&quot;  http://download.oracle.com/otn-pub/java/jdk/8u131-b11/d54c1d3a095b4ff2b6607d096fa80163/jdk-8u131-linux-x64.tar.gz</span><br></pre></td></tr></table></figure><h2 id="解压移动目录"><a href="#解压移动目录" class="headerlink" title="解压移动目录"></a>解压移动目录</h2><ol><li><p>tar命令解压，生成jdk1.8.0_131目录</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tar -zxvf jdk-8u131-linux-x64.tar.gz</span><br></pre></td></tr></table></figure></li></ol><ol start="2"><li><p>mv重命名jdk1.8.0_131为jdk1.8</p> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mv jdk1.8.0_131 jdk1.8</span><br></pre></td></tr></table></figure></li><li><p>将jdk1.8移动到/usr/local 目录下（目录随意，环境变量配置为jdk路径）</p>   <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mv jdk1.8 /usr/local</span><br></pre></td></tr></table></figure></li></ol><h2 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h2><ol><li><p>修改/etc/profile 文件</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vi  &#x2F;etc&#x2F;profile</span><br></pre></td></tr></table></figure><p>打开后如下：</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/fluetty/clouding/main/data/image-20201111155706887.png" alt="image-20201111155706887"></p></li><li><p>按 i 进入INSERT模式，在文件最后配置环境变量。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export JAVA_HOME&#x3D;&#x2F;usr&#x2F;local&#x2F;jdk1.8</span><br><span class="line">export JRE_HOME&#x3D;$&#123;JAVA_HOME&#125;&#x2F;jre</span><br><span class="line">export CLASSPATH&#x3D;.:$&#123;JAVA_HOME&#125;&#x2F;lib:$&#123;JRE_HOME&#125;&#x2F;lib:$CLASSPATH</span><br><span class="line">export JAVA_PATH&#x3D;$&#123;JAVA_HOME&#125;&#x2F;bin:$&#123;JRE_HOME&#125;&#x2F;bin</span><br><span class="line">export PATH&#x3D;$PATH:$&#123;JAVA_PATH&#125;</span><br></pre></td></tr></table></figure></li><li><p>按ESC退出编辑模式， :wq 保存退出</p></li><li><p>使profile配置生效</p>   <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">source &#x2F;etc&#x2F;profile</span><br></pre></td></tr></table></figure></li></ol><h2 id="检测是否安装成功"><a href="#检测是否安装成功" class="headerlink" title="检测是否安装成功"></a>检测是否安装成功</h2><ol><li><p>输入常用的java 命令即可，如查看版本号</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java -version</span><br></pre></td></tr></table></figure></li><li><p>查看命令</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java -help</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 服务器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PicGo+GitHub实现免费图床</title>
      <link href="2020/11/04/PicGo-GitHub%E5%AE%9E%E7%8E%B0%E5%85%8D%E8%B4%B9%E5%9B%BE%E5%BA%8A/"/>
      <url>2020/11/04/PicGo-GitHub%E5%AE%9E%E7%8E%B0%E5%85%8D%E8%B4%B9%E5%9B%BE%E5%BA%8A/</url>
      
        <content type="html"><![CDATA[<p>为了方便自己学习和工作两台电脑.md文件中图片的同步，所以了解到PicGo和Github实现免费图床，特将操作过程记录下来。</p><h2 id="图床"><a href="#图床" class="headerlink" title="图床"></a>图床</h2><p>图床一般就是指存储图片的服务器。图床一般是指储存图片的服务器，有国内和国外之分。国外的图床由于有空间距离等因素决定访问速度很慢影响图片显示速度。国内也分为单线空间、多线空间和cdn加速三种。<a href="https://baike.baidu.com/item/%E5%9B%BE%E5%BA%8A/10721348?fr=aladdin">百度百科</a></p><p>简单来说上传图片后会得到图片的链接，这样就可以通过此链接来查看图片，方便迁移。</p><h2 id="PicGo"><a href="#PicGo" class="headerlink" title="PicGo"></a>PicGo</h2><p><a href="https://molunerfinn.com/PicGo/">PicGo</a> 是一款图片上传的工具, 支持SM.MS图床，微博图床，七牛图床，腾讯云COS，阿里云OSS，Imgur，又拍云，<code>GitHub</code>等图床。我选择的是集成<code>GitHub</code>。</p><p>可以使用此工具将本地的图片文件上传到<code>GitHub</code>个人仓库中，方便快捷，markdown中图片不用再使用本地图片链接。<strong>需要注意的是隐私性问题，GitHub中你公开的仓库别人是可以访问的，也就是你的图片别人是可以看到的。</strong></p><p>安装完成后主界面是这样的。</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/fluetty/clouding/main/data/image-20201022155435359.png" alt="image-20201022155435359"></p><h2 id="GitHUb新建仓库"><a href="#GitHUb新建仓库" class="headerlink" title="GitHUb新建仓库"></a>GitHUb新建仓库</h2><ol><li>注册GitHub账号，有账号则直接登录。点击右上角头像旁加号，新建仓库。</li></ol><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/fluetty/clouding/main/data/image-20201022155606104.png" alt="image-20201022155606104"></p><p>2.设置仓库的名字，注意要设置成public</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/fluetty/clouding/main/data/image-20201022155657318.png" alt="image-20201022155657318"></p><h2 id="生成密钥"><a href="#生成密钥" class="headerlink" title="生成密钥"></a>生成密钥</h2><ol><li>点击右上角头像，选择settings</li></ol><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/fluetty/clouding/main/data/image-20201022155910865.png" alt="image-20201022155910865"></p><p>2.选择左侧 Developer settings</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/fluetty/clouding/main/data/image-20201022160948997.png" alt="image-20201022160948997"></p><p>3.生成新的token,note随意填写。</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/fluetty/clouding/main/data/image-20201022161231153.png" alt="image-20201022161231153"></p><p>4.复制保存新生成的token串</p><h2 id="PicGo配置图床"><a href="#PicGo配置图床" class="headerlink" title="PicGo配置图床"></a>PicGo配置图床</h2><ol><li><p>配置时候需要注意，分支名现在为main,不再是mater了。</p></li><li><p>指定存储路径，会在仓库下建个同名的文件夹。</p></li><li><p>自定义域名的作用是在上传图片后成功后，<code>PicGo</code>会将“自定义域名+上传的图片名”生成的访问链接，放到剪切板上<a href="https://raw.githubusercontent.com/%E7%94%A8%E6%88%B7%E5%90%8D/%E4%BB%93%E5%BA%93%E5%90%8D/main%EF%BC%8C%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9F%9F%E5%90%8D%E9%9C%80%E8%A6%81%E6%8C%89%E7%85%A7%E8%BF%99%E6%A0%B7%E5%8E%BB%E5%A1%AB%E5%86%99">https://raw.githubusercontent.com/用户名/仓库名/main，自定义域名需要按照这样去填写</a></p></li><li><p>通过上传区可以测试上传，成功后GitHub中会有新建的文件夹和图片，PicGo相册中可以看到上传的图片。</p></li></ol><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/fluetty/clouding/main/data/image-20201022161414837.png" alt="image-20201022161414837"></p><h2 id="Typora集成PicGo"><a href="#Typora集成PicGo" class="headerlink" title="Typora集成PicGo"></a>Typora集成PicGo</h2><p><a href="https://typora.io/">Typora</a> 是一款支持实时预览的Markdown 文本编辑器。非常好用，界面设计也挺有高级感。</p><ol><li>左上角 文件– 偏好设置 按照如图配置。配置后测试验证图片上传即可</li></ol><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/fluetty/clouding/main/data/image-20201022161854170.png" alt="image-20201022161854170"></p><ol start="2"><li>使用Typora编辑文件时，拖拽图片进来，截图后复制黏贴图片都可。使用快捷键 <strong>Ctrl + Shift + I</strong>，可以调出插入图片的功能。</li></ol>]]></content>
      
      
      <categories>
          
          <category> blog </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>开源API网关Kong笔记</title>
      <link href="2020/11/03/%E5%BC%80%E6%BA%90API%E7%BD%91%E5%85%B3Kong%E7%AC%94%E8%AE%B0/"/>
      <url>2020/11/03/%E5%BC%80%E6%BA%90API%E7%BD%91%E5%85%B3Kong%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是API网关？"><a href="#什么是API网关？" class="headerlink" title="什么是API网关？"></a>什么是API网关？</h2><p>API 网关并非一个新兴的概念，在十几年前就已经存在了，它的作用主要是作为流量的入口，统一的处理和业务相关的请求，让请求更加安全、快速和准确的得到处理。</p><p>它有以下传统的功能：</p><ol><li><p>反向代理和负载均衡，这和 Nginx 的定位和功能是一致的；</p></li><li><p>动态上游、动态 SSL 证书和动态限流限速等运行时的动态功能，这是开源版本 Nginx并不具备的功能；</p></li><li><p>上游的主动和被动健康检查，以及服务熔断；</p></li><li><p>在 API 网关的基础之上进行扩展，成为全生命周期的 API 管理平台。</p></li></ol><h2 id="Kong简介"><a href="#Kong简介" class="headerlink" title="Kong简介"></a>Kong简介</h2><p>Kong基于<strong>Nginx</strong>，利用了其稳定性和高效率。Kong是Mashape开源的高性能高可用API网关和API服务管理层。</p><p>Kong是一个在Nginx中运行的Lua应用程序，并且可以通过lua-nginx模块实现。Kong不是用这个模块编译Nginx，而是与OpenResty一起分发，OpenResty已经包含了lua-nginx-module。OpenResty不是Nginx的分支，而是一组扩展其功能的模块。Kong基于OpenResty，进行API管理，并提供了插件实现API的AOP。</p><p> 这为可插拔架构奠定了基础，可以在运行时启用和执行Lua脚本（称为“插件”）。 因此，我们认为Kong是微服务架构的典范：它的核心是<strong>实现数据库抽象，路由和插件管理</strong>。 插件可以存在于单独的代码库中，并且可以在几行代码中注入到请求生命周期的任何位置。</p><p>目前互联网后台架构一般是采用微服务，或者类似微服务的形式，应用的请求通常需要访问多个后台系统。如果让每一个后台系统都实现鉴权、限流、<a href="https://cloud.tencent.com/product/clb?from=10680">负载均衡</a>、审计等基础功能是不合适的，通用的做法是把这些功能抽离出来放到网关层。Kong是目前最流行的网关平台。</p><h2 id="Kong的基本架构"><a href="#Kong的基本架构" class="headerlink" title="Kong的基本架构"></a>Kong的基本架构</h2><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/fluetty/clouding/main/data/view.png" alt="view"></p><h3 id="Kong-默认绑定4个端口"><a href="#Kong-默认绑定4个端口" class="headerlink" title="Kong 默认绑定4个端口"></a>Kong 默认绑定4个端口</h3><ul><li>:8000 用来接受用户的HTTP请求，并转发到后台系统</li><li>:8443 用来接受用户的HTTPS请求，并转发到后台系统</li><li>:8001 通过HTTP协议提供管理功能的API （Admin API）</li><li>:8444 通过HTTPS协议提供管理功能的API</li></ul><p>这些端口可以在**/etc/kong/kong.conf**中修改，当然我们可以把Admin API作为一个服务通过kong的网关暴露出去。</p><h3 id="Kong-主要有三个组件"><a href="#Kong-主要有三个组件" class="headerlink" title="Kong 主要有三个组件"></a>Kong 主要有三个组件</h3><ul><li>Kong Server ：基于nginx的服务器，用来接收 API 请求。</li><li>Apache Cassandra/PostgreSQL：用来存储操作数据。</li><li>Kong dashboard：官方推荐 UI 管理工具，当然，也可以使用 restfull 方式管理 admin api。</li></ul><p>Kong 采用插件机制进行功能定制，插件集（可以是 0 或 N 个）在 API 请求响应循环的生命周期中被执行。<strong>插件使用 Lua 编写</strong>，基础功能包括：HTTP 基本认证、密钥认证、CORS（Cross-Origin Resource Sharing，跨域资源共享）、TCP、UDP、文件日志、API 请求限流、请求转发以及 Nginx 监控等。</p><h3 id="Kong-网关具有以下的特性"><a href="#Kong-网关具有以下的特性" class="headerlink" title="Kong 网关具有以下的特性"></a>Kong 网关具有以下的特性</h3><ul><li>可扩展性: 通过简单地添加更多的服务器，可以轻松地进行横向扩展，这意味着您的平台可以在一个较低负载的情况下处理任何请求；</li><li>模块化: 可以通过添加新的插件进行扩展，这些插件可以通过RESTful Admin API轻松配置；</li><li>在任何基础架构上运行: Kong 网关可以在任何地方都能运行。可以在云或内部网络环境中部署 Kong，包括单个或多个数据中心设置，以及 public，private 或 invite-only APIs。</li></ul><h2 id="相关术语"><a href="#相关术语" class="headerlink" title="相关术语"></a>相关术语</h2><ul><li><p>Route：是请求的转发规则，按照Hostname和PATH，将请求转发给Service。<strong>路由是定义对这个服务暴露给客户端的请求路径及请求方式。服务与路由是1对多的关系，一个服务可以以多种路由方式暴露给前端访问，该服务对应的上游服务就是1个API</strong>。  告诉Kong怎么把网关收到的请求发送到某个特定的后台服务。</p></li><li><p>Services：是多个Upstream的集合，是Route的转发目标。<strong>不要把Services当作后端的具体API，要把它当作一个大的服务，该服务下面有多个API（endpoint or route）</strong>。</p></li><li><p>Consumer：是API的用户，里面记录用户的一些信息。</p></li><li><p>Plugin：是插件，plugin可以是全局的，绑定到Service，绑定到Router，绑定到Consumer。</p></li><li><p>Certificate：是https证书。</p></li><li><p>Sni：是域名与Certificate的绑定，指定了一个域名对应的https证书。</p></li><li><p>Upstream：表示虚拟主机名，可用于通过多个服务（目标）对传入请求进行负载均衡。例如：service.v1.xyz 为Service对象命名的上游host是service.v1.xyz对此服务的请求将代理到上游定义的目标。</p></li><li><p>Target：目标IP地址/主机名，其端口表示后端服务的实例,是最终处理请求的Backend服务。每个上游都可以有多个target,并且可以动态添加Target。 由于Upstream维护Target的更改历史记录，因此无法删除或者修改Target。要禁用目标，请发布一个新的Target weight=0,或者使用DELETE来完成相同的操作。</p></li></ul><h2 id="Kong插件的格式"><a href="#Kong插件的格式" class="headerlink" title="Kong插件的格式"></a>Kong插件的格式</h2><p>一个完整的插件目录结构应该像下面这样：</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/fluetty/clouding/main/data/image-20200831151628965.png" alt="image-20200831151628965"></p><p>各个模块的功能：</p><table><thead><tr><th>模块名</th><th>描述</th><th>是否必需</th></tr></thead><tbody><tr><td>api.lua</td><td>插件需要向 Admin API 暴露接口时使用</td><td>N</td></tr><tr><td>daos.lua</td><td>数据层相关，当插件需要访问数据库时配置</td><td>N</td></tr><tr><td>handler.lua</td><td>插件的主要逻辑，这个将会被 Kong 在不同阶段执行其对应的 handler</td><td>Y</td></tr><tr><td>migrations / *.lua</td><td>插件依赖的数据表结构，启用了 daos.lua 时需要定义</td><td>N</td></tr><tr><td>schema.lua</td><td>插件的配置参数定义，主要用于 Kong 参数验证</td><td>Y</td></tr></tbody></table><p>其中 handler.lua 和 schema.lua 是必需的（rbac_charing下也是只有这两个），上面提到的插件需要暴露出来的方法就定义在 handler.lua 中。</p><p><strong>kong插件主要有三个文件</strong>：</p><p>handler.lua 是包含插件逻辑处理相关代码。 schema.lua 包含插件的配置文件。 rockspec 文件是通过luarock安装时用的配置文件。</p><p>逻辑处理的代码根据openResty的不同处理阶段分成了不同的函数，根据插件的功能只需要在不同的函数中添加自己的业务逻辑。</p><h2 id="跟路径（path）有关的参数"><a href="#跟路径（path）有关的参数" class="headerlink" title="跟路径（path）有关的参数"></a>跟路径（path）有关的参数</h2><ol><li> route中的paths参数，表示符合这些请求路径要发到route对应的service中</li><li> route中的strip_path 参数，决定kong转发给后端的时候是否保留源请求用于路由匹配的路径</li><li>service中的path参数，默认为null，kong转发请求时会把这个作为前缀加上</li></ol><p>假设网关以<code>/api</code>为路由把请求转发给nodedemo（即<code>route.paths = [&#39;/api&#39;]</code>)，它们的组合关系如下：</p><table><thead><tr><th>strip_path</th><th>service.path</th><th>请求地址</th><th>网关实际访问后端地址</th></tr></thead><tbody><tr><td>true</td><td>null 或者 /</td><td><a href="http://127.0.0.1/api/demo">http://127.0.0.1/api/demo</a></td><td><a href="http://127.0.0.1:8080/demo">http://127.0.0.1:8080/demo</a></td></tr><tr><td>true</td><td>/test</td><td><a href="http://127.0.0.1/api/demo">http://127.0.0.1/api/demo</a></td><td><a href="http://127.0.0.1:8080/test/demo">http://127.0.0.1:8080/test/demo</a></td></tr><tr><td>false</td><td>null 或者 /</td><td><a href="http://127.0.0.1/api/demo">http://127.0.0.1/api/demo</a></td><td><a href="http://127.0.0.1:8080/api/demo">http://127.0.0.1:8080/api/demo</a></td></tr><tr><td>false</td><td>/test</td><td><a href="http://127.0.0.1/api/demo">http://127.0.0.1/api/demo</a></td><td><a href="http://127.0.0.1:8080/test/api/demo">http://127.0.0.1:8080/test/api/demo</a></td></tr></tbody></table><p>以最后一行为例，相当于访问 <a href="http://127.0.0.1/api/demo">http://127.0.0.1/api/demo</a> 时，实际访问的是<code>/test/api/demo</code>，也就是把 service.path (/test）跟实际请求的路径(/api/demo)拼接起来发给后端。</p><p>配置route时候：这里的 Path 就是具体业务API的路径（endpoint）。Hosts不设置会默认采用Services里的Host，但是一旦设置了，客户端请求该route的时候必须带上设置的host，且必须一致。</p><p>如果Strip path设置为YES，这里的 Path 可以加一个前缀，如：/passport/users，但最终会映射到后端真实的API /users。Kong转发到后端服务的时候会把前缀/passport部分去掉。客户端调用API必须和Routes里的Path一致才行（/passport/users），否则会得到404，无法匹配。用户的请求是先匹配route，然后转发到service。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="http://blog.didispace.com/hzf-ms-apigateway-2/">微服务与API 网关（下）- Kong能为我们做什么？</a></p><p><a href="https://segmentfault.com/a/1190000019857235">企业级API网关Kong系列</a></p><p><a href="https://ms2008.github.io/2018/05/14/kong-plugin-load/">Kong 插件加载机制概述</a></p><p><a href="https://www.cnblogs.com/SummerinShire/p/6925308.html">Kong-负载均衡参考</a></p><p><a href="https://www.jianshu.com/p/b65259021d2b">Kong负载均衡的实现</a></p><p><a href="%5Bhttps://www.lijiaocn.com/%E9%A1%B9%E7%9B%AE/2018/11/20/kong-features-16-work-process.html#%E4%BB%8E-upstream-%E5%88%B0-target%5D(https://www.lijiaocn.com/%E9%A1%B9%E7%9B%AE/2018/11/20/kong-features-16-work-process.html#%E4%BB%8E-upstream-%E5%88%B0-target)">upstream和target详解</a></p>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> learn </tag>
            
            <tag> kong </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker常用指令</title>
      <link href="2020/11/02/Docker%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/"/>
      <url>2020/11/02/Docker%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<p><strong>简介：</strong>Docker 是一个开源的应用容器引擎，基于 Go 语言开发，Docker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的系统。</p><p>docker本质就是宿主机的一个进程，docker是通过namespace实现资源隔离，通过cgroup实现资源限制，通过写时复制技术（copy-on-write）实现了高效的文件操作（类似虚拟机的磁盘比如分配500g并不是实际占用物理磁盘500g）</p><h2 id="Docker-三个核心概念"><a href="#Docker-三个核心概念" class="headerlink" title="Docker 三个核心概念"></a>Docker 三个核心概念</h2><h3 id="镜像（Image）"><a href="#镜像（Image）" class="headerlink" title="镜像（Image）"></a>镜像（Image）</h3><p>是一个包含有文件系统的面向 Docker 引擎的只读模板。任何应用程序运行都需要环境，而镜像就是用来提供这种运行环境的。例如一个 Ubuntu 镜像就是一个包含 Ubuntu 操作系统环境的模板。Docker 把应用程序及其依赖，打包在 image 文件里面。只有通过这个文件，才能生成 Docker 容器。image 文件可以看作是容器的模板。Docker 根据 image 文件生成容器的实例。同一个 image 文件，可以生成多个同时运行的容器实例。</p><h3 id="容器（Container）"><a href="#容器（Container）" class="headerlink" title="容器（Container）"></a>容器（Container）</h3><p>类似于一个轻量级的沙盒，可以将其看作一个极简的 Linux 系统环境（包括 root 权限、进程空间、用户空间和网络空间等），以及运行在其中的应用程序。Docker 引擎利用容器来运行、隔离各个应用。</p><p>容器是镜像创建的应用实例，可以创建、启动、停止、删除容器，各个容器之间是是相互隔离的，互不影响。</p><p>注意：镜像本身是只读的，容器从镜像启动时，Docker 在镜像的上层创建一个可写层，镜像本身不变。</p><h3 id="仓库（Repository）"><a href="#仓库（Repository）" class="headerlink" title="仓库（Repository）"></a>仓库（Repository）</h3><p>镜像仓库，是 Docker 用来集中存放镜像文件的地方。</p><h2 id="Docker常用命令"><a href="#Docker常用命令" class="headerlink" title="Docker常用命令"></a>Docker常用命令</h2><p>Docker 的常用命令一般分为：镜像管理、容器管理。</p><h3 id="查看-Docker-版本"><a href="#查看-Docker-版本" class="headerlink" title="查看 Docker 版本"></a>查看 Docker 版本</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker version</span><br></pre></td></tr></table></figure><h3 id="列出常用命令"><a href="#列出常用命令" class="headerlink" title="列出常用命令"></a>列出常用命令</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker --help</span><br></pre></td></tr></table></figure><h3 id="镜像管理命令"><a href="#镜像管理命令" class="headerlink" title="镜像管理命令"></a>镜像管理命令</h3><p>下面使用 busybox 软件作为示例，busybox 软件是一个集成了非常多最常用的 Linux 命令和工具的软件集合。</p><h4 id="查看所有镜像"><a href="#查看所有镜像" class="headerlink" title="查看所有镜像"></a>查看所有镜像</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker images</span><br><span class="line">docker images ls</span><br></pre></td></tr></table></figure><ul><li><p>REPOSITORY：镜像来自哪个仓库</p></li><li><p>TAG：镜像的标签信息，版本之类的信息</p></li><li><p>IMAGE ID：镜像创建时的id</p></li><li><p>CREATED：镜像创建的时间</p></li><li><p>SIZE：镜像文件大小</p></li></ul><h4 id="下载软件镜像"><a href="#下载软件镜像" class="headerlink" title="下载软件镜像"></a>下载软件镜像</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker pull busybox:latest</span><br></pre></td></tr></table></figure><p>备注：latest 表示使用 busybox 软件的最新版本，所以软件默认下载都是 latest 版本。</p><h4 id="导出镜像"><a href="#导出镜像" class="headerlink" title="导出镜像"></a>导出镜像</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker save busybox &gt; busybox.tar</span><br></pre></td></tr></table></figure><p>备注：把 busybox 镜像导出为 busybox.tar 文件，可以把 busybox.tar 文件复制到别的操作系统上使用，免除下载时网络慢的问题。</p><h4 id="删除镜像"><a href="#删除镜像" class="headerlink" title="删除镜像"></a>删除镜像</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker rmi busybox:latest</span><br></pre></td></tr></table></figure><p>备注：镜像一般都会根据版本打包，如果有下载一个软件的多个版本就需要指定具体版本信息。如 busybox:1.26 就会删除 busybox 软件的 1.26 版本的镜像，不会删除latest 版本的镜像。</p><h4 id="导入镜像"><a href="#导入镜像" class="headerlink" title="导入镜像"></a>导入镜像</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker load &lt; busybox.tar</span><br></pre></td></tr></table></figure><p>备注：使用导出命令导出的镜像，可以通过此命令导入到没有下载此软件的操作系统，方便网络条件差的情况使用。</p><h4 id="更改镜像名"><a href="#更改镜像名" class="headerlink" title="更改镜像名"></a>更改镜像名</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker tag busybox:latest busybox:test</span><br></pre></td></tr></table></figure><p>备注：busybox:latest原镜像名，busybox:test要改成的镜像名</p><h3 id="容器管理命令"><a href="#容器管理命令" class="headerlink" title="容器管理命令"></a><strong>容器管理命令</strong></h3><h4 id="运行容器"><a href="#运行容器" class="headerlink" title="运行容器"></a>运行容器</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d --name=busybox busybox:latest ping 114.114.114.114</span><br><span class="line">docker container run -p 8000:3000 -it demo:0.0.1 /bin/bash</span><br></pre></td></tr></table></figure><ul><li><code>run</code>：run参数代表启动容器</li><li><code>-d</code>：以后台daemon的方式运行</li><li><code>--name</code>：指定一个容器的名字，此后操作都需要使用这个名字来定位容器。</li><li><code>busybox:latest</code>：容器所使用的镜像名字</li><li><code>ping 114.114.114.114</code>：启动容器执行的命令</li></ul><h4 id="查看运行的容器"><a href="#查看运行的容器" class="headerlink" title="查看运行的容器"></a>查看运行的容器</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker ps</span><br><span class="line">docker container ls</span><br></pre></td></tr></table></figure><h4 id="查看所有容器"><a href="#查看所有容器" class="headerlink" title="查看所有容器"></a>查看所有容器</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker ps -a</span><br></pre></td></tr></table></figure><ul><li><code>CONTAINER ID</code>：容器启动的id</li><li><code>IMAGE</code>：使用哪个镜像启动的容器</li><li><code>COMMAND</code>：启动容器的命令</li><li><code>CREATED</code>：创建容器的时间</li><li><code>STATUS</code>：容器启动时间</li><li><code>PORTS</code>：容器映射到宿主机的端口</li><li><code>NAMES</code>：容器启动的名字</li></ul><h4 id="启动容器"><a href="#启动容器" class="headerlink" title="启动容器"></a>启动容器</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker start busybox</span><br></pre></td></tr></table></figure><h4 id="重新启动容器"><a href="#重新启动容器" class="headerlink" title="重新启动容器"></a>重新启动容器</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker restart busybox</span><br></pre></td></tr></table></figure><h4 id="停止容器"><a href="#停止容器" class="headerlink" title="停止容器"></a>停止容器</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker stop busybox</span><br></pre></td></tr></table></figure><h4 id="杀死容器"><a href="#杀死容器" class="headerlink" title="杀死容器"></a>杀死容器</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker kill busybox</span><br></pre></td></tr></table></figure><h4 id="清理所有终止状态的容器"><a href="#清理所有终止状态的容器" class="headerlink" title="清理所有终止状态的容器"></a>清理所有终止状态的容器</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker container prune</span><br></pre></td></tr></table></figure><h4 id="列出容器映射的端口"><a href="#列出容器映射的端口" class="headerlink" title="列出容器映射的端口"></a>列出容器映射的端口</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker port busybox</span><br></pre></td></tr></table></figure><h4 id="查看容器内部运行的进程"><a href="#查看容器内部运行的进程" class="headerlink" title="查看容器内部运行的进程"></a>查看容器内部运行的进程</h4><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">docker top busybox</span><br></pre></td></tr></table></figure><h4 id="查看容器或镜像底层信息"><a href="#查看容器或镜像底层信息" class="headerlink" title="查看容器或镜像底层信息"></a>查看容器或镜像底层信息</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker inspect busybox</span><br></pre></td></tr></table></figure><h4 id="删除运行中的容器"><a href="#删除运行中的容器" class="headerlink" title="删除运行中的容器"></a>删除运行中的容器</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker rm -f busybox</span><br></pre></td></tr></table></figure><h4 id="执行容器内命令"><a href="#执行容器内命令" class="headerlink" title="执行容器内命令"></a>执行容器内命令</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker exec -it busybox ls</span><br><span class="line">docker exec -it busybox /bin/bash</span><br></pre></td></tr></table></figure><p>备注：-it 交互终端</p><h4 id="复制容器内文件"><a href="#复制容器内文件" class="headerlink" title="复制容器内文件"></a>复制容器内文件</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker cp busybox:/etc/hosts hosts</span><br></pre></td></tr></table></figure><h4 id="查看容器日志"><a href="#查看容器日志" class="headerlink" title="查看容器日志"></a>查看容器日志</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker logs -f busybox</span><br><span class="line">docker logs [OPTIONS] busybox</span><br></pre></td></tr></table></figure><p>OPTIONS说明：</p><ul><li><code>-f</code>：跟踪日志输出</li><li><code>--since</code>：显示某个开始时间的所有日志</li><li><code>-t</code>：显示时间戳</li><li><code>--tail</code>：仅列出最新N条容器日志</li></ul><h2 id="docker-compose"><a href="#docker-compose" class="headerlink" title="docker-compose"></a>docker-compose</h2><p>Compose 是用于定义和运行多容器 Docker 应用程序的工具。通过 Compose，可以使用 YML 文件来配置应用程序需要的所有服务。然后使用一个命令，就可以从 YML 文件配置中创建并启动所有服务。  compose命令大多依赖于yml文件，默认使用当前目录下的“docker-compose.yml“，也可以通过－f指定。</p><h4 id="构建建启动nignx容器"><a href="#构建建启动nignx容器" class="headerlink" title="构建建启动nignx容器"></a>构建建启动nignx容器</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker-compose up -d nginx          </span><br></pre></td></tr></table></figure><h4 id="进入到nginx容器中"><a href="#进入到nginx容器中" class="headerlink" title="进入到nginx容器中"></a>进入到nginx容器中</h4> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker-compose exec nginx bash     </span><br></pre></td></tr></table></figure><h4 id="删除所有nginx容器-镜像"><a href="#删除所有nginx容器-镜像" class="headerlink" title="删除所有nginx容器,镜像"></a>删除所有nginx容器,镜像</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker-compose down         </span><br></pre></td></tr></table></figure><h4 id="重新启动nginx容器"><a href="#重新启动nginx容器" class="headerlink" title="重新启动nginx容器"></a>重新启动nginx容器</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker-compose restart nginx</span><br></pre></td></tr></table></figure><h4 id="在php-fpm中不启动关联容器，并容器执行php-v-执行完成后删除容器"><a href="#在php-fpm中不启动关联容器，并容器执行php-v-执行完成后删除容器" class="headerlink" title="在php-fpm中不启动关联容器，并容器执行php -v 执行完成后删除容器"></a>在php-fpm中不启动关联容器，并容器执行php -v 执行完成后删除容器</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker-compose run --no-deps --rm php-fpm php -v </span><br></pre></td></tr></table></figure><h4 id="构建镜像"><a href="#构建镜像" class="headerlink" title="构建镜像"></a>构建镜像</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker-compose build nginx  </span><br></pre></td></tr></table></figure><h4 id="不带缓存的构建"><a href="#不带缓存的构建" class="headerlink" title="不带缓存的构建"></a>不带缓存的构建</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker-compose build --no-cache nginx </span><br></pre></td></tr></table></figure><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://www.cnblogs.com/edisonchou/p/dockerfile_inside_introduction.html">你必须知道的Dockerfile</a></p><p><a href="https://www.cnblogs.com/moxiaoan/p/9299404.html">Docker-compose常用命令</a></p>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
            <tag> learn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nginx学习记录</title>
      <link href="2020/10/20/nginx%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
      <url>2020/10/20/nginx%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h2 id="Nginx-简介"><a href="#Nginx-简介" class="headerlink" title="Nginx 简介"></a>Nginx 简介</h2><p>Nginx是一款免费开源、轻量级的高性能 Web服务器、反向代理服务器，它高并发性能很好，官方测试能够支撑 5 万的并发量；运行时内存和 CPU 占用率低，配置简单，容易上手，而且运行非常稳定。由于它的内存占用少，启动极快，高并发能力强，在互联网项目中广泛应用。</p><p>Nginx是由俄罗斯人Igor Sysoev 设计开发的，第一次公开发布在2004年10月4日。 <a href="http://nginx.org/">官方网站</a></p><h2 id="Nginx的常用功能"><a href="#Nginx的常用功能" class="headerlink" title="Nginx的常用功能"></a>Nginx的常用功能</h2><p>Nginx的功能特别多，详见<a href="http://nginx.org/en/">官网介绍</a> ，比较常用的功能有以下几个。</p><h3 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h3><p>这是 Nginx 服务器作为 WEB 服务器的主要功能之一，客户端向服务器发送请求时，会首先经过 Nginx 服务器，由服务器将请求分发到相应的 WEB 服务器。<strong>正向代理是代理客户端，而反向代理则是代理服务器</strong>，Nginx 在提供反向代理服务方面，通过使用正则表达式进行相关配置，采取不同的转发策略，配置相当灵活，而且在配置后端转发请求时，完全不用关心网络环境如何，可以指定任意的IP地址和端口号，或其他类型的连接、请求等。</p><h3 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h3><p>这也是 Nginx 最常用的功能之一，负载均衡，<strong>一方面是将单一的重负载分担到多个网络节点上做并行处理</strong>，每个节点处理结束后将结果汇总返回给用户，这样可以大幅度提高网络系统的处理能力；<strong>另一方面将大量的前端并发请求或数据流量分担到多个后端网络节点分别处理</strong>，这样可以有效减少前端用户等待相应的时间。而 Nginx 负载均衡都是属于后一方面，主要是<strong>对大量前端访问或流量进行分流</strong>，以保证前端用户访问效率，并可以减少后端服务器处理压力。</p><h3 id="Web缓存"><a href="#Web缓存" class="headerlink" title="Web缓存"></a>Web缓存</h3><p>缓存，是Nginx提供的，可以加快访问速度的机制，说白了，在配置上就是一个开启，同时指定目录，让缓存可以存储到磁盘上。在很多优秀的网站中，Nginx 可以作为前置缓存服务器，它被用于缓存前端请求，从而提高 Web服务器的性能。Nginx 会对用户已经访问过的内容在服务器本地建立副本，这样在一段时间内再次访问该数据，就不需要通过 Nginx 服务器向后端发出请求。减轻网络拥堵，减小数据传输延时，提高用户访问速度。</p><h2 id="Nginx的安装"><a href="#Nginx的安装" class="headerlink" title="Nginx的安装"></a>Nginx的安装</h2><p>​                参考：<a href="https://www.cnblogs.com/taiyonghai/p/6728707.html">Nginx Linux详细安装部署教程</a></p><p>​                          <a href="https://www.cnblogs.com/taiyonghai/p/9402734.html">Nginx Windows详细安装部署教程</a></p><h3 id="启动-Nginx"><a href="#启动-Nginx" class="headerlink" title="启动 Nginx"></a>启动 Nginx</h3><p>window在解压的nginx目录下 打开cmd.exe</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">start nginx</span><br></pre></td></tr></table></figure><h3 id="查看服务是否启动"><a href="#查看服务是否启动" class="headerlink" title="查看服务是否启动"></a>查看服务是否启动</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ps -ef | grep nginx</span><br></pre></td></tr></table></figure><h3 id="重启Nginx"><a href="#重启Nginx" class="headerlink" title="重启Nginx"></a>重启Nginx</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nginx -s reload</span><br></pre></td></tr></table></figure><h3 id="关闭Nginx"><a href="#关闭Nginx" class="headerlink" title="关闭Nginx"></a>关闭Nginx</h3><p>先查出nginx进程id再使用kill命令强制杀掉进程</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nginx -s stop</span><br></pre></td></tr></table></figure><p>允许 nginx 服务将当前正在处理的网络请求处理完成，但不再接收新的请求，之后关闭连接，停止工作。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nginx -s quit</span><br></pre></td></tr></table></figure><h3 id="检查配置文件语法"><a href="#检查配置文件语法" class="headerlink" title="检查配置文件语法"></a>检查配置文件语法</h3><p>指定要检查的文件</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nginx -t -c nginx/conf/nginx/conf</span><br></pre></td></tr></table></figure><p>默认检查nginx.conf配置文件</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nginx -t</span><br></pre></td></tr></table></figure><h2 id="Nginx-conf配置文件"><a href="#Nginx-conf配置文件" class="headerlink" title="Nginx.conf配置文件"></a>Nginx.conf配置文件</h2><ul><li>1、<strong>全局块</strong>：配置影响nginx全局的指令。一般有运行nginx服务器的用户组，nginx进程pid存放路径，日志存放路径，配置文件引入，允许生成worker process数等。</li><li>2、<strong>events块</strong>：配置影响nginx服务器或与用户的网络连接。有每个进程的最大连接数，选取哪种事件驱动模型处理连接请求，是否允许同时接受多个网路连接，开启多个网络连接序列化等。</li><li>3、<strong>http块</strong>：可以嵌套多个server，配置代理，缓存，日志定义等绝大多数功能和第三方模块的配置。如文件引入，mime-type定义，日志自定义，是否使用sendfile传输文件，连接超时时间，单连接请求数等。</li><li>4、<strong>server块</strong>：配置虚拟主机的相关参数，一个http中可以有多个server。</li><li>5、<strong>location块</strong>：配置请求的路由，以及各种页面的处理情况。</li></ul><p>nginx配置文件详解</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#user  nobody;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#==工作进程数，一般设置为cpu核心数</span></span><br><span class="line">worker_processes  <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">#error_log  logs/error.log;</span></span><br><span class="line"><span class="comment">#error_log  logs/error.log  notice;</span></span><br><span class="line"><span class="comment">#error_log  logs/error.log  info;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#pid        logs/nginx.pid;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">events &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">#==最大连接数，一般设置为cpu*2048</span></span><br><span class="line">    worker_connections  <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line">    include       mime.types;</span><br><span class="line">    default_type  application/octet-stream;</span><br><span class="line"></span><br><span class="line">    <span class="comment">#log_format  main  &#x27;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#x27;</span></span><br><span class="line">    <span class="comment">#                  &#x27;$status $body_bytes_sent &quot;$http_referer&quot; &#x27;</span></span><br><span class="line">    <span class="comment">#                  &#x27;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#x27;;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">#access_log  logs/access.log  main;</span></span><br><span class="line">    </span><br><span class="line">    sendfile        on;</span><br><span class="line">    <span class="comment">#tcp_nopush     on;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">#keepalive_timeout  0;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">#==客户端链接超时时间</span></span><br><span class="line">    keepalive_timeout  <span class="number">65</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#gzip  on;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">#当配置多个server节点时，默认server names的缓存区大小就不够了，需要手动设置大一点</span></span><br><span class="line">    server_names_hash_bucket_size <span class="number">512</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#server表示虚拟主机可以理解为一个站点，可以配置多个server节点搭建多个站点</span></span><br><span class="line">    <span class="comment">#每一个请求进来确定使用哪个server由server_name确定</span></span><br><span class="line">    server &#123;</span><br><span class="line">        <span class="comment">#站点监听端口</span></span><br><span class="line">        listen       <span class="number">8800</span>;</span><br><span class="line">        <span class="comment">#站点访问域名</span></span><br><span class="line">        server_name  localhost;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">#编码格式，避免url参数乱码</span></span><br><span class="line">        charset utf<span class="number">-8</span>;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">#access_log  logs/host.access.log  main;</span></span><br><span class="line">    </span><br><span class="line">        <span class="comment">#location用来匹配同一域名下多个URI的访问规则</span></span><br><span class="line">        <span class="comment">#比如动态资源如何跳转，静态资源如何跳转等</span></span><br><span class="line">        <span class="comment">#location后面跟着的/代表匹配规则</span></span><br><span class="line">        location / &#123;</span><br><span class="line">            <span class="comment">#站点根目录，可以是相对路径，也可以使绝对路径</span></span><br><span class="line">            root   html;</span><br><span class="line">            <span class="comment">#默认主页</span></span><br><span class="line">            index  index.html index.htm;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">#转发后端站点地址，一般用于做软负载，轮询后端服务器</span></span><br><span class="line">            <span class="comment">#proxy_pass http://10.11.12.237:8080;</span></span><br><span class="line">    </span><br><span class="line">            <span class="comment">#拒绝请求，返回403，一般用于某些目录禁止访问</span></span><br><span class="line">            <span class="comment">#deny all;</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">#允许请求</span></span><br><span class="line">            <span class="comment">#allow all;</span></span><br><span class="line">            </span><br><span class="line">            add_header <span class="string">&#x27;Access-Control-Allow-Origin&#x27;</span> <span class="string">&#x27;*&#x27;</span>;</span><br><span class="line">            add_header <span class="string">&#x27;Access-Control-Allow-Credentials&#x27;</span> <span class="string">&#x27;true&#x27;</span>;</span><br><span class="line">            add_header <span class="string">&#x27;Access-Control-Allow-Methods&#x27;</span> <span class="string">&#x27;GET, POST, OPTIONS&#x27;</span>;</span><br><span class="line">            add_header <span class="string">&#x27;Access-Control-Allow-Headers&#x27;</span> <span class="string">&#x27;DNT,X-CustomHeader,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type&#x27;</span>;</span><br><span class="line">            <span class="comment">#重新定义或者添加发往后端服务器的请求头</span></span><br><span class="line">            <span class="comment">#给请求头中添加客户请求主机名</span></span><br><span class="line">            proxy_set_header Host $host;</span><br><span class="line">            <span class="comment">#给请求头中添加客户端IP</span></span><br><span class="line">            proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">            <span class="comment">#将$remote_addr变量值添加在客户端“X-Forwarded-For”请求头的后面，并以逗号分隔。 如果客户端请求未携带“X-Forwarded-For”请求头，$proxy_add_x_forwarded_for变量值将与$remote_addr变量相同  </span></span><br><span class="line">            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">            <span class="comment">#给请求头中添加客户端的Cookie</span></span><br><span class="line">            proxy_set_header Cookie $http_cookie;</span><br><span class="line">            <span class="comment">#将使用代理服务器的主域名和端口号来替换。如果端口是80，可以不加。</span></span><br><span class="line">            proxy_redirect off;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">#浏览器对 Cookie 有很多限制，如果 Cookie 的 Domain 部分与当前页面的 Domain 不匹配就无法写入。</span></span><br><span class="line">            <span class="comment">#所以如果请求 A 域名，服务器 proxy_pass 到 B 域名，然后 B 服务器输出 Domian=B 的 Cookie，</span></span><br><span class="line">            <span class="comment">#前端的页面依然停留在 A 域名上，于是浏览器就无法将 Cookie 写入。</span></span><br><span class="line"></span><br><span class="line">　　         <span class="comment">#不仅是域名，浏览器对 Path 也有限制。我们经常会 proxy_pass 到目标服务器的某个 Path 下，</span></span><br><span class="line">            <span class="comment">#不把这个 Path 暴露给浏览器。这时候如果目标服务器的 Cookie 写死了 Path 也会出现 Cookie 无法写入的问题。</span></span><br><span class="line">            </span><br><span class="line"></span><br><span class="line">            <span class="comment">#设置“Set-Cookie”响应头中的domain属性的替换文本，其值可以为一个字符串、正则表达式的模式或一个引用的变量</span></span><br><span class="line">            <span class="comment">#转发后端服务器如果需要Cookie则需要将cookie domain也进行转换，否则前端域名与后端域名不一致cookie就会无法存取</span></span><br><span class="line"></span><br><span class="line">　　　　　　  <span class="comment">#配置规则：proxy_cookie_domain serverDomain(后端服务器域) nginxDomain(nginx服务器域)</span></span><br><span class="line">            proxy_cookie_domain localhost .testcaigou800.com;</span><br><span class="line">            </span><br><span class="line"></span><br><span class="line">            <span class="comment">#取消当前配置级别的所有proxy_cookie_domain指令</span></span><br><span class="line">            <span class="comment">#proxy_cookie_domain off;</span></span><br><span class="line">            <span class="comment">#与后端服务器建立连接的超时时间。一般不可能大于75秒；</span></span><br><span class="line">            proxy_connect_timeout <span class="number">30</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">#error_page  404              /404.html;</span></span><br><span class="line">    </span><br><span class="line">        <span class="comment"># redirect server error pages to the static page /50x.html</span></span><br><span class="line">        <span class="comment">#</span></span><br><span class="line">        error_page   <span class="number">500</span> <span class="number">502</span> <span class="number">503</span> <span class="number">504</span>  /<span class="number">50</span>x.html;</span><br><span class="line">        location = /<span class="number">50</span>x.html &#123;</span><br><span class="line">            root   html;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">　　<span class="comment">#当需要对同一端口监听多个域名时，使用如下配置，端口相同域名不同，server_name也可以使用正则进行配置</span></span><br><span class="line">　　<span class="comment">#但要注意server过多需要手动扩大server_names_hash_bucket_size缓存区大小</span></span><br><span class="line">　　server &#123;</span><br><span class="line">　　　　listen <span class="number">80</span>;</span><br><span class="line">　　　　server_name www.abc.com;</span><br><span class="line">　　　　charset utf<span class="number">-8</span>;</span><br><span class="line">　　　　location / &#123;</span><br><span class="line">　　　　　　proxy_pass http://localhost:<span class="number">10001</span>;</span><br><span class="line">　　　　&#125;</span><br><span class="line">　　&#125;</span><br><span class="line">　　server &#123;</span><br><span class="line">　　　　listen <span class="number">80</span>;</span><br><span class="line">　　　　server_name aaa.abc.com;</span><br><span class="line">　　　　charset utf<span class="number">-8</span>;</span><br><span class="line">　　　　location / &#123;</span><br><span class="line">　　　　　　proxy_pass http://localhost:<span class="number">20002</span>;</span><br><span class="line">　　　　&#125;</span><br><span class="line">　　&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Nginx反向代理详解"><a href="#Nginx反向代理详解" class="headerlink" title="Nginx反向代理详解"></a>Nginx反向代理详解</h2><h3 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h3><p><strong>正向代理代理客户端，反向代理代理服务器。</strong></p><h4 id="正向代理"><a href="#正向代理" class="headerlink" title="正向代理"></a>正向代理</h4><p>正向代理指的是，一个位于客户端和原始服务器之间的服务器，为了从原始服务器取得内容，客户端向代理发送一个请求并指定目标(原始服务器)，然后代理向原始服务器转交请求并将获得的内容返回给客户端。</p><h4 id="反向代理-1"><a href="#反向代理-1" class="headerlink" title="反向代理"></a>反向代理</h4><p>反向代理（Reverse Proxy）方式是指以代理服务器来接受Internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给Internet上请求连接的客户端，此时代理服务器对外就表现为一个服务器。</p><h3 id="为什么使用反向代理？"><a href="#为什么使用反向代理？" class="headerlink" title="为什么使用反向代理？"></a>为什么使用反向代理？</h3><ul><li>可以起到保护网站安全的作用，因为任何来自Internet的请求都必须先经过代理服务器。</li><li>通过缓存静态资源，加速Web请求。</li><li>实现负载均衡。目前市面上，主流的负载均衡方案：硬件设备有F5，软件方案有四层负载均衡的LVS，七层负载均衡的Nginx、Haproxy等。</li></ul><p><strong>链接：<a href="https://www.cnblogs.com/ysocean/p/9392908.html#_label3">nginx 反向代理详解</a></strong></p><h3 id="Nginx的Master-Worker模式"><a href="#Nginx的Master-Worker模式" class="headerlink" title="Nginx的Master-Worker模式"></a>Nginx的Master-Worker模式</h3><p>启动Nginx后，其实就是在80端口启动了Socket服务进行监听，如图所示，Nginx涉及Master进程和Worker进程。</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/fluetty/clouding/main/data/nginx-Master-Worker.jpg" alt="nginx-Master-Worker"></p><h4 id="Master进程的作用"><a href="#Master进程的作用" class="headerlink" title="Master进程的作用"></a>Master进程的作用</h4><p>读取并验证配置文件nginx.conf；管理worker进程；</p><h4 id="Worker进程的作用"><a href="#Worker进程的作用" class="headerlink" title="Worker进程的作用"></a>Worker进程的作用</h4><p>每一个Worker进程都维护一个线程（避免线程切换），处理连接和请求；注意Worker进程的个数由配置文件决定，一般和CPU个数相关（有利于进程切换），配置几个就有几个Worker进程。</p><h2 id="Nginx负载均衡"><a href="#Nginx负载均衡" class="headerlink" title="Nginx负载均衡"></a>Nginx负载均衡</h2><p>在反向代理中，可以通过proxy_pass来指定Tomcat的地址，很显然只能指定一台Tomcat地址，那么如果想指定多台来达到负载均衡呢？</p><p>第一，通过<strong>upstream</strong>来定义一组Tomcat，并指定负载策略（IPHASH、加权论调、最少连接），健康检查策略（Nginx可以监控这一组Tomcat的状态）等。</p><p>第二，将proxy_pass替换成upstream指定的值即可。</p><h3 id="负载均衡可能带来的问题"><a href="#负载均衡可能带来的问题" class="headerlink" title="负载均衡可能带来的问题"></a>负载均衡可能带来的问题</h3><p>负载均衡所带来的明显的问题是，一个请求，可以到A server，也可以到B server，这完全不受控制，当然这也不是什么问题，只是得注意：<strong>用户状态的保存问题，如Session会话信息，不能在保存到服务器上。</strong></p><h3 id="查看链接：-nginx-负载均衡详解"><a href="#查看链接：-nginx-负载均衡详解" class="headerlink" title="查看链接： nginx 负载均衡详解"></a>查看链接： <a href="https://www.cnblogs.com/ysocean/p/9392912.html">nginx 负载均衡详解</a></h3><h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><h3 id="Nginx如何做到热部署？"><a href="#Nginx如何做到热部署？" class="headerlink" title="Nginx如何做到热部署？"></a>Nginx如何做到热部署？</h3><p>所谓热部署，就是配置文件nginx.conf修改后，不需要stop Nginx，不需要中断请求，就能让配置文件生效。（nginx -s reload 重新加载/nginx -t检查配置/nginx -s stop）</p><p>worker进程负责处理具体的请求，那么如果想达到热部署的效果，可以想象：</p><p><strong>方案一：</strong></p><p>修改配置文件nginx.conf后，主进程master负责推送给woker进程更新配置信息，woker进程收到信息后，更新进程内部的线程信息。（有点valatile的味道）</p><p><strong>方案二：</strong></p><p>修改配置文件nginx.conf后，重新生成新的worker进程，当然会以新的配置进行处理请求，而且新的请求必须都交给新的worker进程，至于老的worker进程，等把那些以前的请求处理完毕后，kill掉即可。</p><p><strong>Nginx采用的就是方案二来达到热部署的。</strong></p><h3 id="Nginx如何做到高并发下的高效处理？"><a href="#Nginx如何做到高并发下的高效处理？" class="headerlink" title="Nginx如何做到高并发下的高效处理？"></a>Nginx如何做到高并发下的高效处理？</h3><p>Nginx的worker进程个数与CPU绑定、worker进程内部包含一个线程高效回环处理请求，这的确有助于效率，但这是不够的。</p><p>要同时处理那么多的请求，要知道，有的请求需要发生IO，可能需要很长时间，如果等着它，就会拖慢worker的处理速度。</p><p><strong>Nginx采用了Linux的epoll模型，epoll模型基于事件驱动机制，它可以监控多个事件是否准备完毕，如果OK，那么放入epoll队列中，这个过程是异步的。worker只需要从epoll队列循环处理即可。</strong></p><h3 id="Nginx挂掉怎么办？"><a href="#Nginx挂掉怎么办？" class="headerlink" title="Nginx挂掉怎么办？"></a>Nginx挂掉怎么办？</h3><p><strong>Keepalived+Nginx实现高可用</strong>。</p><p>Keepalived是一个高可用解决方案，主要是用来防止服务器单点发生故障，可以通过和Nginx配合来实现Web服务的高可用。（其实，Keepalived不仅仅可以和Nginx配合，还可以和很多其他服务配合）</p><p>Keepalived+Nginx实现高可用的思路：</p><p>第一：请求不要直接打到Nginx上，应该先通过Keepalived（这就是所谓虚拟IP，VIP）</p><p>第二：Keepalived应该能监控Nginx的生命状态（提供一个用户自定义的脚本，定期检查Nginx进程状态，进行权重变化,，从而实现Nginx故障切换）</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/fluetty/clouding/main/data/nginx+keepalived.jpg" alt="nginx+keepalived"></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://zhuanlan.zhihu.com/p/34943332">8分钟带你深入浅出搞懂Nginx</a><br><a href="https://www.cnblogs.com/ysocean/p/9392908.html#_label3">nginx 反向代理详解</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hr面试高频问题</title>
      <link href="2020/10/20/hr%E9%9D%A2%E8%AF%95%E9%AB%98%E9%A2%91%E9%97%AE%E9%A2%98/"/>
      <url>2020/10/20/hr%E9%9D%A2%E8%AF%95%E9%AB%98%E9%A2%91%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<ol><li>请你自我介绍一下你自己？</li></ol><p>回答提示：一般人回答这个问题过于平常，只说姓名. 年龄. 爱好. 工作经验，这些在简历上都有。其实，企业最希望知道的是求职者能否胜任工作，包括：最强的技能. 最深入研究的知识领域. 个性中最积极的部分. 做过的最成功的事，主要的成就等，这些都可以和学习无关，也可以和学习有关，但要突出积极的个性和做事的能力，说得合情合理企业才会相信。企业很重视一个人的礼貌，<a href="https://www.zhihu.com/search?q=%E6%B1%82%E8%81%8C%E8%80%85&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:636315003%7D">求职者</a>要尊重考官，在回答每个问题之后都说一句“谢谢”，企业喜欢有礼貌的求职者。</p><ol start="2"><li>你觉得你个性上最大的优点是什么？</li></ol><p>回答提示：沉着冷静. 条理清楚. 立场坚定. 顽强向上. 乐于助人和关心他人. 适应能力和幽默感. 乐观和友爱。</p><ol start="3"><li>说说你最大的缺点？</li></ol><p>回答提示：这个问题企业问的概率很大，通常不希望听到直接回答的缺点是什么等，如果求职者说自己小心眼. 爱忌妒人. 非常懒. 脾气大. 工作效率低，企业肯定不会录用你。绝对不要自作聪明地回答“我最大的缺点是过于追求完美”，有的人以为这样回答会显得自己比较出色，但事实上，他已经岌岌可危了。企业喜欢求职者从自己的优点说起，中间加一些小缺点，最后再把问题转回到优点上，突出优点的部分，企业喜欢聪明的求职者。</p><ol start="4"><li>你对加班的看法？</li></ol><p>回答提示：实际上好多公司问这个问题，并不证明一定要加班，只是想测试你是否愿意为公司奉献。</p><p>回答样本：如果是工作需要我会义不容辞加班，我现在单身，没有任何家庭负担，可以全身心的投入工作。但同时，我也会提高工作效率，减少不必要的加班。</p><ol start="5"><li>你对薪资的要求？</li></ol><p>回答提示：如果你对薪酬的要求太低，那显然贬低自己的能力；如果你对薪酬的要求太高，那又会显得你分量过重，公司受用不起。一些雇主通常都事先对求聘的职位定下<a href="https://www.zhihu.com/search?q=%E5%BC%80%E6%94%AF%E9%A2%84%E7%AE%97&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:636315003%7D">开支预算</a>，因而他们第一次提出的价钱往往是他们所能给予的最高价钱，他们问你只不过想证实一下这笔钱是否足以引起你对该工作的兴趣。</p><p>回答样本一：我对工资没有硬性要求，我相信贵公司在处理我的问题上会友善合理。我注重的是找对工作机会，所以只要条件公平，我则不会计较太多。</p><p>回答样本二：我受过系统的软件编程的训练，不需要进行大量的培训，而且我本人也对编程特别感兴趣。因此，我希望公司能根据我的情况和市场标准的水平，给我合理的薪水。</p><p>回答样本三：如果你必须自己说出具体数目，请不要说一个宽泛的范围，那样你将只能得到最低限度的数字。最好给出一个具体的数字，这样表明你已经对当今的人才市场作了调查，知道像自己这样学历的雇员有什么样的价值。</p><ol start="6"><li>在五年的时间内，你的<a href="https://www.zhihu.com/search?q=%E8%81%8C%E4%B8%9A%E8%A7%84%E5%88%92&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:636315003%7D">职业规划</a>？</li></ol><p>回答提示：这是每一个应聘者都不希望被问到的问题，但是几乎每个人都会被问到，比较多的答案是“管理者”。但是近几年来，许多公司都已经建立了专门的技术途径。这些工作地位往往被称作“顾问”. “参议技师”或“高级软件工程师”等等。当然，说出其他一些你感兴趣的职位也是可以的，比如产品销售部经理，<a href="https://www.zhihu.com/search?q=%E7%94%9F%E4%BA%A7%E9%83%A8%E7%BB%8F%E7%90%86&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:636315003%7D">生产部经理</a>等一些与你的专业有相关背景的工作。要知道，考官总是喜欢有进取心的应聘者，此时如果说“不知道”，或许就会使你丧失一个好机会。最普通的回答应该是“我准备在技术领域有所作为”或“我希望能按照公司的管理思路发展”。</p><ol start="7"><li>你朋友对你的评价？</li></ol><p>回答提示：想从侧面了解一下你的性格及与人相处的问题。</p><p>回答样本一：我的朋友都说我是一个可以信赖的人。因为，我一旦答应别人的事情，就一定会做到。如果我做不到，我就不会轻易许诺。</p><p>回答样本二：我觉的我是一个比较随和的人，与不同的人都可以友好相处。在我与人相处时，我总是能站在别人的角度考虑问题。</p><ol start="8"><li>你还有什么问题要问吗？</li></ol><p>回答提示：企业的这个问题看上去可有可无，其实很关键，企业不喜欢说“没问题”的人，因为其很注重员工的个性和创新能力。企业不喜欢求职者问个人福利之类的问题，如果有人这样问：贵公司对新入公司的员工有没有什么培训项目，我可以参加吗？或者说贵公司的晋升机制是什么样的？企业将很欢迎，因为体现出你对学习的热情和对公司的忠诚度以及你的上进心。</p><ol start="9"><li>如果通过这次面试我们单位录用了你，但工作一段时间却发现你根本不适合这个职位，你怎么办？</li></ol><p>回答提示：一段时间发现工作不适合我，有两种情况：①如果你确实热爱这个职业，那你就要不断学习，虚心向领导和同事学习业务知识和处事经验，了解这个职业的精神内涵和职业要求，力争减少差距；②你觉得这个职业可有可无，那还是趁早换个职业，去发现适合你的，你热爱的职业，那样你的发展前途也会大点，对单位和个人都有好处。</p><ol start="10"><li>在完成某项工作时，你认为领导要求的方式不是最好的，自己还有更好的方法，你应该怎么做？</li></ol><p>回答提示：①.原则上我会尊重和服从领导的工作安排，同时私底下找机会以请教的口吻，婉转地表达自己的想法，看看领导是否能改变想法。②如果领导没有采纳我的建议，我也同样会按领导的要求认真地去完成这项工作。③.还有一种情况，假如领导要求的方式违背原则，我会坚决提出反对意见，如领导仍固执己见，我会毫不犹豫地再向上级领导反映。</p><ol start="11"><li>如果你的工作出现失误，给本公司造成经济损失，你认为该怎么办？</li></ol><p>回答提示：①我本意是为公司努力工作，如果造成经济损失，我认为首要的问题是想方设法去弥补或挽回经济损失。如果我无能力负责，希望单位帮助解决。②分清责任，各负其责，如果是我的责任，我甘愿受罚；如果是一个我负责的团队中别人的失误，也不能幸灾乐祸，作为一个团队，需要互相提携共同完成工作，安慰同事并且帮助同事查找原因总结经验。③总结经验教训，一个人的一生不可能不犯错误，重要的是能从自己的或者是别人的错误中吸取经验教训，并在今后的工作中避免发生同类的错误。检讨自己的工作方法. 分析问题的深度和力度是否不够，以致出现了本可以避免的错误。</p><ol start="12"><li>如果你做的一项工作受到上级领导的表扬，但你主管领导却说是他做的，你该怎样？</li></ol><p>回答提示：我首先不会找那位上级领导说明这件事，我会主动找我的主管领导来沟通，因为沟通是解决<a href="https://www.zhihu.com/search?q=%E4%BA%BA%E9%99%85%E5%85%B3%E7%B3%BB&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:636315003%7D">人际关系</a>的最好办法，但结果会有两种：①我的主管领导认识到自己的错误，我想我会视具体情况决定是否原谅他。②他更加变本加厉的来威胁我，那我会毫不犹豫地找我的上级领导反映此事，因为他这样做会造成负面影响，对今后的工作不利。</p><ol start="13"><li>谈谈你对跳槽的看法？</li></ol><p>回答提示：①正常的“跳槽”能促进人才合理流动，应该支持。②频繁的跳槽对单位和个人双方都不利，应该反对。</p><ol start="14"><li>工作中你难以和同事. 上司相处，你该怎么办？</li></ol><p>回答提示：①我会服从领导的指挥，配合同事的工作。②我会从自身找原因，仔细分析是不是自己工作做得不好让领导不满意，同事看不惯。还要看看是不是为人处世方面做得不好，如果是这样的话我会努力改正。③如果我找不到原因，我会找机会跟他们沟通，请他们指出我的不足，有问题就及时改正。④作为优秀的员工，应该时刻以大局为重，即使在一段时间内，领导和同事对我不理解，我也会做好本职工作，虚心向他们学习，我相信，他们会看见我在努力，总有一天会对我微笑的。</p><ol start="15"><li>假设你在某单位工作，成绩比较突出，得到领导的肯定。但同时你发现同事们越来越孤立你，你怎么看这个问题？你准备怎么办？</li></ol><p>回答提示：①成绩比较突出，得到领导的肯定是件好事情，以后更加努力。②检讨一下自己是不是对工作的热心度超过同事间交往的热心了，加强同事间的交往及共同的兴趣爱好。③工作中，切勿伤害别人的自尊心④不再领导前拨弄是非。</p><ol start="16"><li>你最近是否参加了培训课程？谈谈培训课程的内容。是公司资助还是自费参加？</li></ol><p>回答提示：</p><ol start="17"><li>你对于我们公司了解多少？</li></ol><p>回答提示：在去公司面试前上网查一下该公司主营业务。如回答：贵公司有意改变策略，加强与国外大厂的OEM合作，自有品牌的部分则透过海外经销商。</p><ol start="18"><li>请说出你选择这份工作的动机？</li></ol><p>回答提示：这是想知道面试者对这份工作的热忱及理解度，并筛选因一时兴起而来应试的人，如果是无经验者，可以强调“就算职种不同，也希望有机会发挥之前的经验”。</p><ol start="19"><li>你最擅长的技术方向是什么？</li></ol><p>回答提示：说和你要应聘的职位相关的课程，表现一下自己的热诚没有什么坏处。</p><ol start="20"><li>你能为我们公司带来什么呢？</li></ol><p>回答提示：①假如你可以的话，试着告诉他们你可以减低他们的费用——“我已经接受过<a href="https://www.zhihu.com/search?q=%E5%8C%97%E5%A4%A7%E9%9D%92%E9%B8%9F&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:636315003%7D">北大青鸟</a>近两年专业的培训，立刻就可以上岗工作”。②企业很想知道未来的员工能为企业做什么，求职者应再次重复自己的优势，然后说：“就我的能力，我可以做一个优秀的员工在组织中发挥能力，给组织带来高效率和更多的收益”。企业喜欢求职者就申请的职位表明自己的能力，比如申请营销之类的职位，可以说：“我可以开发大量的新客户，同时，对老客户做更全面周到的服务，开发老客户的新需求和消费。”等等。</p><ol start="21"><li>最能概括你自己的三个词是什么？</li></ol><p>回答提示：我经常用的三个词是：适应能力强，有责任心和做事有始终，结合具体例子向主考官解释，</p><ol start="22"><li>你的业余爱好是什么？</li></ol><p>回答提示：找一些富于团体合作精神的，这里有一个真实的故事：有人被否决掉，因为他的爱好是深海潜水。主考官说：因为这是一项单人活动，我不敢肯定他能否适应<a href="https://www.zhihu.com/search?q=%E5%9B%A2%E4%BD%93%E5%B7%A5%E4%BD%9C&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:636315003%7D">团体工作</a>。</p><ol start="23"><li>作为被面试者给我打一下分？</li></ol><p>回答提示：试着列出四个优点和一个非常非常非常小的缺点（可以抱怨一下设施，没有明确责任人的缺点是不会有人介意的）。</p><ol start="24"><li>你怎么理解你应聘的职位？</li></ol><p>回答提示：把岗位职责和任务及工作态度阐述一下。</p><ol start="25"><li>喜欢这份工作的哪一点？</li></ol><p>回答提示：相信其实大家心中一定都有答案了吧！每个人的价值观不同，自然评断的标准也会不同，但是，在回答面试官这个问题时可不能太直接就把自己心理的话说出来，尤其是薪资方面的问题，不过一些无伤大雅的回答是不错的考虑，如交通方便，工作性质及内容颇能符合自己的兴趣等等都是不错的答案，不过如果这时自己能仔细思考出这份工作的与众不同之处，相信在面试上会大大加分。</p><ol start="26"><li>为什么要离职?</li></ol><p>回答提示：①回答这个问题时一定要小心，就算在前一个工作受到再大的委屈，对公司有多少的怨言，都千万不要表现出来，尤其要避免对公司本身主管的批评，避免面试官的负面情绪及印象。建议此时最好的回答方式是将问题归咎在自己身上，例如觉得工作没有学习发展的空间，自己想在面试工作的相关产业中多加学习，或是前一份工作与自己的生涯规划不合等等，回答的答案最好是积极正面的。②我希望能获得一份更好的工作，如果机会来临，我会抓住。我觉得目前的工作，已经达到顶峰，即沒有升迁机会。</p><ol start="27"><li>说说你对行业. 技术发展趋势的看法？</li></ol><p>回答提示：企业对这个问题很感兴趣，只有有备而来的求职者能够过关。求职者可以直接在网上查找对你所申请的行业部门的信息，只有深入了解才能产生独特的见解。企业认为最聪明的求职者是对所面试的公司预先了解很多，包括公司各个部门，发展情况，在面试回答问题的时候可以提到所了解的情况，企业欢迎进入企业的人是“知己”，而不是“盲人”。</p><ol start="28"><li>对工作的期望与目标何在？</li></ol><p>回答提示：这是面试者用来评断求职者是否对自己有一定程度的期望. 对这份工作是否了解的问题。对于工作有确实学习目标的人通常学习较快，对于新工作自然较容易进入状况，这时建议你，最好针对工作的性质找出一个确实的答案，如业务员的工作可以这样回答：“我的目标是能成为一个超级业务员，将公司的产品广泛的推销出去，达到最好的业绩成效；为了达到这个目标，我一定会努力学习，而我相信以我认真负责的态度，一定可以达到这个目标。”其他类的工作也可以比照这个方式来回答，只要在目标方面稍微修改一下就可以了。</p><ol start="29"><li>说你的家庭？</li></ol><p>回答提示：企业面试时询问家庭问题不是非要知道求职者家庭的情况，探究隐私，企业不喜欢探究个人隐私，而是要了解家庭背景对求职者的塑造和影响。企业希望听到的重点也在于家庭对求职者的积极影响。企业最喜欢听到的是：我很爱我的家庭，我的家庭一向很和睦，虽然我的父亲和母亲都是普通人，但是从小，我就看到我父亲起早贪黑，每天工作特别勤劳，他的行动无形中培养了我认真负责的态度和勤劳的精神。我母亲为人善良，对人热情，特别乐于助人，所以在单位人缘很好，她的一言一行也一直在教导我做人的道理。企业相信，和睦的家庭关系对一个人的成长有潜移默化的影响。</p><ol start="30"><li>就你申请的这个职位，你认为你还欠缺什么？</li></ol><p>回答提示：企业喜欢问求职者弱点，但精明的求职者一般不直接回答。他们希望看到这样的求职者：继续重复自己的优势，然后说：“对于这个职位和我的能力来说，我相信自己是可以胜任的，只是缺乏经验，这个问题我想我可以进入公司以后以最短的时间来解决，我的学习能力很强，我相信可以很快融入公司的<a href="https://www.zhihu.com/search?q=%E4%BC%81%E4%B8%9A%E6%96%87%E5%8C%96&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:636315003%7D">企业文化</a>，进入工作状态。”企业喜欢能够巧妙地躲过难题的求职者。</p><ol start="31"><li>你欣赏哪种性格的人？</li></ol><p>回答提示：诚实. 不死板而且容易相处的人. 有“实际行动”的人。</p><ol start="32"><li>你通常如何处理別人的批评？</li></ol><p>回答提示：①沈默是金，不必说什么，否则情况更糟，不过我会接受建设性的批评。②我会等大家冷靜下来再讨论。</p><ol start="33"><li>怎样对待自己的失敗？</li></ol><p>回答提示：我们大家生来都不是十全十美的，我相信我有第二个机会改正我的错误。</p><ol start="34"><li>什么会让你有成就感？</li></ol><p>回答提示：为贵公司竭力效劳，尽我所能，完成一个项目。</p><ol start="35"><li>眼下你生活中最重要的是什么？</li></ol><p>回答提示：对我来说，能在这个领域找到工作是最重要的，能在贵公司任职对我说最重要。</p><ol start="36"><li>你为什么愿意到我们公司来工作？</li></ol><p>回答提示：对于这个问题，你要格外小心，如果你已经对该单位作了研究，你可以回答一些详细的原因，像“公司本身的高技术开发环境很吸引我。”. “我同公司出生在同样的时代，我希望能够进入一家与我共同成长的公司。”. “你们公司一直都稳定发展，在近几年来在市场上很有竞争力。”. “我认为贵公司能够给我提供一个与众不同的发展道路。”这都显示出你已经做了一些调查，也说明你对自己的未来有了较为具体的远景规划。</p><ol start="37"><li>你和别人发生过争执吗？你是怎样解决的？</li></ol><p>回答提示：这是面试中最险恶的问题，其实是考官布下的一个陷阱，千万不要说任何人的过错，应知成功解决矛盾是一个协作团体中成员所必备的能力。假如你工作在一个服务行业，这个问题简直成了最重要的一个环节。你是否能获得这份工作，将取决于这个问题的回答。考官希望看到你是成熟且乐于奉献的。他们通过这个问题了解你的成熟度和处世能力。在没有外界干涉的情况下，通过妥协的方式来解决才是正确答案。</p><ol start="38"><li>问题：你做过的哪件事最令自己感到骄傲？</li></ol><p>回答提示：这是考官给你的一个机会，让你展示自己把握命运的能力。这会体现你潜在的领导能力以及你被提升的可能性。假如你应聘于一个服务性质的单位，你很可能会被邀请去午餐。记住：你的前途取决于你的知识. 你的社交能力和综合表现。</p><ol start="39"><li>新到一个部门，一天一个客户来找你解决问题，你努力想让他满意，可是始终达不到群众得满意，他投诉你们部门工作效率低，你这个时候怎么作？</li></ol><p>回答提示：(1)首先，我会保持冷静。作为一名工作人员，在工作中遇到各种各样的问题是正常的，关键是如何认识它，积极应对，妥善处理。(2)其次，我会反思一下客户不满意的原因。一是看是否是自己在解决问题上的确有考虑的不周到的地方，二是看是否是客户不太了解相关的服务规定而提出超出规定的要求，三是看是否是客户了解相关的规定，但是提出的要求不合理。(3)再次，根据原因采取相对的对策。如果是自己确有不周到的地方，按照服务规定作出合理的安排，并向客户作出解释；如果是客户不太了解政策规定而造成的误解，我会向他作出进一步的解释，消除他的误会；如果是客户提出的要求不符合政策规定，我会明确地向他指出。(4)再次，我会把整个事情的处理情况向领导作出说明，希望得到他的理解和支持。(5)我不会因为客户投诉了我而丧失工作的热情和积极性，而会一如既往地牢记为客户服务的宗旨，争取早日做一名领导信任. 公司放心. 客户满意的职员。</p><ol start="40"><li>对这项工作，你有哪些可预见的困难？</li></ol><p>回答提示：①不宜直接说出具体的困难，否则可能令对方怀疑应聘者不行。②可以尝试<a href="https://www.zhihu.com/search?q=%E8%BF%82%E5%9B%9E%E6%88%98%E6%9C%AF&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:636315003%7D">迂回战术</a>，说出应聘者对困难所持有的态度——工作中出现一些困难是正常的，也是难免的，但是只要有坚忍不拔的毅力. 良好的合作精神以及事前周密而充分的准备，任何困难都是可以克服。</p><p>分析：一般问这个问题，面试者的希望就比较大了，因为已经在谈工作细节，但常规思路中的回答，又被面试官“骗”了。当面试官询问这个问题的时候，有两个目的。第一，看看应聘者是不是在行，说出的困难是不是在这个职位中一般都不可避免的问题。第二，是想看一下应聘者解决困难的手法对不对，及公司能否提供这样的资源。而不是想了解应聘者对困难的态度。</p><ol start="41"><li>如果我录用你，你将怎样开展工作？</li></ol><p>回答提示：①如果应聘者对于应聘的职位缺乏足够的了解，最好不要直接说出自己开展工作的具体办法。②可以尝试采用迂回战术来回答，如“首先听取领导的指示和要求，然后就有关情况进行了解和熟悉，接下来制定一份近期的工作计划并报领导批准，最后根据计划开展工作。”。</p><p>分析：这个问题的主要目的也是了解应聘者的工作能力和计划性. 条理性，而且重点想要知道细节。如果向思路中所讲的迂回战术，面试官会认为回避问题，如果引导了几次仍然是回避的话，此人绝对不会录用了。</p><ol start="42"><li>你希望与什么样的上级共事？</li></ol><p>回答提示：①通过应聘者对上级的“希望”可以判断出应聘者对自我要求的意识，这既上一个陷阱，又是一次机会。②最好回避对上级具体的希望，多谈对自己的要求。③如“做为刚步入社会的新人，我应该多要求自己尽快熟悉环境. 适应环境，而不应该对环境提出什么要求，只要能发挥我的专长就可以了。</p><p>分析：这个问题比较好的回答是，希望我的上级能够在工作中对我多指导，对我工作中的错误能够立即指出。总之，从上级指导这个方面谈，不会有大的纰漏。</p><ol start="43"><li>在完成某项工作时，你认为领导要求的方式不是最好的，自己还有更好的方法，你应该怎么做？</li></ol><p>回答提示：①.原则上我会尊重和服从领导的工作安排；同时私底下找机会以请教的口吻，婉转地表达自己的想法，看看领导是否能改变想法。②如果领导没有采纳我的建议，我也同样会按领导的要求认真地去完成这项工作。③.还有一种情况，假如领导要求的方式违背原则，我会坚决提出反对意见，如领导仍固执己见，我会毫不犹豫地再向上级领导反映。</p><ol start="44"><li>与上级意见不一是，你将怎么办？</li></ol><p>回答提示：①一般可以这样回答“我会给上级以必要的解释和提醒，在这种情况下，我会服从上级的意见。”②如果面试你的是总经理，而你所应聘的职位另有一位经理，且这位经理当时不在场，可以这样回答：“对于非原则性问题，我会服从上级的意见，对于涉及公司利益的重大问题，我希望能向更高层领导反映。”</p><p>分析：这个问题的标准答案是思路①，如果用②的回答，必死无疑。你没有摸清楚改公司的内部情况，先想打小报告，这样的人没有人敢要。</p><ol start="45"><li>你工作经验欠缺，如何能胜任这项工作？</li></ol><p>常规思路：①如果招聘单位对应届毕业生的应聘者提出这个问题，说明招聘公司并不真正在乎“经验”，关键看应聘者怎样回答。②对这个问题的回答最好要体现出应聘者的诚恳. 机智. 果敢及敬业。③如“作为应届毕业生，在工作经验方面的确会有所欠缺，因此在读书期间我一直利用各种机会在这个行业里做兼职。我也发现，实际工作远比书本知识丰富. 复杂。但我有较强的责任心. 适应能力和学习能力，而且比较勤奋，所以在兼职中均能圆满完成各项工作，从中获取的经验也令我受益非浅。请贵公司放心，学校所学及兼职的工作经验使我一定能胜任这个职位。”点评：这个问题思路中的答案尚可，突出自己的吃苦能力和适应性以及学习能力（不是学习成绩）为好。</p><ol start="46"><li>您在前一家公司的离职原因是什么？</li></ol><p>回答提示：①最重要的是：应聘者要使找招聘单位相信，应聘者在过往的单位的“离职原因”在此家招聘单位里不存在。②避免把“离职原因”说得太详细. 太具体。③不能掺杂主观的负面感受，如“太辛苦”. “人际关系复杂”. “管理太混乱”. “公司不重视人才”. “公司排斥我们某某的员工”等。④但也不能躲闪. 回避，如“想换换环境”. “个人原因”等。⑤不能涉及自己负面的人格特征，如不诚实. 懒惰. 缺乏责任感. 不随和等。⑥尽量使解释的理由为应聘者个人形象添彩。⑦相关例子：如“我离职是因为这家公司倒闭；我在公司工作了三年多，有较深的感情；从去年始，由于市场形势突变，公司的局面急转直下；到眼下这一步我觉得很遗憾，但还要面对显示，重新寻找能发挥我能力的舞台。”同一个面试问题并非只有一个答案，而同一个答案并不是在任何面试场合都有效，关键在应聘者掌握了规律后，对面试的具体情况进行把握，有意识地揣摩面试官提出问题的心理背景，然后投其所好。</p><p>分析：除非是薪资太低，或者是最初的工作，否则不要用薪资作为理由。“求发展”也被考官听得太多，离职理由要根据每个人的真实离职理由来设计，但是在回答时一定要表现得真诚。实在想不出来的时候，家在外地可以说是因为家中有事，须请假几个月，公司又不可能准假，所以辞职，这个答案一般面试官还能接受。</p><ol start="47"><li>你工作经验欠缺，如何能胜任这项工作？</li></ol><p>回答提示：①如果招聘单位对应届毕业生的应聘者提出这个问题，说明招聘公司并不真正在乎“经验”，关键看应聘者怎样回答。②对这个问题的回答最好要体现出应聘者的诚恳. 机智. 果敢及敬业。③如“作为应届毕业生，在工作经验方面的确会有所欠缺，因此在读书期间我一直利用各种机会在这个行业里做兼职。我也发现，实际工作远比书本知识丰富. 复杂。但我有较强的责任心. 适应能力和学习能力，而且比较勤奋，所以在兼职中均能圆满完成各项工作，从中获取的经验也令我受益非浅。请贵公司放心，学校所学及兼职的工作经验使我一定能胜任这个职位。”</p><p>分析：这个问题思路中的答案尚可。突出自己的吃苦能力和适应性以及学习能力（不是学习成绩）为好。</p><ol start="48"><li>为了做好你工作份外之事，你该怎样获得他人的支持和帮助？</li></ol><p>回答提示：每个公司都在不断变化发展的过程中，你当然希望你的员工也是这样。你希望得到那些希望并欢迎变化的人，因为这些人明白，为了公司的发展，变化是公司日常生活中重要组成部分。这样的员工往往很容易适应公司的变化，并会对变化做出积极的响应。</p><ol start="49"><li>果你在这次面试中没有被录用，你怎么打算？</li></ol><p>回答提示：现在的社会是一个竞争的社会，从这次面试中也可看出这一点，有竞争就必然有优劣，有成功必定就会有失败。往往成功的背后有许多的困难和挫折，如果这次失败了也仅仅是一次而已，只有经过经验经历的积累才能塑造出一个完全的成功者。我会从以下几个方面来正确看待这次失败：①要敢于面对，面对这次失败不气馁，接受已经失去了这次机会就不会回头这个现实，从心理意志和精神上体现出对这次失败的抵抗力。要有自信，相信自己经历了这次之后经过努力一定能行，能够超越自我。②善于反思，对于这次面试经验要认真总结，思考剖析，能够从自身的角度找差距。正确对待自己，实事求是地评价自己，辩证的看待自己的长短得失，做一个明白人。③走出阴影，要克服这一次失败带给自己的心理压力，时刻牢记自己弱点，防患于未然，加强学习，提高自身素质。④认真工作，回到原单位岗位上后，要实实在在. 踏踏实实地工作，三十六行. 行行出状元，争取在本岗位上做出一定的成绩。⑤再接再厉，成为国家公务员一直是我的梦想，以后如果有机会我仍然后再次参加竞争。</p><ol start="50"><li>假如你晚上要去送一个出国的同学去机场，可单位临时有事非你办不可，你怎么办？</li></ol><p>回答提示：我觉得工作是第一位的，但朋友间的情谊也是不能偏废的，这个问题我觉得要按照当时具体的情况来决定。</p><p>①如果我的朋友晚上9点中的飞机，而我的加班八点就能够完成的话，那就最理想了，干完工作去机场，皆大欢喜。②如果说工作不是很紧急，加班仅仅是为了明天上班的时候能把报告交到办公室，那完全可以跟领导打声招呼，先去机场然后回来加班，晚点睡就是了。③如果工作很紧急，两者不可能兼顾的情况下，我觉得可以由两种选择。（1）如果不是全单位都加班的话，是不是可以要其他同事来代替以下工作，自己去机场，哪怕就是代替你离开的那一会儿。（2）如果连这一点都做不到的话，那只好忠义不能两全了，打电话给朋友解释一下，相信他会理解，毕竟工作做完了就完了，朋友还是可以再见面的。</p><ol start="51"><li>谈谈你过去做过的成功案例？</li></ol><p>回答提示：举一个你最有把握的例子，把来龙去脉说清楚，而不要说了很多却没有重点。切忌夸大其词，把别人的功劳到说成自己的，很多主管为了确保要用的人是最适合的，会打电话向你的前一个主管征询对你的看法及意见，所以如果说谎，是很容易穿梆的。</p><ol start="52"><li>谈谈你过去的工作经验中，最令你挫折的事情？</li></ol><p>回答提示：曾经接触过一个客户，原本就有耳闻他们以挑剔出名，所以事前的准备功夫做得十分充分，也投入了相当多的时间与精力，最后客户虽然并没有照单全收，但是接受的程度已经出乎我们意料之外了。原以为从此可以合作愉快，却得知客户最后因为预算关系选择了另一家代理商，之前的努力因而付诸流水。尽管如此，我还是从这次的经验学到很多，如对该产业的了解，整个team的默契也更好了。</p><p>分析：借此了解你对挫折的容忍度及调解方式。</p><ol start="53"><li>如何安排自己的时间？会不会排斥加班？</li></ol><p>回答提示：基本上，如果上班工作有效率，工作量合理的话，应该不太需要加班。可是我也知道有时候很难避免加班，加上现在工作都采用<a href="https://www.zhihu.com/search?q=%E8%B4%A3%E4%BB%BB%E5%88%B6&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:636315003%7D">责任制</a>，所以我会调配自己的时间，全力配合。</p><p>分析：虽然不会有人心甘情愿的加班，但依旧要表现出高配合度的诚意。</p><ol start="54"><li>为什么我们要在众多的面试者中选择你？</li></ol><p>回答提示：根据我对贵公司的了解，以及我在这份工作上所累积的专业. 经验及人脉，相信正是贵公司所找寻的人才。而我在工作态度. ＥＱ上，也有圆融. 成熟的一面，和主管. 同事都能合作愉快。</p><p>分析：别过度吹嘘自己的能力，或信口开河地乱开支票，例如一定会为该公司带来多少钱的业务等，这样很容易给人一种爱说大话. 不切实际的感觉。</p><ol start="55"><li>这个职务的期许？</li></ol><p>回答提示：希望能借此发挥我的所学及专长，同时也吸收贵公司在这方面的经验，就公司. 我个人而言，缔造“双赢”的局面。</p><p>分析：回答前不妨先询问该公司对这项职务的责任认定及归属，因为每一家公司的状况不尽相同，以免说了一堆理想抱负却发现牛头不对马嘴。</p><ol start="56"><li>为什么选择这个职务？</li></ol><p>回答提示：这一直是我的兴趣和专长，经过这几年的磨练，也累积了一定的经验及人脉，相信我一定能胜任这个职务的。</p><p>分析：适时举出过去的“丰功伟业”，表现出你对这份职务的熟稔度，但避免过于夸张的形容或流于炫耀。</p><ol start="57"><li>什么选择我们这家公司？</li></ol><p>回答提示：曾经在报章杂志看过关于贵公司的报道，与自己所追求的理念有志一同。而贵公司在业界的成绩也是有目共睹的，而且对员工的教育训练. 升迁等也都很有制度。</p><p>分析：去面试前先做功课，了解一下该公司的背景，让对方觉得你真的很有心想得到这份工作，而不只是探探路。</p><ol start="58"><li>认为你在学校属于好学生吗？</li></ol><p>回答提示：企业的招聘者很精明，问这个问题可以试探出很多问题：如果求职者学习成绩好，就会说：“是的，我的成绩很好，所有的成绩都很优异。当然，判断一个学生是不是好学生有很多标准，在学校期间我认为成绩是重要的，其他方面包括思想道德. 实践经验. 团队精神. 沟通能力也都是很重要的，我在这些方面也做得很好，应该说我是一个全面发展的学生。”如果求职者成绩不尽理想，便会说：“我认为是不是一个好学生的标准是多元化的，我的学习成绩还可以，在其他方面我的表现也很突出，比如我去很多地方实习过，我很喜欢在快节奏和压力下工作，我在学生会组织过××活动，锻炼了我的团队合作精神和组织能力。”有经验的招聘者一听就会明白，企业喜欢诚实的求职者。</p><ol start="59"><li>谈谈如何适应办公室工作的新环境？</li></ol><p>回答提示①办公室里每个人有各自的岗位与职责，不得擅离岗位。②根据领导指示和工作安排，制定工作计划，提前预备，并按计划完成。③多请示并及时汇报，遇到不明白的要虚心请教。④抓间隙时间，多学习，努力提高自己的政治素质和业务水平。</p><ol start="60"><li>工作中学习到了些什么？</li></ol><p>回答提示：这是针对转职者提出的问题，建议此时可以配合面试工作的特点作为主要依据来回答，如业务工作需要与人沟通，便可举出之前工作与人沟通的例子，经历了哪些困难，学习到哪些经验，把握这些要点做陈述，就可以轻易过关了。</p><ol start="61"><li>想过创业吗？</li></ol><p>回答提示：这个问题可以显示你的冲劲，但如果你的回答是“有”的话，千万小心，下一个问题可能就是：那么为什么你不这样做呢？</p><p>如果想要知道更多，和我一起进步，请关注我的公众号“努力的阿小瑞”</p><ol start="62"><li>除了本公司外，还应聘了哪些公司？</li></ol><p>回答提示：很奇怪，这是相当多公司会问的问题，其用意是要概略知道应徵者的求职志向，所以这并非绝对是负面答案，就算不便说出公司名称，也应回答“销售同种产品的公司”，如果应聘的其他公司是不同业界，容易让人产生无法信任的感觉。</p><ol start="63"><li>何时可以到职？</li></ol><p>回答提示：大多数企业会关心就职时间，最好是回答“如果被录用的话，到职日可按公司规定上班”，但如果还未辞去上一个工作. 上班时间又太近，似乎有些强人所难，因为交接至少要一个月的时间，应进一步说明原因，录取公司应该会通融的。</p><ol start="64"><li>你并非毕业于名牌院校？</li></ol><p>回答提示：是否毕业于名牌院校不重要，重要的是有能力完成您交给我的工作，我接受了北大青鸟的职业培训，掌握的技能完全可以胜任贵公司现在工作，而且我比一些名牌院校的应届毕业生的动手能力还要强，我想我更适合贵公司这个职位。</p><ol start="65"><li> 怎样看待学历和能力？</li></ol><p>回答提示：学历我想只要是大学专科的学历，就表明觉得我具备了根本的学习能力。剩下的，你是学士也好，还是博士也好，对于这一点的讨论，不是看你学了多少知识，而是看你在这个领域上发挥了什么，也就是所说的能力问题。一个人工作能力的高低直接决定其职场命运，而学历的高低只是进入一个企业的敲门砖，如果贵公司把学历卡在博士上，我就无法进入贵公司，当然这不一定只是我个人的损失，如果一个专科生都能完成的工作，您又何必非要招聘一位博士生呢。</p>]]></content>
      
      
      <categories>
          
          <category> 面试题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络面试题目</title>
      <link href="2020/10/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE/"/>
      <url>2020/10/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE/</url>
      
        <content type="html"><![CDATA[<h3 id="浏览器输入URL发生了什么-TODO-详细描述"><a href="#浏览器输入URL发生了什么-TODO-详细描述" class="headerlink" title="浏览器输入URL发生了什么   TODO   详细描述"></a>浏览器输入URL发生了什么   TODO   详细描述</h3><ol><li>DNS解析        优先查找本地host文件有无对应的IP地址，没有的话去本地DNS服务器查找，还不行的话，本地DNS服务器会去找根DNS服务器要一个域服务器的地址进行查询，域服务器将要查询的域名的解析服务器地址返回给本地DNS，本地DNS去这里查询就OK了。</li><li>TCP连接        建立TCP/IP连接，服务器接收到请求并开始处理。</li><li>发送HTTP请求        浏览器拿到服务器的IP地址后，会向它发送HTTP请求。HTTP请求经由一层层的处理、封装、发出之后，最终经由网络到达服务器。</li><li>服务器处理HTTP请求并返回HTTP报文    服务器构建响应，再经由一层层的处理、封装、发出后，到达客户端，浏览器处理请求。</li><li>浏览器解析渲染页面        浏览器开始渲染页面，解析HTML，构建render树，根据render树的节点和CSS的对应关系，进行布局，绘制页面。</li><li>连接结束</li></ol><h3 id="TCP和UDP区别"><a href="#TCP和UDP区别" class="headerlink" title="TCP和UDP区别"></a>TCP和UDP区别</h3><ol><li>TCP 面向连接，传输可靠；  传输形式：字节流； 传输效率慢，所需资源多； 应用场景：要求通信数据可靠（如文件传输、邮件传输、远程登录等） 首部字节 20-60</li><li>UDP 无连接，传输不可靠；传输形式：数据报文段；传输效率快，所需资源少；应用场景：要求通信速度高（如即时通信，直播、域名转换等），首部8个字节（由四个字段组成）</li><li>TCP 不提供广播或者多播服务</li></ol><h3 id="TCP是如何保证传输可靠性"><a href="#TCP是如何保证传输可靠性" class="headerlink" title="TCP是如何保证传输可靠性"></a>TCP是如何保证传输可靠性</h3><ol><li>应用程序被分割成TCP认为最适合发送的数据块</li><li>TCP给发送的每个包标号，接收方对数据包排序，把有序数据传送给应用层。</li><li>校验和：TCP将保持它的首部和数据的校验和。这是一个端到端的校验和，目的是监测数据传输过程中的变化。如果收到检验和有差错，将丢弃这个报文段和不确认收到此报文段。</li><li>TCP的接收端会丢弃重复的数据。</li><li>流量控制：TCP根据接收端对数据的处理能力，决定发送端的发送速度，这个机制就是流量控制。TCP利用滑动窗口来实现流量控制。</li><li>拥塞控制：拥塞控制就是防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不致过载。常用的方法就是：1. 慢开始、拥塞控制 2. 快重传、快恢复。</li><li>超时重传：当TCP发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。 </li></ol><h3 id="tcp连接的三次握手，四次挥手"><a href="#tcp连接的三次握手，四次挥手" class="headerlink" title="tcp连接的三次握手，四次挥手"></a>tcp连接的三次握手，四次挥手</h3><h4 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h4><p>同步序号SYN：用来建立连接，涉及到TCP的三次握手。    </p><ol><li>开始建立连接时，客户端向服务器发送一个TCP分组，分组首部的SYN为1，并携带一个初始序号，表明这是一个连接请求。</li><li>如果服务器接受了连接，会向客户端发送一个TCP分组，分组中会包含SYN和ACK，都为1，同时包含一个确认序号，值为来自客户端的初始序号 + 1，表示连接已经被接受。</li><li>客户端收到上一步发来的分组后，会再向服务器发送一段确认报文分组，ACK为1，会再次携带确认序号，值是第二步来自客户端的确认序号 + 1。服务端收到确认信息后，进入已经连接的状态。<br> 在第三步的确认分组中，是可以携带要发送的数据的。</li></ol><h4 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h4><p>连接终止标志FIN： 用来关闭连接，当一端完成数据发送任务后会发送一个FIN标志来终止连接，但因为TCP在两个方向（C-S,S-C）上会有数据传递，每个方向有各自的发送FIN &amp; 确认关闭流程，所以会有四次交互，也称为四次挥手。    </p><ol><li>如果客户端应用层的数据发送完毕，会导致客户端的TCP报文发送一个FIN，告知服务器准备关闭数据传送。</li><li>服务器接收到这个标志后，它发回一个ACK，确认序号为收到的序号加1，同时TCP还要向应用程序发一个文件结束符。</li><li>此时服务器关闭这个方向的连接，导致它的TCP也会发送一个FIN。</li><li>客户端接收到之后发回一个确认ACK，序号为收到的序号 + 1，连接完全关闭。</li></ol><h3 id="描述HTTPS和HTTP的区别"><a href="#描述HTTPS和HTTP的区别" class="headerlink" title="描述HTTPS和HTTP的区别"></a>描述HTTPS和HTTP的区别</h3><ol><li>http是超文本传输协议，信息是明文传输，客户端和服务端无法验证对方的身份，https则是具有安全性的ssl/tls加密传输协议，ssl/tls运行在TCP之上。传输加密，加密采用对称加密，对称加密事务密匙用服务器方的证书进行了非对称加密。 http安全性不如https，https耗费服务器资源多。</li><li>http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。</li><li>对称加密：密钥只有一个，加密解密用同一个密码，加密速度快。典型的加密算法有AES、DES。</li><li>非对称加密：密钥成对出现（根据公钥无法推知私钥，根据私钥无法推知公钥）加密解密使用不同密钥（公钥加密需要私钥解密，私钥加密需要公钥解密），相对对称加密速度较慢。典型的非对称加密算法有RSA、DSA等。</li></ol><h3 id="HTTP协议的请求报文和响应报文格式"><a href="#HTTP协议的请求报文和响应报文格式" class="headerlink" title="HTTP协议的请求报文和响应报文格式"></a>HTTP协议的请求报文和响应报文格式</h3><p><strong>HTTP 请求报文由请求行、请求头部、空行 和 请求体 4 个部分组成。</strong></p><ol><li>请求行：请求行由方法字段、URL 字段 和HTTP 协议版本字段 3 个部分组成，他们之间使用空格隔开。<br>常用的 HTTP 请求方法有 GET、POST、HEAD、PUT、DELETE、OPTIONS、TRACE、CONNECT;</li><li>请求头部：请求头部由关键字/值对组成，每行一对，关键字和值用英文冒号“:”分隔。请求头部通知服务器有关于客户端请求的信息，典型的请求头有：User-Agent：产生请求的浏览器类型;Accept-Encoding：客户端可接受的编码压缩格式;Cookie：存储于客户端扩展字段，向同一域名的服务端发送属于该域的cookie;等</li></ol><p><strong>HTTP 响应报文由状态行、响应头部、空行 和 响应包体 4 个部分组成。</strong></p><ol><li>状态行：状态行由 HTTP 协议版本字段、状态码和状态码的描述文本 3 个部分组成，他们之间使用空格隔开。</li></ol><h3 id="HTTP的状态码有哪些？如果出现某些错误的状态码，分析出是什么情况吗？"><a href="#HTTP的状态码有哪些？如果出现某些错误的状态码，分析出是什么情况吗？" class="headerlink" title="HTTP的状态码有哪些？如果出现某些错误的状态码，分析出是什么情况吗？"></a>HTTP的状态码有哪些？如果出现某些错误的状态码，分析出是什么情况吗？</h3><ol><li>状态码由三位数字组成，第一位数字表示响应的类型，常用的状态码有五大类如下所示：<br>　　1xx：表示服务器已接收了客户端请求，客户端可继续发送请求;<br>　　2xx：表示服务器已成功接收到请求并进行处理;<br>　　3xx：表示服务器要求客户端重定向;<br>　　4xx：表示客户端的请求有非法内容;<br>　　5xx：表示服务器未能正常处理客户端的请求而出现意外错误;</li><li>状态码描述文本有如下取值：<br>　　200 OK：表示客户端请求成功;<br>　　400 Bad Request：表示客户端请求有语法错误，不能被服务器所理解;<br>　　401 Unauthonzed：表示请求未经授权，该状态代码必须与 WWW-Authenticate 报头域一起使用;<br>　　403 Forbidden：表示服务器收到请求，但是拒绝提供服务，通常会在响应正文中给出不提供服务的原因;<br>　　404 Not Found：请求的资源不存在，例如，输入了错误的URL;<br>　　500 Internal Server Error：表示服务器发生不可预期的错误，导致无法完成客户端的请求;<br>　　503 Service Unavailable：表示服务器当前不能够处理客户端的请求，在一段时间之后，服务器可能会恢复正常;</li></ol><h3 id="网络5层模型，每一层有哪些协议以及每一层的作用"><a href="#网络5层模型，每一层有哪些协议以及每一层的作用" class="headerlink" title="网络5层模型，每一层有哪些协议以及每一层的作用"></a>网络5层模型，每一层有哪些协议以及每一层的作用</h3><p>五层体系结构包括：应用层、运输层、网络层、数据链路层和物理层。<br>    图片</p><h3 id="网络IO模型有哪些？5种网络I-O模型"><a href="#网络IO模型有哪些？5种网络I-O模型" class="headerlink" title="网络IO模型有哪些？5种网络I/O模型"></a>网络IO模型有哪些？5种网络I/O模型</h3><ol><li>阻塞</li><li>非阻塞</li><li>I/O多路复用</li><li>信号驱动IO</li><li>异步I/O</li></ol><h3 id="Session和Cookie的作用是什么？有什么区别？"><a href="#Session和Cookie的作用是什么？有什么区别？" class="headerlink" title="Session和Cookie的作用是什么？有什么区别？"></a>Session和Cookie的作用是什么？有什么区别？</h3><p>Cookie和Session都是用来跟踪浏览器用户身份的会话方式。<br>Session的主要作用就是通过服务端记录用户的状态。Session数据保存在服务器端。安全性相对较高。<br>Cookie一般用于保存用户信息。Cookie数据保存在客户端（浏览器端）</p><h3 id="Cookie被禁用怎么办？"><a href="#Cookie被禁用怎么办？" class="headerlink" title="Cookie被禁用怎么办？"></a>Cookie被禁用怎么办？</h3><p>最常用的就是利用URL重写把Session ID直接附加在URL路径后。</p><h3 id="HTTP1-0和HTTP1-1的主要区别是什么？"><a href="#HTTP1-0和HTTP1-1的主要区别是什么？" class="headerlink" title="HTTP1.0和HTTP1.1的主要区别是什么？"></a>HTTP1.0和HTTP1.1的主要区别是什么？</h3><ol><li>长连接：HTTP1.0中，默认使用短连接，每次请求都要重新建立一次连接。HTTP1.1默认使用长连接，默认开启Connection:keep-alive. HTTP1.1的持续连接有非流水线方式和流水线方式。流水线方式是客户在收到HTTP的响应报文之前就能接着发送新的请求报文。与之相对应的非流水线方式是客户在收到前一个响应后才能发送下一个请求。</li><li>错误状态响应码：HTTP1.1中新增了24个错误状态响应码，如409表示请求资源与资源当前状态发生冲突；410表示服务器上某资源被永久删除。</li><li>缓存处理：HTTP1.0中主要使用Header里的If-Modified-Since, Expires作为缓存判断的标准；HTTP1.1引入了更多的缓存控制策略，如Entity tag;If-Match，If-None-Match等更多可供选择的缓存头来控制缓存策略。</li><li>带宽优化及网络连接的使用：1.0不支持断点续传，存在浪费带宽现象；1.1在请求头引入range头域，允许只请求资源的某个部分，返回状态码是206（Partial Content），方便自由选择以便于充分利用带宽和连接。</li></ol><h3 id="URI和URL的区别是什么？"><a href="#URI和URL的区别是什么？" class="headerlink" title="URI和URL的区别是什么？"></a>URI和URL的区别是什么？</h3><ol><li>URI(Uniform Resource Identifier)是统一资源标志符，可唯一标识一个资源。</li><li>URL(Uniform Resource Location)是统一资源定位符，可提供该资源的路径。它是一种具体的URI，即URL可以用来标识一个资源，而且还指明了如何Locate这个资源。</li><li>URI的作用像身份证号，URL的作用更像家庭住址。URL是一种具体的URI，它不仅唯一标识资源，而且还提供了定位该资源的信息。</li></ol><h3 id="HTTP-协议包括哪些请求？"><a href="#HTTP-协议包括哪些请求？" class="headerlink" title="HTTP 协议包括哪些请求？"></a>HTTP 协议包括哪些请求？</h3><p>超文本传输协议（HTTP，HyperText Transfer Protocol)是互联网上应用最为广泛的一种网络协议。所有的WWW文件都必须遵守这个标准。</p><ul><li>GET：请求读取由URL所标志的信息。</li><li>POST：给服务器添加信息（如注释）。</li><li>PUT：在给定的URL下存储一个文档。</li><li>DELETE：删除给定的URL所标志的资源。</li></ul><h3 id="HTTP-中，-POST-与-GET-的区别"><a href="#HTTP-中，-POST-与-GET-的区别" class="headerlink" title="HTTP 中， POST 与 GET 的区别"></a>HTTP 中， POST 与 GET 的区别</h3><ol><li>Get是从服务器上获取数据，Post是向服务器传送数据。</li><li>Get是把参数数据队列加到提交表单的Action属性所指向的URL中，值和表单内各个字段一一对应，在URL中可以看到。</li><li>Get传送的数据量小，不能大于2KB；Post传送的数据量较大，一般被默认为不受限制。</li><li>根据HTTP规范，GET用于信息获取，而且应该是安全的和幂等的。<br> 4.1  所谓 安全的 意味着该操作用于获取信息而非修改信息。换句话说，GET请求一般不应产生副作用。就是说，它仅仅是获取资源信息，就像数据库查询一样，不会修改，增加数据，不会影响资源的状态。<br> 4.2  幂等 的意味着对同一URL的多个请求应该返回同样的结果。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> network </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis常考面试题目</title>
      <link href="2020/10/11/Redis%E5%B8%B8%E8%80%83%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE/"/>
      <url>2020/10/11/Redis%E5%B8%B8%E8%80%83%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE/</url>
      
        <content type="html"><![CDATA[<h3 id="Redis为什么这么快"><a href="#Redis为什么这么快" class="headerlink" title="Redis为什么这么快"></a>Redis为什么这么快</h3><ol><li>完全基于内存，绝大部分请求是纯粹的内存操作，非常快速。数据存在内存中，类似于HashMap，HashMap的优势就是查找和操作的时间复杂度都是O(1)；</li><li>数据结构简单，对数据操作也简单，Redis中的数据结构是专门进行设计的；</li><li>采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗 CPU，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗；</li><li>使用多路I/O复用模型，非阻塞IO；</li><li>使用底层模型不同，它们之间底层实现方式以及与客户端之间通信的应用协议不一样，Redis直接自己构建了VM 机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求；</li></ol><h3 id="Redis支持的数据类型和使用场景"><a href="#Redis支持的数据类型和使用场景" class="headerlink" title="Redis支持的数据类型和使用场景"></a>Redis支持的数据类型和使用场景</h3><ol><li>String  常规计数：微博数，粉丝数等。</li><li>Hash 适合存储对象</li><li>List 底层实现为双向链表，可反向查找和遍历。 应用场景：微博的关注列表，粉丝列表，消息列表等。</li><li>Set 可以自动去重   应用场景：共同关注、共同粉丝等。</li><li>Sorted Set 权重score使得集合中的元素可以按照score有序排列。 应用场景：礼物排行榜</li><li>5.0后Stream</li></ol><h3 id="Redis和Memecache的区别？"><a href="#Redis和Memecache的区别？" class="headerlink" title="Redis和Memecache的区别？"></a>Redis和Memecache的区别？</h3><ol><li>在数据类型支持方面  Redis在数据支持上要比memecache多,Redis不仅仅支持简单的k/v类型的数据结构，同时还提供list,set,zset,hash等数据结构的存储。memcache支持简单的数据类型String.</li><li>在存储方式方面   Memecache把数据全部存在内存之中，不能持久化数据； Redis支持数据的持久化（RDB和AOF两种）； </li><li>集群模式： Memecache没有原生的集群模式，需要依靠客户端实现往集群中分片写入数据；Redis原生支持cluster模式。</li><li>Memecache是多线程的，非阻塞IO复用的网络模型；Redis使用单线程的多路IO复用模型。</li></ol><h3 id="Redis持久化"><a href="#Redis持久化" class="headerlink" title="Redis持久化"></a>Redis持久化</h3><ol><li>快照（snapshotting）持久化（RDB） RDB是在不同的时间点，将Redis某一时刻的数据生成快照并存储到磁盘上。</li><li>AOF（append-only file）持久化  AOF是只允许追加不允许改写文件，是将Redis执行过的所有写指令记录下来，在下次redis重启的时候，只要把这些写指令从前到后重复执行一遍，就可以实现数据恢复。</li></ol><h3 id="Redis的缓存雪崩和缓存击穿"><a href="#Redis的缓存雪崩和缓存击穿" class="headerlink" title="Redis的缓存雪崩和缓存击穿"></a>Redis的缓存雪崩和缓存击穿</h3><p> <strong>缓存雪崩 ：</strong>缓存同一时间大面积失效，请求落到数据库上，短时间内数据库因承受大量请求而崩掉。 </p><ul><li>事前：尽量保证Redis集群的高可用性，选择合适的内存淘汰策略。</li><li>事中：本地ehcache缓存 + hystrix限流降级，避免数据库崩掉        </li><li>事后：利用Redis持久化机制保存的数据尽快恢复缓存。</li></ul><p><strong>缓存击穿：</strong> 大量请求的key不存在于缓存，导致大量请求不经过缓存这一层直接访问数据库。<br>解决方法： </p><ul><li>缓存无效key 若某个key缓存数据库都查不到，将其写入到redis并设置过期时间。</li><li>布隆过滤器</li></ul><h3 id="为什么redis的操作是原子的？"><a href="#为什么redis的操作是原子的？" class="headerlink" title="为什么redis的操作是原子的？"></a>为什么redis的操作是原子的？</h3><p>原子性是数据库的事务中的特性。在数据库事务的情景下，原子性指的是：一个事务（transaction）中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。</p><p>对于Redis而言，命令的原子性指的是：一个操作的不可以再分，操作要么执行，要么不执行。<br>Redis的操作之所以是原子性的，是因为<strong>Redis是单线程的。</strong></p><h3 id="Redis缓存淘汰策略"><a href="#Redis缓存淘汰策略" class="headerlink" title="Redis缓存淘汰策略"></a>Redis缓存淘汰策略</h3><p>6种数据淘汰策略：</p><ul><li>volatile-lru：从已设置过期时间的数据中挑选最近最少使用的数据淘汰；</li><li>volatile-ttl：从已设置过期时间的数据中挑选将要过期的数据淘汰；</li><li>volatile-random：从已设置过期时间的数据中任意选择数据淘汰；</li><li>allkeys-lru：从数据集中挑选最近最少使用的数据淘汰；</li><li> allkeys-random：从数据集中任意选择数据淘汰；</li><li>no-enviction（驱逐）：禁止驱逐数据</li></ul><p>注意这里的6种机制，volatile和allkeys规定了是对已设置过期时间的数据集淘汰数据还是从全部数据集淘汰数据，后面的lru、ttl以及random是三种不同的淘汰策略，再加上一种no-enviction永不回收的策略。</p><p>建议使用策略规则：<br>　1.  <em>如果数据呈现幂律分布，也就是一部分数据访问频率高，一部分数据访问频率低，则使用allkeys-lru</em><br>　2.  <em>如果数据呈现平等分布，也就是所有的数据访问频率都相同，则使用allkeys-random</em></p><h3 id="BloomFilter的原理"><a href="#BloomFilter的原理" class="headerlink" title="BloomFilter的原理"></a>BloomFilter的原理</h3><p>它实际上是一个很长的二进制向量和一系列随机映射函数。</p><p>布隆过滤器可以用于检索一个元素是否在一个集合中。它的优点是空间效率和查询时间都远远超过一般的算法，缺点是有一定的误识别率和删除困难。</p><p>Bloom Filter 是一种空间效率很高的随机数据结构，Bloom filter 可以看做是对 bit-map 的扩展, 它的原理是：</p><p>当一个元素被加入集合时，通过 K 个 Hash 函数将这个元素映射成一个位阵列（Bit array）中的 K 个点，把它们置为 1。检索时，我们只要看看这些点是不是都是 1 就（大约）知道集合中有没有它。</p><p>如果这些点有任何一个 0，则被检索元素一定不在；如果都是 1，则被检索元素很可能在。</p><h3 id="zset底层存储结构"><a href="#zset底层存储结构" class="headerlink" title="zset底层存储结构"></a>zset底层存储结构</h3><p>zset底层的存储结构包括ziplist或skiplist，在同时满足以下两个条件的时候使用ziplist，其他时候使用skiplist，<br>两个条件如下：</p><ol><li>有序集合保存的元素数量小于128个</li><li>有序集合保存的所有元素的长度小于64字节</li></ol><p>当ziplist作为zset的底层存储结构时候，每个集合元素使用两个紧挨在一起的压缩列表节点来保存，第一个节点保存元素的成员，第二个元素保存元素的分值。</p><p> 当skiplist作为zset的底层存储结构的时候，使用skiplist按序保存元素及分值，使用dict来保存元素和分值的映射关系。</p>]]></content>
      
      
      <categories>
          
          <category> 面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql面试高频题目</title>
      <link href="2020/10/07/Mysql%E9%9D%A2%E8%AF%95%E9%AB%98%E9%A2%91%E9%A2%98%E7%9B%AE/"/>
      <url>2020/10/07/Mysql%E9%9D%A2%E8%AF%95%E9%AB%98%E9%A2%91%E9%A2%98%E7%9B%AE/</url>
      
        <content type="html"><![CDATA[<h2 id="说说MySQL有哪些存储引擎、都有哪些区别"><a href="#说说MySQL有哪些存储引擎、都有哪些区别" class="headerlink" title="说说MySQL有哪些存储引擎、都有哪些区别"></a>说说MySQL有哪些存储引擎、都有哪些区别</h2><ol><li>一个数据库中多个表可以使用不同引擎以满足各种性能和实际需求。常见的存储引擎就 InnoDB、MyISAM、Memory、NDB。InnoDB 是 MySQL 默认的存储引擎，支持事务、行级锁定和外键。</li><li>InnoDB 支持事务，MyISAM不支持事务。这是 MySQL 将默认存储引擎从 MyISAM 变成 InnoDB 的重要原因之一；</li><li>InnoDB 支持外键，而 MyISAM 不支持。对一个包含外键的 InnoDB 表转为 MYISAM 会失败；</li><li>InnoDB 是聚簇索引，MyISAM 是非聚簇索引。聚簇索引的文件存放在主键索引的叶子节点上，因此 InnoDB 必须要有主键，通过主键索引效率很高。 MyISAM 是非聚集索引，数据文件是分离的，索引保存的是数据文件的指针。主键索引和辅助索引是独立的。</li><li>InnoDB 不保存表的具体行数，执行select count(*) from table 时需要全表扫描。而 MyISAM 用一个变量保存了整个表的行数，执行上述语句时只需要读出该变量即可，速度很快；</li><li>InnoDB 最小的锁粒度是行锁，MyISAM 最小的锁粒度是表锁。一个更新语句会锁住整张表，导致其他查询和更新都会被阻塞，因此并发访问受限。这也是 MySQL 将默认存储引擎从 MyISAM 变成 InnoDB 的重要原因之一</li></ol><h3 id="一张表，里面有ID自增主键，当insert了17条记录之后，删除了第15-16-17条记录，再把Mysql重启，再insert一条记录，这条记录的ID是18还是15-？"><a href="#一张表，里面有ID自增主键，当insert了17条记录之后，删除了第15-16-17条记录，再把Mysql重启，再insert一条记录，这条记录的ID是18还是15-？" class="headerlink" title="一张表，里面有ID自增主键，当insert了17条记录之后，删除了第15,16,17条记录，再把Mysql重启，再insert一条记录，这条记录的ID是18还是15 ？"></a>一张表，里面有ID自增主键，当insert了17条记录之后，删除了第15,16,17条记录，再把Mysql重启，再insert一条记录，这条记录的ID是18还是15 ？</h3><ol><li>如果表的类型是MyISAM，那么是18。因为MyISAM表会把自增主键的最大ID 记录到数据文件中，重启MySQL自增主键的最大ID也不会丢失；</li><li>如果表的类型是InnoDB，那么是15。因为InnoDB 表只是把自增主键的最大ID记录到内存中，所以重启数据库或对表进行OPTION操作，都会导致最大ID丢失。</li></ol><h3 id="哪个存储引擎执行-select-count-更快，为什么"><a href="#哪个存储引擎执行-select-count-更快，为什么" class="headerlink" title="哪个存储引擎执行 select count(*) 更快，为什么"></a>哪个存储引擎执行 select count(*) 更快，为什么</h3><ol><li>MyISAM更快，因为MyISAM内部维护了一个计数器，可以直接调取。在 MyISAM 存储引擎中，把表的总行数存储在磁盘上，当执行 select count(*) from t 时，直接返回总数据。</li><li>在 InnoDB 存储引擎中，跟 MyISAM 不一样，没有将总行数存储在磁盘上，当执行 select count(*) from t 时，会先把数据读出来，一行一行的累加，最后返回总数量。</li></ol><h2 id="为什么Mysql索引要用B-树不是B树"><a href="#为什么Mysql索引要用B-树不是B树" class="headerlink" title="为什么Mysql索引要用B+树不是B树"></a>为什么Mysql索引要用B+树不是B树</h2><p>用B+树不用B树考虑的是IO对性能的影响，B树的每个节点都存储数据，而B+树只有叶子节点才存储数据，所以查找相同数据量的情况下，B树的高度更高，IO更频繁。</p><p>数据库索引是存储在磁盘上的，当数据量大时，就不能把整个索引全部加载到内存了，只能逐一加载每一个磁盘页（对应索引树的节点）。</p><p>其中在MySQL底层对B+树进行进一步优化：在叶子节点中是双向链表，且在链表的头结点和尾节点也是循环指向的。</p><h4 id="为何不采用Hash方式？"><a href="#为何不采用Hash方式？" class="headerlink" title="为何不采用Hash方式？"></a>为何不采用Hash方式？</h4><p>因为Hash索引底层是哈希表，哈希表是一种以key-value存储数据的结构，所以多个数据在存储关系上是完全没有任何顺序关系的，所以，对于区间查询是无法直接通过索引查询的，就需要全表扫描。所以，哈希索引只适用于等值查询的场景。</p><p>而B+ Tree是一种多路平衡查询树，所以他的节点是天然有序的（左子节点小于父节点、父节点小于右子节点），所以对于范围查询的时候不需要做全表扫描。</p><p>哈希索引不支持多列联合索引的最左匹配规则，如果有大量重复键值的情况下，哈希索引的效率会很低，因为存在哈希碰撞问题。</p><h2 id="通俗地理解三个范式"><a href="#通俗地理解三个范式" class="headerlink" title="通俗地理解三个范式"></a>通俗地理解三个范式</h2><p>　　通俗地理解三个范式，对于数据库设计大有好处。在数据库设计中，为了更好地应用三个范式，就必须通俗地理解<br>　　三个范式(通俗地理解是够用的理解，并不是最科学最准确的理解)<br><strong>第一范式：</strong>1NF是对属性的原子性约束，要求属性具有原子性，不可再分解；<br><strong>第二范式：</strong>2NF是对记录的惟一性约束，要求记录有惟一标识，即实体的惟一性；<br><strong>第三范式：</strong>3NF是对字段冗余性的约束，即任何字段不能由其他字段派生出来，它要求字段没有冗余。</p><p>　　没有冗余的数据库设计可以做到。但是，没有冗余的数据库未必是最好的数据库，有时为了提高运行效率，就必须降<br>　　低范式标准，适当保留冗余数据。具体做法是：在概念数据模型设计时遵守第三范式，降低范式标准的工作放到物理<br>　　数据模型设计时考虑。降低范式就是增加字段，允许冗余。</p><h2 id="MySQL索引分类"><a href="#MySQL索引分类" class="headerlink" title="MySQL索引分类"></a>MySQL索引分类</h2><ol><li>数据结构角度</li></ol><ul><li>B+树索引</li><li>Hash索引</li><li>Full-Text全文索引</li><li>R-Tree索引</li></ul><ol start="2"><li>从物理存储角度</li></ol><ul><li>聚集索引（clustered index）</li><li>非聚集索引（non-clustered index），也叫辅助索引（secondary index）</li><li>聚集索引和非聚集索引都是B+树结构</li></ul><ol start="3"><li>从逻辑角度</li></ol><ul><li>主键索引：主键索引是一种特殊的唯一索引，不允许有空值</li><li>普通索引或者单列索引：每个索引只包含单个列，一个表可以有多个单列索引</li><li>多列索引（复合索引、联合索引）：复合索引指多个字段上创建的索引，只有在查询条件中使用了创建索引时的第一个字段，索引才会被使用。使用复合索引时遵循最左前缀集合</li><li>唯一索引或者非唯一索引</li><li>空间索引：空间索引是对空间数据类型的字段建立的索引，MYSQL中的空间数据类型有4种，分别是GEOMETRY、POINT、LINESTRING、POLYGON。MYSQL使用SPATIAL关键字进行扩展，使得能够用于创建正规索引类型的语法创建空间索引。创建空间索引的列，必须将其声明为NOT NULL，空间索引只能在存储引擎为MYISAM的表中创建</li></ul><h2 id="哪些情况需要创建索引"><a href="#哪些情况需要创建索引" class="headerlink" title="哪些情况需要创建索引"></a>哪些情况需要创建索引</h2><ol><li>主键自动建立唯一索引</li><li>频繁作为查询条件的字段</li><li>查询中与其他表关联的字段，外键关系建立索引</li><li>单键/组合索引的选择问题，高并发下倾向创建组合索引</li><li>查询中排序的字段，排序字段通过索引访问大幅提高排序速度</li><li>查询中统计或分组字段</li></ol><h2 id="哪些情况不要创建索引"><a href="#哪些情况不要创建索引" class="headerlink" title="哪些情况不要创建索引"></a>哪些情况不要创建索引</h2><ol><li>表记录太少</li><li>经常增删改的表</li><li>数据重复且分布均匀的表字段，只应该为最经常查询和最经常排序的数据列建立索引（如果某个数据类包含太多的重复数据，建立索引没有太大意义）</li><li>频繁更新的字段不适合创建索引（会加重IO负担）</li><li>where条件里用不到的字段不创建索引</li></ol><h2 id="MySQL中-in和-exists-的区别？"><a href="#MySQL中-in和-exists-的区别？" class="headerlink" title="MySQL中 in和 exists 的区别？"></a>MySQL中 in和 exists 的区别？</h2><ol><li>exists：<strong>exists对外表用loop逐条查询</strong>，每次查询都会查看exists的条件语句，当exists里的条件语句能够返回记录行时（无论记录行是的多少，只要能返回），条件就为真，返回当前loop到的这条记录；反之，如果exists里的条件语句不能返回记录行，则当前loop到的这条记录被丢弃，exists的条件就像一个bool条件，当能返回结果集则为true，不能返回结果集则为false</li><li>in：in查询相当于多个or条件的叠加  in在查询的时候，首先查询子查询的表，然后<strong>将内表和外表做一个笛卡尔积</strong>，然后按照条件进行筛选。所以相对内表比较小的时候，in的速度较快。</li><li>如果查询的两个表大小相当，那么用in和exists差别不大。如果两个表中一个较小，一个是大表，则子查询表大的用exists，子查询表小的用in</li></ol><h2 id="哪些情况会使索引失效？"><a href="#哪些情况会使索引失效？" class="headerlink" title="哪些情况会使索引失效？"></a>哪些情况会使索引失效？</h2><ol><li>使用不等于（！= 或者&lt;&gt;）不能使用索引</li><li>单独的&gt;,&lt;,(有时会用到，有时不会)</li><li>like “%_” 百分号在前.</li><li>单独引用复合索引里非第一位置的索引列.</li><li>字符型字段为数字时在where条件里不添加引号.</li><li>对索引列进行运算.需要建立函数索引.</li><li>not in ,not exists.</li><li>当变量采用的是times变量，而表的字段采用的是date变量时.或相反情况。</li></ol><h2 id="事务的四大特性（ACID）"><a href="#事务的四大特性（ACID）" class="headerlink" title="事务的四大特性（ACID）"></a>事务的四大特性（ACID）</h2><h3 id="原子性（Atomicity）"><a href="#原子性（Atomicity）" class="headerlink" title="原子性（Atomicity）"></a>原子性（Atomicity）</h3><p>原子性是指事务包含的所有操作要么全部成功，要么全部失败回滚，事务的操作如果成功就必须要完全应用到数据库，如果操作失败则不能对数据库有任何影响。</p><h3 id="一致性（Consistency）"><a href="#一致性（Consistency）" class="headerlink" title="一致性（Consistency）"></a>一致性（Consistency）</h3><p>一致性是指事务必须使数据库从一个一致性状态变换到另一个一致性状态，也就是说一个事务执行之前和执行之后都必须处于一致性状态。</p><h3 id="隔离性（Isolation）"><a href="#隔离性（Isolation）" class="headerlink" title="隔离性（Isolation）"></a>隔离性（Isolation）</h3><p>隔离性是当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。</p><h3 id="持久性（Durability）"><a href="#持久性（Durability）" class="headerlink" title="持久性（Durability）"></a>持久性（Durability）</h3><p>持久性是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。</p><p>　　例如我们在使用JDBC操作数据库时，在提交事务方法后，提示用户事务操作完成，当我们程序执行完成直到看到提示后，就可以认定事务已经正确提交，即使这时候数据库出现了问题，也必须要将我们的事务完全执行完成，否则就会造成我们看到提示事务处理完毕，但是数据库因为故障而没有执行事务的重大错误。</p><h2 id="不考虑事务的隔离性，可能会发生的几种问题"><a href="#不考虑事务的隔离性，可能会发生的几种问题" class="headerlink" title="不考虑事务的隔离性，可能会发生的几种问题"></a>不考虑事务的隔离性，可能会发生的几种问题</h2><ol><li>脏读<br> 脏读是指在一个事务处理过程里读取了另一个未提交的事务中的数据。</li><li>不可重复读<br> 不可重复读是指在对于数据库中的某个数据，一个事务范围内多次查询却返回了不同的数据值，这是由于在查询间隔，被另一个事务修改并提交了。</li><li>幻读<br> 相同的查询条件首次查询后，其他事务添加或删除了新的数据，再次查询不一致</li></ol><h2 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h2><p>数据库事务的隔离级别有4种，由低到高分别为</p><ul><li> READ-UNCOMMITTED(未提交读)： 最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。</li><li>  READ-COMMITTED(已提交读)： 允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生。Oracle的默认事务隔离级别</li><li> REPEATABLE-READ(可重复读)： 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。 MySQL的默认事务隔离级别。</li><li> SERIALIZABLE(可串行化)： 最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。 开销过大</li></ul>]]></content>
      
      
      <categories>
          
          <category> 面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线程进程相关面试题</title>
      <link href="2020/10/05/%E7%BA%BF%E7%A8%8B%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>2020/10/05/%E7%BA%BF%E7%A8%8B%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h3 id="如何创建线程"><a href="#如何创建线程" class="headerlink" title="如何创建线程"></a>如何创建线程</h3><ol><li>继承Thread类    重写run方法</li><li>实现Runnable接口    重写run方法</li><li>实现Callable接口 Callable的 call() 方法可以返回值和抛出异常</li><li>可以使用Executor框架来创建线程池</li></ol><h3 id="Thread-类中的start-和-run-方法有什么区别？"><a href="#Thread-类中的start-和-run-方法有什么区别？" class="headerlink" title="Thread 类中的start() 和 run()方法有什么区别？"></a>Thread 类中的start() 和 run()方法有什么区别？</h3><p>start()方法被用来启动新创建的线程，而且start()内部调用了run()方法，这和直接调用run()方法的效果不一样。<br>当你调用run()方法的时候，只会是在原来的线程中调用执行，没有新的线程启动，start()方法才会启动新线程。</p><h3 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h3><p>首先从定义上理解就有所不同</p><ol><li>进程是具有一定独立功能的程序、它是系统进行资源分配和调度的一个独立单位，重点在系统调度和单独的单位，也就是说进程是可以独立运行的一段程序。</li><li>线程是进程的一个实体，是CPU调度和分派的基本单位，他是比进程更小的能独立运行的基本单位，线程自己基本上不拥有系统资源。在运行时，只是暂用一些计数器、寄存器和栈 。</li></ol><h4 id="他们之间的关系"><a href="#他们之间的关系" class="headerlink" title="他们之间的关系"></a>他们之间的关系</h4><p>一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程（通常说的主线程）。<br>    资源分配给进程，同一进程的所有线程共享该进程的所有资源。<br>    线程在执行过程中，需要协作同步。不同进程的线程间要利用消息通信的办法实现同步。<br>    处理机分给线程，即真正在处理机上运行的是线程。<br>    线程是指进程内的一个执行单元，也是进程内的可调度实体。</p><h4 id="从三个角度来剖析二者之间的区别"><a href="#从三个角度来剖析二者之间的区别" class="headerlink" title="从三个角度来剖析二者之间的区别"></a>从三个角度来剖析二者之间的区别</h4><ol><li>调度：线程作为调度和分配的基本单位，进程作为拥有资源的基本单位。</li><li>并发性：不仅进程之间可以并发执行，同一个进程的多个线程之间也可以并发执行。</li><li>拥有资源：进程是拥有资源的一个独立单位，线程不拥有系统资源，但可以访问隶属于进程的资源。</li></ol><h3 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h3><ol><li>协程，又称微线程，纤程。英文名Coroutine。一句话说明什么是线程：协程是一种用户态的轻量级线程。</li><li>协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈。因此：协程能保留上一次调用时的状态（即所有局部状态的一个特定组合），每次过程重入时，就相当于进入上一次调用的状态，换种说法：进入上一次离开时所处逻辑流的位置。</li></ol><h4 id="协程的好处"><a href="#协程的好处" class="headerlink" title="协程的好处"></a>协程的好处</h4><ol><li>无需线程上下文切换的开销</li><li>无需原子操作锁定及同步的开销</li><li>方便切换控制流，简化编程模型</li><li>高并发+高扩展性+低成本：一个CPU支持上万的协程都不是问题。所以很适合用于高并发处理。</li></ol><h4 id="协程的缺点"><a href="#协程的缺点" class="headerlink" title="协程的缺点"></a>协程的缺点</h4><ol><li>无法利用多核资源：协程的本质是个单线程,它不能同时将单个CPU的多个核用上,协程需要和进程配合才能运行在多CPU上.当然我们日常所编写的绝大部分应用都没有这个必要，除非是cpu密集型应用。</li><li>进行阻塞（Blocking）操作（如IO时）会阻塞掉整个程序</li></ol><h3 id="多线程间通信方式"><a href="#多线程间通信方式" class="headerlink" title="多线程间通信方式"></a>多线程间通信方式</h3><ol><li>共享变量        线程间发送信号的一个简单方式是在共享对象的变量里设置信号值  synchronized </li><li>wait/notify机制        为了实现线程通信，我们可以使用Object类提供的wait()、notify()、notifyAll()三个方法。调用wait()方法会释放对该同步监视器的锁定。</li><li>Lock/Condition机制   如果程序不使用synchronized关键字来保持同步，而是直接使用Lock对象来保持同步，则系统中不存在隐式的同步监视器对象，也就不能使用wait()、notify()、notifyAll()来协调线程的运行.</li><li>管道</li></ol><h3 id="进程间通信方式"><a href="#进程间通信方式" class="headerlink" title="进程间通信方式"></a>进程间通信方式</h3><ol><li>管道（Pipe） ：管道可用于具有亲缘关系进程间的通信，允许一个进程和另一个与它有共同祖先的进程之间进行通信。</li><li>命名管道（named pipe） ：命名管道克服了管道没有名字的限制，因此，除具有管道所具有的功能外，它还允许无亲缘关系进程间的通信。命名管道在文件系统中有对应的文件名。命名管道通过命令mkfifo或系统调用mkfifo来创建。</li><li>信号（Signal） ：信号是比较复杂的通信方式，用于通知接受进程有某种事件发生，除了用于进程间通信外，进程还可以发送信号给进程本身；Linux除了支持Unix早期信号语义函数sigal外，还支持语义符合Posix.1标准的信号函数sigaction（实际上，该函数是基于BSD的，BSD为了实现可靠信号机制，又能够统一对外接口，用sigaction函数重新实现了signal函数）。</li><li>消息（Message）队列 ：消息队列是消息的链接表，包括Posix消息队列system V消息队列。有足够权限的进程可以向队列中添加消息，被赋予读权限的进程则可以读走队列中的消息。消息队列克服了信号承载信息量少，管道只能承载无格式字节流以及缓冲区大小受限等缺</li><li>共享内存 ：使得多个进程可以访问同一块内存空间，是最快的可用IPC形式。是针对其他通信机制运行效率较低而设计的。往往与其它通信机制，如信号量结合使用，来达到进程间的同步及互斥。</li><li>内存映射（mapped memory）：内存映射允许任何多个进程间通信，每一个使用该机制的进程通过把一个共享的文件映射到自己的进程地址空间来实现它。</li><li>信号量（semaphore） ：主要作为进程间以及同一进程不同线程之间的同步手段。</li><li>套接口（Socket） ：更为一般的进程间通信机制，可用于不同机器之间的进程间通信。起初是由Unix系统的BSD分支开发出来的，但现在一般可以移植到其它类Unix系统上：linux和System V的变种都支持套接字。</li></ol><h3 id="Java常见的线程安全的类实现方式"><a href="#Java常见的线程安全的类实现方式" class="headerlink" title="Java常见的线程安全的类实现方式"></a>Java常见的线程安全的类实现方式</h3><ol><li>通过synchronized 关键字给方法加上内置锁来实现线程安全    Timer，TimerTask，Vector，Stack，HashTable，StringBuffer</li><li>原子类Atomicxxx—包装类的线程安全类        如AtomicLong，AtomicInteger等等        Atomicxxx 是通过Unsafe 类的native方法实现线程安全的</li><li>BlockingQueue 和BlockingDeque<br>BlockingDeque接口继承了BlockingQueue接口，<br>BlockingQueue 接口的实现类有ArrayBlockingQueue ，LinkedBlockingQueue ，PriorityBlockingQueue 而BlockingDeque接口的实现类有LinkedBlockingDeque<br>BlockingQueue和BlockingDeque 都是通过使用定义为final的ReentrantLock作为类属性显式加锁实现同步的</li><li>CopyOnWriteArrayList和 CopyOnWriteArraySet<br>CopyOnWriteArraySet的内部实现是在其类内部声明一个final的CopyOnWriteArrayList属性，并在调用其构造函数时实例化该CopyOnWriteArrayList，CopyOnWriteArrayList采用的是显式地加上ReentrantLock实现同步，而CopyOnWriteArrayList容器的线程安全性在于在每次修改时都会创建并重新发布一个新的容器副本，从而实现可变性。</li><li>Concurrentxxx<br>最常用的就是ConcurrentHashMap，当然还有ConcurrentSkipListSet和ConcurrentSkipListMap等等。<br>ConcurrentHashMap使用了一种完全不同的加锁策略来提供更高的并发性和伸缩性。ConcurrentHashMap并不是将每个方法都在同一个锁上同步并使得每次只能有一个线程访问容器，而是使用一种粒度更细的加锁机制——分段锁来实现更大程度的共享；在这种机制中，任意数量的读取线程可以并发访问Map，执行读取操作的线程和执行写入操作的线程可以并发地访问Map，并且一定数量的写入线程可以并发地修改Map，这使得在并发环境下吞吐量更高，而在单线程环境中只损失非常小的性能</li><li>ThreadPoolExecutor        ThreadPoolExecutor也是使用了ReentrantLock显式加锁同步</li><li>Collections中的synchronizedCollection(Collection c)方法可将一个集合变为线程安全，其内部通过synchronized关键字加锁同步</li></ol><h3 id="怎么判断乐观锁是否被修改过？"><a href="#怎么判断乐观锁是否被修改过？" class="headerlink" title="怎么判断乐观锁是否被修改过？"></a>怎么判断乐观锁是否被修改过？</h3><p>使用数据版本（Version）记录机制实现，这是乐观锁最常用的一种实现方式。何谓数据版本？即为数据增加一个版本标识，一般是通过为数据库表增加一个数字类型的 “version” 字段来实现。</p><h3 id="产生死锁的四个必要条件，如何解决？"><a href="#产生死锁的四个必要条件，如何解决？" class="headerlink" title="产生死锁的四个必要条件，如何解决？"></a>产生死锁的四个必要条件，如何解决？</h3><ol><li>互斥条件：一个资源每次只能被一个进程使用。</li><li>请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。</li><li>不剥夺条件:进程已获得的资源，在末使用完之前，不能强行剥夺。</li><li>循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。</li></ol><h3 id="处理死锁的思路如下："><a href="#处理死锁的思路如下：" class="headerlink" title="处理死锁的思路如下："></a>处理死锁的思路如下：</h3><ol><li>预防死锁：破坏四个必要条件中的一个或多个来预防死锁</li><li>避免死锁：在资源动态分配的过程中，用某种方式防止系统进入不安全的状态。</li><li>检测死锁：运行时产生死锁，及时发现思索，将程序解脱出来。</li><li>解除死锁：发生死锁后，撤销进程，回收资源，分配给正在阻塞状态的进程。</li></ol><h3 id="预防死锁的办法："><a href="#预防死锁的办法：" class="headerlink" title="预防死锁的办法："></a>预防死锁的办法：</h3><ol><li>破坏请求和保持条件：1.一次性的申请所有资源。之后不再申请资源，如果不满足资源条件则得不到资源分配。2.只获得初期资源运行，之后将运行完的资源释放，请求新的资源。</li><li>破坏不可抢占条件：当一个进程获得某种不可抢占资源，提出新的资源申请，若不能满足，则释放所有资源，以后需要，再次重新申请。</li><li>破坏循环等待条件：对资源进行排号，按照序号递增的顺序请求资源。若进程获得序号高的资源想要获取序号低的资源，就需要先释放序号高的资源。</li></ol><h3 id="死锁的解除办法："><a href="#死锁的解除办法：" class="headerlink" title="死锁的解除办法："></a>死锁的解除办法：</h3><ol><li>抢占资源。从一个或多个进程中抢占足够数量的资源，分配给死锁进程，以解除死锁状态。</li><li>终止（撤销）进程：将一个或多个思索进程终止（撤销），直至打破循环环路，使系统从死锁状态解脱。</li></ol><h3 id="Java锁有哪些，具体的原理是什么，之间有什么区别"><a href="#Java锁有哪些，具体的原理是什么，之间有什么区别" class="headerlink" title="Java锁有哪些，具体的原理是什么，之间有什么区别"></a>Java锁有哪些，具体的原理是什么，之间有什么区别</h3><ol><li>公平锁/非公平锁    公平锁是指多个线程按照申请锁的顺序来获取锁。非公平锁是指多个线程获取锁的顺序并不是按照申请锁的顺序，有可能后申请的线程比先申请的线程优先获取锁。有可能，会造成优先级反转或者饥饿现象。   对于Java ReentrantLock而言，通过构造函数指定该锁是否是公平锁，默认是非公平锁。非公平锁的优点在于吞吐量比公平锁大。对于Synchronized而言，也是一种非公平锁。由于其并不像ReentrantLock是通过AQS来实现线程调度，所以并没有任何办法使其变成公平锁。</li><li>可重入锁    可重入锁又名递归锁，是指在同一个线程在外层方法获取锁的时候，在进入内层方法会自动获取锁。ReentrantLock Synchronized 是可重入锁。可重入锁的一个好处是可一定程度避免死锁。</li><li>独享锁/共享锁        独享锁是指该锁一次只能被一个线程所持有。共享锁是指该锁可被多个线程所持有。ReentrantLock Synchronized 是独享锁。Lock的另一个实现类ReadWriteLock，其读锁是共享锁，其写锁是独享锁。独享锁与共享锁也是通过AQS(AbstractQueuedSynchronizer)来实现的，通过实现不同的方法，来实现独享或者共享。</li><li>互斥锁/读写锁        互斥锁在Java中的具体实现就是ReentrantLock。    读写锁在Java中的具体实现就是ReadWriteLock</li><li>乐观锁/悲观锁        悲观锁认为对于同一个数据的并发操作，一定是会发生修改的，哪怕没有修改，也会认为修改。因此对于同一个数据的并发操作，悲观锁采取加锁的形式。悲观的认为，不加锁的并发操作一定会出问题。乐观锁则认为对于同一个数据的并发操作，是不会发生修改的。在更新数据的时候，会采用尝试更新，不断重新的方式更新数据。乐观的认为，不加锁的并发操作是没有事情的。悲观锁在Java中的使用，就是利用各种锁。乐观锁在Java中的使用，是无锁编程，常常采用的是CAS算法，典型的例子就是原子类，通过CAS自旋实现原子操作的更新</li><li>分段锁    分段锁其实是一种锁的设计，并不是具体的一种锁，对于ConcurrentHashMap而言，其并发的实现就是通过分段锁的形式来实现高效的并发操作。ConcurrentHashMap中的分段锁称为Segment，它即类似于HashMap（JDK7与JDK8中HashMap的实现）的结构，即内部拥有一个Entry数组，数组中的每个元素又是一个链表；同时又是一个ReentrantLock（Segment继承了ReentrantLock)。当需要put元素的时候，并不是对整个hashmap进行加锁，而是先通过hashcode来知道他要放在那一个分段中，然后对这个分段进行加锁，所以当多线程put的时候，只要不是放在一个分段中，就实现了真正的并行的插入。        分段锁的设计目的是细化锁的粒度，当操作不需要更新整个数组的时候，就仅仅针对数组中的一项进行加锁操作。</li><li>偏向锁/轻量级锁/重量级锁        锁的状态，并且是针对Synchronized。偏向锁是指一段同步代码一直被一个线程所访问，那么该线程会自动获取锁。降低获取锁的代价。<br>轻量级锁是指当锁是偏向锁的时候，被另一个线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，提高性能。<br>重量级锁是指当锁为轻量级锁的时候，另一个线程虽然是自旋，但自旋不会一直持续下去，当自旋一定次数的时候，还没有获取到锁，就会进入阻塞，该锁膨胀为重量级锁。重量级锁会让其他申请的线程进入阻塞，性能降低。</li><li>自旋锁    自旋锁是指尝试获取锁的线程不会立即阻塞，而是采用循环的方式去尝试获取锁，这样的好处是减少线程上下文切换的消耗，缺点是循环会消耗CPU。</li></ol><h3 id="sleep-和wait-方法的区别和共同点"><a href="#sleep-和wait-方法的区别和共同点" class="headerlink" title="sleep()和wait()方法的区别和共同点"></a>sleep()和wait()方法的区别和共同点</h3><ol><li>最主要的区别是sleep()不释放锁，wait()会释放锁。</li><li>两者皆可暂停线程的执行。</li><li>wait()常用于线程交互/通信，sleep()常用于暂停执行。</li><li>wait()方法调用后，线程不会自动苏醒，需要别的线程调用同一对象的notify() 或notifyAll()方法。sleep()方法执行完，会自动苏醒。或者可以使用wait(long timeout)超时自动苏醒。</li></ol><h3 id="synchronized-底层是如何优化的"><a href="#synchronized-底层是如何优化的" class="headerlink" title="synchronized 底层是如何优化的"></a>synchronized 底层是如何优化的</h3><ol><li><p>在 Java 早期版本中，synchronized 属于重量级锁，效率低下，因为监视器锁（monitor）是依赖于底层的操作系统的 Mutex Lock 来实现的，Java 的线程是映射到操作系统的原生线程之上的。如果要挂起或者唤醒一个线程，都需要操作系统帮忙完成，而操作系统实现线程之间的切换时需要从用户态转换到内核态，这个状态之间的转换需要相对比较长的时间，时间成本相对较高，这也是为什么早期的 synchronized 效率低的原因。</p></li><li><p>JDK1.6 对锁的实现引入了大量的优化，如偏向锁、轻量级锁、自旋锁、适应性自旋锁、锁消除、锁粗化等技术来减少锁操作的开销。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM高频面试题目</title>
      <link href="2020/10/03/JVM%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE/"/>
      <url>2020/10/03/JVM%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE/</url>
      
        <content type="html"><![CDATA[<h3 id="简单描述一下JVM的内存模型"><a href="#简单描述一下JVM的内存模型" class="headerlink" title="简单描述一下JVM的内存模型"></a>简单描述一下JVM的内存模型</h3><p>jvm内存主要分为五个部分：<strong>方法区，java堆，java栈，程序计数器，本地方法栈。</strong></p><ol><li><strong>方法区（永久代，线程共享）</strong>：存储被虚拟机加载的类信息，常量，静态常量，静态方法，运行时常量池等。</li><li><strong>java堆（线程共享）</strong>：存放所有new出来的东西。    1.堆是java虚拟机所管理的内存区域中最大的一块，java堆是被所有线程共享的内存区域，在java虚拟机启动时创建，堆内存的唯一目的就是存放对象实例，几乎所有的对象实例都在堆内存分配空间。2.堆是GC管理的主要区域，从垃圾回收的角度看，由于现在的垃圾收集器都是采用的分代收集算法，因此java堆还可以初步细分为新生代和老年代。</li><li><strong>java栈（线程私有方法级）</strong>：为虚拟机执使用到的方法服务。每个方法被调用的时候都会创建一个栈帧，用于存储局部变量表、操作栈、动态链接、方法出口等信息。局部变量表存放的是：编译期可知的基本数据类型、对象引用类型。</li><li><strong>程序计数器（线程私有）</strong>：保证线程切换后能恢复到原来的位置。在线程创建时创建，指向下一条指令的地址，执行本地方法时，其值为undefined。为了线程切换后能够恢复到正确的执行位置，每条线程都有一个独立的程序计数器，这块儿属于“线程私有”的内存。</li><li><strong>本地方法栈（线程私有）</strong>：为虚拟机执使用到的Native方法服务。本地方法栈则为虚拟机执使用到的Native方法服务，本地方法栈也会抛出StackOverFlowError和OutOfMemoryError。</li></ol><h3 id="什么情况下会触发FullGC"><a href="#什么情况下会触发FullGC" class="headerlink" title="什么情况下会触发FullGC?"></a>什么情况下会触发FullGC?</h3><ol><li>System.gc()方法的调用。此方法的调用是建议JVM进行Full GC,虽然只是建议而非一定，但很多情况下它会触发Full GC,从而增加Full GC的频率，也即增加了间歇性停顿的次数。</li><li>旧生代空间不足。旧生代空间只有在新生代对象转入及创建大对象、大数组时才会出现不足的现象，当执行Full GC后空间仍然不足，则抛出错误：java.lang.OutOfMemoryError: Java heap space 。</li><li>Permanet Generation空间满了。Permanet Generation中存放的为一些class的信息等，当系统中要加载的类、反射的类和调用的方法较多时，Permanet Generation可能会被占满，在未配置为采用CMS GC的情况下会执行Full GC。</li><li>通过Minor GC后进入老年代的平均大小大于老年代的可用内存。如果发现统计数据说之前Minor GC的平均晋升大小比目前old gen剩余的空间大，则不会触发Minor GC而是转为触发full GC。</li><li>由Eden区、From Space区向To Space区复制时，对象大小大于To Space可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小</li></ol><h3 id="Java类加载器有几种，关系是怎么样的？"><a href="#Java类加载器有几种，关系是怎么样的？" class="headerlink" title="Java类加载器有几种，关系是怎么样的？"></a>Java类加载器有几种，关系是怎么样的？</h3><ol><li><strong>引导类加载器（启动类加载器）</strong> bootstrap class loader    由C++编写，无法通过程序得到。主要负责加载JAVA中的一些核心类库。它负责将 /lib路径下的核心类库或-Xbootclasspath参数指定的路径下的jar包加载到内存中</li><li><strong>扩展类加载器</strong> extensions class loader    负责加载JAVA_HOME/lib/ext目录下或者由系统变量-Djava.ext.dir指定位路径中的类库，开发者可以直接使用标准扩展类加载器。</li><li><strong>系统类加载器</strong> application class loader    它负责加载系统类路径java -classpath或-D java.class.path 指定路径下的类库，也就是我们经常用到的classpath路径，开发者可以直接使用系统类加载器，一般情况下该类加载是程序中默认的类加载器，通过ClassLoader#getSystemClassLoader()方法可以获取到该类加载器。</li><li><strong>自定义类加载器</strong> java.lang.classloder    通过继承java.lang.ClassLoader类的方式<h4 id="关系："><a href="#关系：" class="headerlink" title="关系："></a>关系：</h4>启动类加载器，由C++实现，没有父类。<br>拓展类加载器(ExtClassLoader)，由Java语言实现，父类加载器为null<br>系统类加载器(AppClassLoader)，由Java语言实现，父类加载器为ExtClassLoader<br>自定义类加载器，父类加载器肯定为AppClassLoader。</li></ol><h3 id="双亲委派机制的加载流程是怎样的，有什么好处？"><a href="#双亲委派机制的加载流程是怎样的，有什么好处？" class="headerlink" title="双亲委派机制的加载流程是怎样的，有什么好处？"></a>双亲委派机制的加载流程是怎样的，有什么好处？</h3><ol><li>虚拟机类加载机制：虚拟机把描述类的数据从class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型。</li><li>类从被加载到JVM中开始，到卸载为止，整个生命周期包括：加载、验证、准备、解析、初始化、使用和卸载七个阶段。</li><li>类加载过程包括加载、验证、准备、解析和初始化五个阶段。</li><li>某个特定的类加载器在接到加载类的请求时，首先将加载任务委托给父类加载器，依次递归，如果父类加载器可以完成类加载任务，就成功返回；只有父类加载器无法完成此加载任务时，才自己去加载。</li><li>使用双亲委派模型的好处在于Java类随着它的类加载器一起具备了一种带有优先级的层次关系。保证了Java程序的稳定运行，可以避免类的重复加载(JVM区分不同类的方式不仅仅是类名，相同的类文件被不同的类加载器加载产生的是两个不同的类），也保证了Java的核心API不被篡改。每个类加载器加载自己有可能出现多个不同的但是名字相同的类。</li></ol><h3 id="简单讲一下类加载过程"><a href="#简单讲一下类加载过程" class="headerlink" title="简单讲一下类加载过程"></a>简单讲一下类加载过程</h3><ol><li>类加载过程包括加载、链接（验证、准备、解析）和初始化五个阶段。</li><li>加载：加载指的是把class字节码文件从各个来源通过类加载器装载入内存中。按照类加载器：一般包括启动类加载器，扩展类加载器，应用类加载器，以及用户的自定义类加载器。</li><li>验证：为了保证加载进来的字节流符合虚拟机规范，不会造成安全错误。文件格式的验证、元数据的验证、字节码的验证、符号引用的验证等</li><li>准备: 准备阶段是为类的静态变量分配内存，并将其初始化为默认值。</li><li>解析：把常量池中的符号引用转换为直接引用。</li><li>初始化：JVM负责主要对类变量(类变量就是static修改的变量)进行初始化。 方式：1.声明静态类变量时指定初始值    2.使用静态代码块为类变量指定初始值</li></ol><h3 id="Java8为什么用Metaspace替换掉PermGen？Metaspace保存在哪里？"><a href="#Java8为什么用Metaspace替换掉PermGen？Metaspace保存在哪里？" class="headerlink" title="Java8为什么用Metaspace替换掉PermGen？Metaspace保存在哪里？"></a>Java8为什么用Metaspace替换掉PermGen？Metaspace保存在哪里？</h3><ol><li>整个永久代有一个JVM本身设置的固定大小上限，无法进行调整，而原空间使用的是直接内存，受本机可用内存的限制，并且永远不会得到java.lang.OutOfMemoryError。Metaspace将根据运行时的应用程序需求动态地调整大小。</li><li>元空间并不在虚拟机中，而是使用本地内存。</li></ol><h3 id="编译期会对指令做那些优化（简单描述编译器的指令重排）"><a href="#编译期会对指令做那些优化（简单描述编译器的指令重排）" class="headerlink" title="编译期会对指令做那些优化（简单描述编译器的指令重排）"></a>编译期会对指令做那些优化（简单描述编译器的指令重排）</h3><p>在执行程序时为了提高性能，编译器和处理器常常会对指令做重排序。重排序分三种类型：</p><ol><li>编译器优化的重排序<br> 编译器在不改变单线程程序语义的前提下（代码中不包含synchronized关键字），可以重新安排语句的执行顺序。</li><li>指令级并行的重排序<br> 现代处理器采用了指令级并行技术（Instruction-Level Parallelism， ILP）来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。    </li><li>内存系统的重排序。<br> 由于处理器使用缓存和读/写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。</li></ol><h3 id="简单描述一下volatile可以解决什么问题？如何做到的"><a href="#简单描述一下volatile可以解决什么问题？如何做到的" class="headerlink" title="简单描述一下volatile可以解决什么问题？如何做到的"></a>简单描述一下volatile可以解决什么问题？如何做到的</h3><ol><li>重排序是指编译器和处理器为了优化程序性能而对指令序列进行排序的一种手段。用volatile修饰共享变量，在编译时，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序。</li><li>强制主内存读写同步，保证共享变量对所有线程的可见性。1.当写一个volatile变量时，JMM会把该线程对应的本地内存中的变量强制刷新到主内存中去；2.这个写会操作会导致其他线程中的缓存无效。</li></ol><h3 id="简单描述一下GC的分代回收"><a href="#简单描述一下GC的分代回收" class="headerlink" title="简单描述一下GC的分代回收"></a>简单描述一下GC的分代回收</h3><ol><li>Java的堆内存被分代回收，分代管理是为了方便垃圾回收。 1.大部分对象很快就不再使用；2.还有一部分不会立即无用，也不会持续很长时间。</li><li>虚拟机划分为年轻代、老年代、永久代。</li><li>年轻代主要存放新创建的对象，年轻代分为Eden区和了两个Survivor区。大部分对象在Eden区中生成。当Eden区满了，还存活的对象会在两个Survivor区中交替保存，达到一定次数会晋升到老年代。</li><li>老年代用来存放从年轻代晋升而来的，存活时间较长的对象。</li><li>永久代，主要保存类信息等内容，这里的永久代是指对象划分方式，不是专指 1.7 的 PermGen，或者 1.8 之后的 Metaspace。</li><li>根据年轻代与老年代的特点，JVM 提供了不同的垃圾回收算法。垃圾回收算法按类型可以分为引用计数法、复制法和标记清除法。</li><li>JVM 中提供的年轻代回收算法 Serial、ParNew、Parallel Scavenge都是复制算法，而 CMS、G1、ZGC 都属于标记清除算法。</li></ol><h3 id="G1垃圾回收算法和CMS的区别有哪些？"><a href="#G1垃圾回收算法和CMS的区别有哪些？" class="headerlink" title="G1垃圾回收算法和CMS的区别有哪些？"></a>G1垃圾回收算法和CMS的区别有哪些？</h3><blockquote><p>CMS：以获取最短回收停顿时间为目标的收集器，基于并发“标记清理”实现。    优点是并发收集，停顿小。</p></blockquote><p>过程：</p><ol><li>初始标记：独占CPU，仅标记GCroots能直接关联的对象</li><li>并发标记：可以和用户线程并行执行，标记所有可达对象</li><li>重新标记：独占CPU(STW)，对并发标记阶段用户线程运行产生的垃圾对象进行标记修正</li><li>并发清理：可以和用户线程并行执行，清理垃圾</li></ol><blockquote><p>G1：是一款面向服务端应用的垃圾收集器    并行于并发    分代收集    可预测的停顿</p></blockquote><p>过程：</p><ol><li>初始标记（Initial Making）</li><li>并发标记（Concurrent Marking）</li><li>最终标记（Final Marking）</li><li>筛选回收（Live Data Counting and Evacuation）</li></ol><h3 id="对象引用有哪几种方式，有什么特点？"><a href="#对象引用有哪几种方式，有什么特点？" class="headerlink" title="对象引用有哪几种方式，有什么特点？"></a>对象引用有哪几种方式，有什么特点？</h3><ol><li>强引用    代码中普遍存在的类似”Object obj = new Object()”这类的引用，只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象。</li><li>软引用    描述有些还有用但并非必需的对象。在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围进行二次回收。如果这次回收还没有足够的内存，才会抛出内存溢出异常。Java中的类SoftReference表示软引用。</li><li>弱引用        描述非必需对象。被弱引用关联的对象只能生存到下一次垃圾回收之前，垃圾收集器工作之后，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。Java中的类WeakReference表示弱引用。</li><li>虚引用    这个引用存在的唯一目的就是在这个对象被收集器回收时收到一个系统通知，被虚引用关联的对象，和其生存时间完全没关系。Java中的类PhantomReference表示虚引用。</li></ol><h3 id="简单说一下Java对象的创建过程"><a href="#简单说一下Java对象的创建过程" class="headerlink" title="简单说一下Java对象的创建过程"></a>简单说一下Java对象的创建过程</h3><ol><li>类加载检查   检查这个指令的参数是否能在常量池中定位到这个类的符号引用，并且检查符号引用代表的类是否已被加载、解析、初始化。若没有则执行类加载过程。</li><li>分配内存    虚拟机为新生对象分配内存。分配方式有”指针碰撞”和”空闲列表”两种，选取何种由Java堆是否规整决定，Java堆是否规整由所采用的垃圾收集器是否带有压缩整理功能决定。   内存分配并发问题两种方式保证线程安全： CAS+失败重试（CAS十的一种实现方式，虚拟机采用CAS配上失败重试的方式保证操作的原子性）  TLAB </li><li>初始化零值   虚拟机将分配的内存初始化为零值（不包括对象头）确保对象实例字段可不赋初值直接使用。</li><li>设置对象头    对对象进行设置 如这个对象是那个的实例 对象的hash码等</li><li>执行init方法  按照程序员的意愿进行初始化</li></ol><h3 id="如何判断对象是否已经死亡"><a href="#如何判断对象是否已经死亡" class="headerlink" title="如何判断对象是否已经死亡"></a>如何判断对象是否已经死亡</h3><ol><li>引用计数法    给对象加引用计数器，计数器为0的对象就是不可能再被使用的。</li><li>可达性分析算法   通过一系列的称为”GC Roots”的对象作为起点，从这些节点向下搜索，节点走过的路径称为引用链，当一个对象到GC Roots没有任何应用链相连，此对象不可用。</li></ol><h3 id="内存泄漏-内存溢出-解决或者避免的方法"><a href="#内存泄漏-内存溢出-解决或者避免的方法" class="headerlink" title="内存泄漏 内存溢出 解决或者避免的方法"></a>内存泄漏 内存溢出 解决或者避免的方法</h3><h4 id="内存泄露"><a href="#内存泄露" class="headerlink" title="内存泄露"></a>内存泄露</h4><p>是指程序在申请内存后，无法释放已申请的内存空间就造成了内存泄漏，一次内存泄漏似乎不会有大的影响，但内存泄漏堆积后的后果就是内存溢出。</p><h4 id="内存溢出"><a href="#内存溢出" class="headerlink" title="内存溢出"></a>内存溢出</h4><p>指程序申请内存时，没有足够的内存供申请者使用，或者说，给了你一块存储int类型数据的存储空间，但是你却存储long类型的数据，那么结果就是内存不够用，此时就会报错OOM,即所谓的内存溢出，简单来说就是自己所需要使用的空间比我们拥有的内存大内存不够使用所造成的内存溢出。</p><p>内存泄漏一般分为 常发性内存泄漏、偶发性内存泄漏、一次性内存泄漏、隐式内存泄漏。</p><p> <strong>解决方法</strong>：</p><ol><li>资源性对象在不使用的时候，应该调用它的close()函数将其关闭掉        </li><li>避免集中创建对象尤其是大对象，如果可以的话尽量使用流操作。</li></ol><h4 id="内存溢出原因"><a href="#内存溢出原因" class="headerlink" title="内存溢出原因"></a>内存溢出原因</h4><ol><li>内存中加载的数据量过于庞大，如一次从数据库取出过多数据；</li><li>集合类中有对对象的引用，使用完后未清空，产生了堆积，使得JVM不能回收；</li><li>代码中存在死循环或循环产生过多重复的对象实体；</li><li>使用的第三方软件中的BUG；</li><li>启动参数内存值设定的过小</li></ol><h4 id="内存溢出的解决方案"><a href="#内存溢出的解决方案" class="headerlink" title="内存溢出的解决方案"></a>内存溢出的解决方案</h4><ol><li>修改JVM启动参数，直接增加内存。(-Xms，-Xmx参数一定不要忘记加。)</li><li>检查错误日志，查看“OutOfMemory”错误前是否有其 它异常或错误。</li><li>对代码进行走查和分析，找出可能发生内存溢出的位置。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java集合相关面试题</title>
      <link href="2020/10/02/Java%E9%9B%86%E5%90%88%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>2020/10/02/Java%E9%9B%86%E5%90%88%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h3 id="map-HashMap-HashTable-ConcurrentHashMap-必须阅读源码，必问题目"><a href="#map-HashMap-HashTable-ConcurrentHashMap-必须阅读源码，必问题目" class="headerlink" title="map HashMap  HashTable  ConcurrentHashMap (必须阅读源码，必问题目)"></a>map HashMap  HashTable  ConcurrentHashMap (必须阅读源码，必问题目)</h3><ol><li>父类不同  HashTable 继承 Dictionary，    HashMap 继承 abstractMap，它们都是Map接口的实现类 ，都是键值对集合。</li><li>最重要的区别：多线程同步特性不同    HashMap同一时间允许多个线程同时进行操作，效率相对较高 但是可能出现并发错误；Hashtable 同一时间只允许一个线程进行操作，效率相对较低 但是不会出现并发错误。</li><li>它们对于null的处理不同 HashMap 无论主键还是值对象，都可以存放null，只不过主键要求唯一，所以只能存放一个null；Hashtable对null零容忍，无论主键还是值 都不能添加null，否则直接出现异常。</li><li>它们底层实现的细节不同 HashMap 底层默认分16个小组 分组组数可以指定，但最终结果一定是2的n次方数（为什么呢）因为计算散列小组的时候 使用：x &amp; (分组组数-1)，效率高；    Hashtable 底层默认分11个小组，分组组数可以任意指定，计算散列小组的时候 使用：x %分组组数。</li><li>底层数据结构 JDK 1.8 前， 两者【底层数据结构】 = 【链表 + 数组 】；JDK1.8之后 HashMap 底层数据结构变化 ，链表长度过长(默认超过8时)，则链表树化为红黑树，提高搜索效率。</li><li>它们出现的版本不同     HashMap since JDK1.2；    Hashtable since JDK1.0</li></ol><h3 id="说说String中hashcode的实现"><a href="#说说String中hashcode的实现" class="headerlink" title="说说String中hashcode的实现"></a>说说String中hashcode的实现</h3><p><strong>源码：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> h = hash;</span><br><span class="line"><span class="keyword">if</span> (h == <span class="number">0</span> &amp;&amp; value.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">char</span> val[] = value;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; value.length; i++) &#123;</span><br><span class="line">        h = <span class="number">31</span> * h + val[i];</span><br><span class="line">    &#125;</span><br><span class="line">    hash = h;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>String类中的hashCode计算方法还是比较简单的，就是以31为权，每一位为字符的ASCII值进行运算，用自然溢出来等效取模。</p><p>哈希计算公式可以计为s[0]*31^(n-1) + s[1]*31^(n-2) + … + s[n-1]</p><h4 id="那为什么以31为质数"><a href="#那为什么以31为质数" class="headerlink" title="那为什么以31为质数"></a>那为什么以31为质数</h4><p>主要是因为31是一个奇质数，所以31<em>i=32</em>i-i=(i&lt;&lt;5)-i，这种位移与减法结合的计算相比一般的运算快很多。</p><h3 id="说说jdk1-8中hashmap有什么变化"><a href="#说说jdk1-8中hashmap有什么变化" class="headerlink" title="说说jdk1.8中hashmap有什么变化"></a>说说jdk1.8中hashmap有什么变化</h3><ol><li>由数组+链表的结构改为数组+链表+红黑树。</li><li>优化了高位运算的hash算法：h^(h&gt;&gt;&gt;16)</li><li>扩容后，元素要么是在原位置，要么是在原位置再移动2次幂的位置，且链表顺序不变。<br> 发生hash碰撞时，java 1.7 会在链表的头部插入，而java 1.8会在链表的尾部插入。<br> 在java 1.8中，Entry被Node替代(换了一个马甲）<br>最后一条是重点，因为最后一条的变动，hashmap在1.8中，不会在出现死循环问题。</li></ol><h4 id="为什么在解决hash冲突的时候，不直接用红黑树，-而选择先用链表，再转红黑树"><a href="#为什么在解决hash冲突的时候，不直接用红黑树，-而选择先用链表，再转红黑树" class="headerlink" title="为什么在解决hash冲突的时候，不直接用红黑树， 而选择先用链表，再转红黑树"></a>为什么在解决hash冲突的时候，不直接用红黑树， 而选择先用链表，再转红黑树</h4><p>因为红黑树需要进行左旋，右旋，变色这些操作来保持平衡，而单链表不需要。 当元素小于8个当时候，此时做查询操作，链表结构已经能保证查询性能。<br>当元素大于8个的时候，此时需要红黑树来加快查询速度，但是新增节点的效率变慢了。<br>因此，如果一开始就用红黑树结构，元素太少，新增效率又比较慢，无疑这是浪费性能的。</p><h4 id="我不用红黑树，用二叉查找树可以么"><a href="#我不用红黑树，用二叉查找树可以么" class="headerlink" title="我不用红黑树，用二叉查找树可以么"></a>我不用红黑树，用二叉查找树可以么</h4><p>可以。但是二叉查找树在特殊情况下会变成一条线性结构（这就跟原来使用链表结构一样了，造成很深的问题），遍历查找会非常慢。</p><h3 id="当链表转为红黑树后，什么时候退化为链表"><a href="#当链表转为红黑树后，什么时候退化为链表" class="headerlink" title="当链表转为红黑树后，什么时候退化为链表"></a>当链表转为红黑树后，什么时候退化为链表</h3><p>为6的时候退转为链表。中间有个差值7可以防止链表和树之间频繁的转换。<br>假设一下，如果设计成链表个数超过8则链表转换成树结构，链表个数小于8则树结构转换成链表，<br>如果一个HashMap不停的插入、删除元素，链表个数在8左右徘徊，就会频繁的发生树转链表、链表转树，效率会很低。</p><h3 id="HashMap在并发编程环境下有什么问题"><a href="#HashMap在并发编程环境下有什么问题" class="headerlink" title="HashMap在并发编程环境下有什么问题"></a>HashMap在并发编程环境下有什么问题</h3><ol><li>多线程扩容，引起的死循环问题</li><li>多线程put的时候可能导致元素丢失</li><li>put非null元素后get出来的却是null<h3 id="在jdk1-8中还有这些问题么"><a href="#在jdk1-8中还有这些问题么" class="headerlink" title="在jdk1.8中还有这些问题么"></a>在jdk1.8中还有这些问题么</h3>在jdk1.8中，死循环问题已经解决。其他两个问题还是存在。</li></ol><h3 id="你一般怎么解决这些问题的？"><a href="#你一般怎么解决这些问题的？" class="headerlink" title="你一般怎么解决这些问题的？"></a>你一般怎么解决这些问题的？</h3><p>比如ConcurrentHashmap，Hashtable等线程安全等集合类。</p><h3 id="解决hash冲突的方法"><a href="#解决hash冲突的方法" class="headerlink" title="解决hash冲突的方法"></a>解决hash冲突的方法</h3><p>比较出名的有四种</p><ol><li> 开放定址法    一旦发生了冲突，就去寻找下一个空的散列地址，只要散列表足够大，空的散列地址总能找到，并将记录存入.</li><li> 链地址法     链地址法的基本思想是：每个哈希表节点都有一个next指针，多个哈希表节点可以用next指针构成一个单向链表，被分配到同一个索引上的多个节点可以用这个单向链表连接起来。</li><li>再哈希法  再哈希法又叫双哈希法，有多个不同的Hash函数，当发生冲突时，使用第二个，第三个，….，等哈希函数计算地址，直到无冲突。虽然不易发生聚集，但是增加了计算时间。</li><li>公共溢出区域法    将哈希表分为基本表和溢出表两部分，凡是和基本表发生冲突的元素，一律填入溢出表。</li></ol><h3 id="几种数组copy方法的速度差异"><a href="#几种数组copy方法的速度差异" class="headerlink" title="几种数组copy方法的速度差异"></a>几种数组copy方法的速度差异</h3><ol><li>for 循环逐一复制        for循环适合于小型数组</li><li>System.arraycopy()</li><li>Arrays.copyOf()        本质上调用的是System.arraycopy(）方法</li><li>使用clone()        Object类中的一个本地方法，这里虽然返回Object，看着需要强制类型转换，但Object子类重写了这个方法，会返回相应的类型。</li></ol><h3 id="ConcurrentHashMap-在-JDK-1-8-中，为什么要使用内置锁-synchronized-来代替重入锁-ReentrantLock？"><a href="#ConcurrentHashMap-在-JDK-1-8-中，为什么要使用内置锁-synchronized-来代替重入锁-ReentrantLock？" class="headerlink" title="ConcurrentHashMap 在 JDK 1.8 中，为什么要使用内置锁 synchronized 来代替重入锁 ReentrantLock？"></a>ConcurrentHashMap 在 JDK 1.8 中，为什么要使用内置锁 synchronized 来代替重入锁 ReentrantLock？</h3><ol><li>粒度降低了；</li><li>JVM 开发团队没有放弃 synchronized，而且基于 JVM 的 synchronized 优化空间更大，更加自然。</li><li>在大量的数据操作下，对于 JVM 的内存压力，基于 API 的 ReentrantLock 会开销更多的内存。            </li></ol>]]></content>
      
      
      <categories>
          
          <category> 面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基础面试题</title>
      <link href="2020/10/01/Java%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>2020/10/01/Java%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="String-StringBuffer-StringBuilder"><a href="#String-StringBuffer-StringBuilder" class="headerlink" title="String StringBuffer StringBuilder"></a>String StringBuffer StringBuilder</h2><ol><li>运行速度快慢为：StringBuilder &gt; StringBuffer &gt; String </li><li>操作数量较少的字符串用String，不可修改的字符串；<br>在单线程且操作大量字符串用StringBuilder,速度快，但线程不安全，可修改；<br>在多线程且操作大量字符串用StringBuffer，线程安全，可修改。</li><li>for循环中追加字符串  IDEA会提示使用StringBuilder</li><li>扩容机制：StringBuffer/StringBuilder在没有传参的情况下默认初始容量是16；有参数的情况下，初始容量是16+字符串的长度，并且是用append（）方法追加的字符。ensureCapacityInternal（）int newCapacity = (value.length &lt;&lt; 1) + 2；增加为自身长度的一倍然后再加2；这个时候如果还是放不下，那就直接扩容到它需要的长度  newCapacity = minCapacity;</li></ol><h2 id="包装类-基本数据类型、-拆箱装箱、常量池缓存机制"><a href="#包装类-基本数据类型、-拆箱装箱、常量池缓存机制" class="headerlink" title="包装类 基本数据类型、 拆箱装箱、常量池缓存机制"></a>包装类 基本数据类型、 拆箱装箱、常量池缓存机制</h2><ol><li>包装类是对象，有自己的方法，默认值为null</li><li>存储位置不同，基本数据类型直接将值保存在值栈中，而包装类型是把对象放在堆中，然后通过对象的引用来调用</li><li>装箱就是将基本数据类型包装成包装类型，拆箱就是反过来将包装类型拆成基本数据类型。</li><li>装箱过程是通过调用包装类的valueOf方法实现的，而拆箱过程是通过调用包装器的 xxxValue方法实现的。（其中xxx代表对应的基本数据类型）</li><li>常量池的缓存机制：Double 和 Float 无 ；Boolean类型的比较类似单纯地比较他们的值是否相等。</li></ol><h2 id="如何理解java中只有值传递"><a href="#如何理解java中只有值传递" class="headerlink" title="如何理解java中只有值传递"></a>如何理解java中只有值传递</h2><ol><li>基本类型传递的是值的副本，引用类型传递的是引用的副本。</li><li>java中不管是值对象还是引用对象都是值传递，在其他方法里面改变引用类型的值肯定是通过引用改变的，当传递引用对象的时候传递的是复制过的对象句柄(引用)，注意这个引用是复制过的，也就是说又在内存中复制了一份句柄，这时候有两个句柄是指向同一个对象的，所以你改变这个句柄对应空间的数据会影响外部的变量的，虽然是复制的但是引用指向的是同一个地址，当你把这个句柄指向其他对象的引用时并不会改变原对象，因为你拿到的句柄是复制过的引用。<br>总结java中的句柄(引用)是复制过的，所以说java只有值传递。</li></ol><h2 id="十进制的数在内存中是怎么存的"><a href="#十进制的数在内存中是怎么存的" class="headerlink" title="十进制的数在内存中是怎么存的"></a>十进制的数在内存中是怎么存的</h2><p>  基于补码</p><h2 id="java8新特性"><a href="#java8新特性" class="headerlink" title="java8新特性"></a>java8新特性</h2><ol><li>Lambda 表达式 − Lambda 允许把函数作为一个方法的参数（函数作为参数传递到方法中）。 .sort()等</li><li>Stream API −新添加的Stream API（java.util.stream） 把真正的函数式编程风格引入到Java中。 例子：list.stream().filter().collect(Collectors.toList());</li><li>LocalDate和LocalTime类</li></ol><h2 id="和equals之间的区别"><a href="#和equals之间的区别" class="headerlink" title="==和equals之间的区别"></a>==和equals之间的区别</h2><ol><li>种类不同        ==：运算符        equals:是Object类里面的一个方法</li><li>作用不同       ==：既可以比较基本数据类型（比较数值） 又可以比较引用数据类型（比较地址）  equals:只能比较引用数据类型，表示如何制定一个类型的比较规则,可以按照自己的意愿修改比较规则   比如：String类型比较字符串的内容</li></ol><h2 id="为什么重写euqals-方法-必须重写-hashCode"><a href="#为什么重写euqals-方法-必须重写-hashCode" class="headerlink" title="为什么重写euqals 方法 必须重写 hashCode()"></a>为什么重写euqals 方法 必须重写 hashCode()</h2><ol><li>两个对象 hashCode() 所得hash值相等 ， 但equals()方法不一定返回true</li><li>两个对象 equals() 返回true，那么对象调用hashCode()返回的hash值一定相等</li><li>如果 仅重写 equals(),而不重写hashcode(),则存在 equals方法会返回true，而hashcode()方法返回的hash值不相等</li><li>为了保证同一个对象，保证在equals相同的情况下hashcode值必定相同，如果重写了equals而未重写hashcode方法，可能就会出现两个没有关系的对象equals相同的</li><li>lombok插件 @Data 自动重写 hashCode() equals() toString()方法</li></ol><h2 id="面向对象-特征、六原则一法则"><a href="#面向对象-特征、六原则一法则" class="headerlink" title="面向对象  特征、六原则一法则"></a>面向对象  特征、六原则一法则</h2><ol><li>面向对象的特征：封装 继承 多态 。封装：隐藏对象的属性和实现细节，仅对外提供公共访问方式，将变化隔离，便于使用，提高复用性和安全性。继承：提高代码复用性；继承是多态的前提。多态：父类或接口定义的引用变量可以指向子类或具体实现类的实例对象。提高了程序的拓展性。</li><li>单一职责原则：一个类只做它该做的事情。”高内聚”</li><li>开闭原则：软件实体应当对扩展开放，对修改关闭。</li><li>依赖倒转原则：面向接口编程。（该原则说得直白和具体一些就是声明方法的参数类型、方法的返回类型、变量的引用类型时，尽可能使用抽象类型而不用具体类型，因为抽象类型可以被它的任何一个子类型所替代，请参考下面的里氏替换原则。）</li><li>里氏替换原则：任何时候都可以用子类型替换掉父类型。简单的说就是能用父类型的地方就一定能使用子类型。</li><li>接口隔离原则：接口要小而专，绝不能大而全。</li><li>聚合复用原则：优先使用聚合关系复用代码。</li><li>迪米特法则：迪米特法则又叫最少知识原则，一个对象应当对其他对象有尽可能少的了解。（迪米特法则简单的说就是如何做到”低耦合”，门面模式和调停者模式就是对迪米特法则的践行。)</li></ol><h2 id="Java泛型所给予的编译期检查"><a href="#Java泛型所给予的编译期检查" class="headerlink" title="Java泛型所给予的编译期检查"></a>Java泛型所给予的编译期检查</h2><p>Java泛型所给予的编译期检查，是根据该泛型对象的引用类型来定的，如果泛型类对象的引用类型的&lt; &gt;里有具体类型，那么就会执行相应的编译期检查。<br>在编译之后程序会采取去泛型化的措施。也就是说Java中的泛型，只在编译阶段有效。在编译过程中，正确检验泛型结果后，会将泛型的相关信息擦出，并且在对象进入和离开方法的边界处添加类型检查和类型转换的方法。也就是说，泛型信息不会进入到运行时阶段。</p><h2 id="java是解释型语言还是编译型语言？"><a href="#java是解释型语言还是编译型语言？" class="headerlink" title="java是解释型语言还是编译型语言？"></a>java是解释型语言还是编译型语言？</h2><p>有人说Java是编译型的。因为所有的Java代码都是要编译的，.java不经过编译就无法执行。<br>也有人说Java是解释型的。因为java代码编译后不能直接运行，它是解释运行在JVM上的，所以它是解释型的。<br>对于C和C++，它们经过一次编译之后，可以由操作系统直接执行，所以它们是编译型语言。而Java不一样，它首先由编译器编译成.class（字节码）文件，然后在通过JVM从.class文件中读一行解释执行一行，所以它是解释型的语言。也正是由于java对于多种不同的操作系统有不同的JVM，所以实现了真正意义上的跨平台。</p><h2 id="finalize方法是Object提供的的实例方法，使用规则如下"><a href="#finalize方法是Object提供的的实例方法，使用规则如下" class="headerlink" title="finalize方法是Object提供的的实例方法，使用规则如下"></a>finalize方法是Object提供的的实例方法，使用规则如下</h2><ol><li>当对象不再被任何对象引用时，GC会调用该对象的finalize()方法</li><li>finalize()是Object的方法，子类可以覆盖这个方法来做一些系统资源的释放或者数据的清理</li><li>可以在finalize()让这个对象再次被引用，避免被GC回收；但是最常用的目的还是做cleanup</li><li>Java不保证这个finalize()一定被执行；但是保证调用finalize的线程没有持有任何user-visible同步锁。</li><li>在finalize里面抛出的异常会被忽略，同时方法终止。</li><li>当finalize被调用之后，JVM会再一次检测这个对象是否能被存活的线程访问得到，如果不是，则清除该对象。也就是finalize只能被调用一次；也就是说，覆盖了finalize方法的对象需要经过两个GC周期才能被清除。</li></ol><h2 id="深拷贝和浅拷贝有什么区别"><a href="#深拷贝和浅拷贝有什么区别" class="headerlink" title="深拷贝和浅拷贝有什么区别"></a>深拷贝和浅拷贝有什么区别</h2><ol><li>浅拷贝：复制基本类型的属性；引用类型的属性复制，复制栈中的变量 和 变量指向堆内存中的对象的指针，不复制堆内存中的对象。</li><li>深拷贝：复制基本类型的属性；引用类型的属性复制，复制栈中的变量 和 变量指向堆内存中的对象的指针和堆内存中的对象。</li><li>可以说一下BeanUtils.copyProperties()    Arrays.copyOf() clone()等</li></ol><h2 id="Class类的作用"><a href="#Class类的作用" class="headerlink" title="Class类的作用"></a>Class类的作用</h2><ol><li>Class类是一个比较特殊的类。特殊在这是一个在类加载过程中由虚拟机生成的，由于表示被加载类的类型信息的对象。简单地说，我们创建一个int变量，那么这个int变量是个整数类型，那么我们怎么知道这个类型是整数类型呢？就是通过这个Class类来知道的。java是面向对象编程的，java中几乎所有的数据都是对象，那么是对象，就必须知道自己到底是哪一种类型的对象。于是Class类便顺势而生了。</li><li>Class类的作用，本质上讲，就是前面所说的，它代表着一个类的类型信息。正是因为这个特殊作用的存在，Class类能够实现它所代表的这个类的所有功能，包括创建这个类的实例，获得所有的构造函数，方法，字段值等等，可以说无所不能。</li></ol><h2 id="什么是反射机制，有什么作用"><a href="#什么是反射机制，有什么作用" class="headerlink" title="什么是反射机制，有什么作用"></a>什么是反射机制，有什么作用</h2><ol><li>在Java环境中，反射机制允许程序在执行时获取某个类自身的定义信息，也可以实现动态创建类的对象、变更属性的内容或执行特定的方法的功能。从而使Java具有动态语言的特性，增强了程序的灵活性和可移植性。</li><li>Java反射机制主要用于实现以下功能。1.在运行时判断任意一个对象所属的类型。2.在运行时构造任意一个类的对象。3.在运行时判断任意一个类所具有的成员变量和方法。4.在运行时调用任意一个对象的方法，甚至可以调用private方法。</li><li>实现Java反射机制的API在Java.lang.reflect包下，具有以下几点。1. Class类：代表一个类。2. Filed类：代表类的成员变量。3.Method类：代表类的方法。4.Constructor类：代表类的构造方法。5.Array类：提供了动态创建数组及访问数组元素的静态方法。该类中的所有方法都是静态的。</li><li>Spring通过反射创建对象，并将对象放到spring ioc容器中；Spring的拦截器也是基于反射实现的；</li></ol><h2 id="Synchronized-lock-volatile"><a href="#Synchronized-lock-volatile" class="headerlink" title="Synchronized lock volatile"></a>Synchronized lock volatile</h2><p>synchronized修饰静态方法以及同步代码块   synchronized (类.class)用法锁的是类，线程想要执行对应同步代码，需要获得类锁。<br>synchronized修饰成员方法，线程获取的是当前调用该方法的对象实例的对象锁。</p><h2 id="synchronized关键字和volatile关键字比较"><a href="#synchronized关键字和volatile关键字比较" class="headerlink" title="synchronized关键字和volatile关键字比较"></a>synchronized关键字和volatile关键字比较</h2><p>volatile关键字是线程同步的轻量级实现，所以volatile性能肯定比synchronized关键字要好。<br>但是volatile关键字只能用于变量，而synchronized关键字可以修饰方法以及代码块。<br>synchronized关键字在JavaSE 1.6之后进行了主要包括为了减少获得锁和释放锁带来的性能消耗而引入的偏向锁和轻量级锁以及其它各种优化之后执行效率有了显著提升，实际开发中使用 synchronized 关键字的场景还是更多一些。</p><p>多线程访问volatile关键字不会发生阻塞，而synchronized关键字可能会发生阻塞。<br>volatile关键字能保证数据的可见性，但不能保证数据的原子性。synchronized关键字两者都能保证。<br>volatile关键字主要用于解决变量在多个线程之间的可见性，而 synchronized关键字解决的是多个线程之间访问资源的同步性。</p><h2 id="既然有了字节流，为什么还要有字符流"><a href="#既然有了字节流，为什么还要有字符流" class="headerlink" title="既然有了字节流，为什么还要有字符流"></a>既然有了字节流，为什么还要有字符流</h2><p>字符流是由JVM将字节转换得到的，所以这个过程还是非常耗时的，字节流在处理时是逐个字节读取，在读取汉字时会出现乱码问题。<br>图片和音频这些文件用字节流比较好，涉及到字符的使用字符流比较好。</p>]]></content>
      
      
      <categories>
          
          <category> 面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
